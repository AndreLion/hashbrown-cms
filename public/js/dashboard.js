/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 269);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper class for making HTTP/S requests
 *
 * @memberof HashBrown.Client.Helpers
 */

var RequestHelper =
/*#__PURE__*/
function () {
  function RequestHelper() {}

  /**
   * An environment specific request
   *
   * @param {String} method
   * @param {String} url
   * @param {Object} data
   *
   * @returns {Promise} Response
   */
  RequestHelper.request = function request(method, url, data) {
    return RequestHelper.customRequest(method, RequestHelper.environmentUrl(url), data);
  };
  /**
   * Uploads a file
   *
   * @param {String} url
   * @param {String} type
   * @param {FormData} data
   *
   * @returns {Promise} Response
   */


  RequestHelper.uploadFile = function uploadFile(url, type, data) {
    return new Promise(function (resolve, reject) {
      $.ajax({
        url: RequestHelper.environmentUrl(url),
        type: 'POST',
        data: data,
        processData: false,
        contentType: false,
        success: function success(response) {
          resolve(response);
        },
        error: function error(e) {
          reject(e);
        }
      });
    }); //return RequestHelper.customRequest('POST', RequestHelper.environmentUrl(url), data, { 'Content-Type': type });
  };
  /**
   * An environment-independent request
   *
   * @param {String} method
   * @param {String} url
   * @param {Object} data
   * @param {Object} headers
   *
   * @returns {Promise} Response
   */


  RequestHelper.customRequest = function customRequest(method, url, data, headers) {
    headers = headers || {
      'Content-Type': 'application/json; charset=utf-8'
    };
    return new Promise(function (resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open(method.toUpperCase(), url);

      for (var k in headers) {
        xhr.setRequestHeader(k, headers[k]);
      }

      if (data) {
        if (typeof data === 'object' && data instanceof FormData === false) {
          data = JSON.stringify(data);
        }

        xhr.send(data);
      } else {
        xhr.send();
      }

      xhr.onreadystatechange = function () {
        var DONE = 4;
        var OK = 200;
        var NOT_MODIFIED = 304;
        var UNAUTHORIZED = 403;

        if (xhr.readyState === DONE) {
          if (xhr.status === UNAUTHORIZED) {
            location = '/login/?path=' + location.pathname + location.hash;
            reject(new Error('User is not logged in'));
          } else if (xhr.status == OK || xhr.status == NOT_MODIFIED) {
            var response = xhr.responseText;

            if (response && response != 'OK') {
              try {
                response = JSON.parse(response);
              } catch (e) {// If the response isn't JSON, then so be it
              }
            }

            if (response === '') {
              response = null;
            }

            resolve(response);
          } else {
            var error = new Error(xhr.responseText);
            error.statusCode = xhr.status;
            reject(error);
          }
        }
      };
    });
  };
  /**
   * Wraps a URL to include environment
   *
   * @param {String} url
   */


  RequestHelper.environmentUrl = function environmentUrl(url) {
    var newUrl = '/api/';

    if (HashBrown.Helpers.ProjectHelper.currentProject) {
      newUrl += HashBrown.Helpers.ProjectHelper.currentProject + '/';
    }

    if (HashBrown.Helpers.ProjectHelper.currentEnvironment) {
      newUrl += HashBrown.Helpers.ProjectHelper.currentEnvironment + '/';
    }

    newUrl += url;
    return newUrl;
  };
  /**
   * Listens for server restart
   */


  RequestHelper.listenForRestart = function listenForRestart() {
    UI.messageModal('Restart', 'HashBrown is restarting...', false);

    function poke() {
      $.ajax({
        type: 'get',
        url: '/',
        success: function success() {
          location.reload();
        },
        error: function error() {
          poke();
        }
      });
    }

    poke();
  };

  /**
   * Reloads a resource
   */
  RequestHelper.reloadResource = function reloadResource(name) {
    return RequestHelper.request('get', name).then(function (result) {
      window.resources[name] = result; // Apply correct model

      for (var i in window.resources[name]) {
        var object = window.resources[name][i];
        var model = null;

        switch (name) {
          case 'connections':
            model = new HashBrown.Models.Connection(object);
            break;

          case 'content':
            model = new HashBrown.Models.Content(object);
            break;

          case 'templates':
            model = new HashBrown.Models.Template(object);
            break;

          case 'forms':
            model = new HashBrown.Models.Form(object);
            break;

          case 'users':
            model = new HashBrown.Models.User(object);
            break;

          case 'media':
            model = new HashBrown.Models.Media(object);
            break;

          case 'schemas':
            model = HashBrown.Helpers.SchemaHelper.getModel(object);
            break;

          default:
            return Promise.reject(new Error('Resource "' + name + '" has no model defined'));
        }

        window.resources[name][i] = model;
      }

      return Promise.resolve(result);
    }).catch(function (e) {
      // If the error is a 404, it's an intended response from the controller
      if (e.statusCode !== 404) {
        UI.errorModal(e);
      }

      window.resources[name] = [];
      return Promise.resolve([]);
    });
  };

  /**
   * Reloads all resources
   */
  RequestHelper.reloadAllResources = function reloadAllResources() {
    $('.page--environment__spinner__messages').empty();
    var queue = ['content', 'schemas', 'media', 'connections', 'templates', 'forms', 'users'];

    for (var _i = 0; _i < queue.length; _i++) {
      var item = queue[_i];

      var $msg = _.div({
        class: 'widget--spinner__message',
        'data-name': item
      }, item);

      $('.page--environment__spinner__messages').append($msg);
    }

    var processQueue = function processQueue() {
      var name = queue.shift();
      return RequestHelper.reloadResource(name).then(function () {
        $('.page--environment__spinner__messages [data-name="' + name + '"]').toggleClass('loaded', true);

        if (queue.length < 1) {
          return Promise.resolve();
        } else {
          return processQueue();
        }
      });
    };

    return processQueue();
  };

  return RequestHelper;
}();

module.exports = RequestHelper;

/***/ }),
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper class for managing projects client side
 *
 * @memberof HashBrown.Client.Helpers
 */

var ProjectHelper = function ProjectHelper() {};

module.exports = ProjectHelper;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Path = __webpack_require__(9);

var Resource = __webpack_require__(11);
/**
 * The base class for all Media objects
 *
 * @memberof HashBrown.Common.Models
 */


var Media =
/*#__PURE__*/
function (_Resource) {
  _inheritsLoose(Media, _Resource);

  function Media() {
    return _Resource.apply(this, arguments) || this;
  }

  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */
  Media.paramsCheck = function paramsCheck(params) {
    params = _Resource.paramsCheck.call(this, params);
    delete params.remote;
    delete params.sync;
    delete params.isRemote;

    if (!params.folder) {
      params.folder = '/';
    }

    return params;
  };
  /**
   * Structure
   */


  var _proto = Media.prototype;

  _proto.structure = function structure() {
    this.def(String, 'id');
    this.def(String, 'icon', 'file-image-o');
    this.def(String, 'name');
    this.def(String, 'url');
    this.def(String, 'path');
    this.def(String, 'folder', '/');
  };
  /**
   * Read from file path
   *
   * @param {String} filePath
   */


  _proto.readFromFilePath = function readFromFilePath(filePath) {
    var name = Path.basename(filePath);
    var id = filePath; // Trim file path for id 

    id = id.replace('/' + name, '');
    id = id.substring(id.lastIndexOf('/') + 1); // Remove file extension

    name = name.replace(/\.[^/.]+$/, '');
    this.id = id;
    this.name = name;
    this.url = '/media/' + HashBrown.Helpers.ProjectHelper.currentProject + '/' + HashBrown.Helpers.ProjectHelper.currentEnvironment + '/' + id;
  };
  /**
   * Gets the content type header
   *
   * @returns {String} Content-Type header
   */


  _proto.getContentTypeHeader = function getContentTypeHeader() {
    var name = (this.name || '').toLowerCase();
    var extension = name.split('.');

    if (extension && extension.length > 0) {
      extension = extension[extension.length - 1];
    }

    switch (extension) {
      // Image types
      case 'jpg':
        return 'image/jpeg';

      case 'png':
        return 'image/png';

      case 'gif':
        return 'image/gif';

      case 'bmp':
        return 'image/bmp';
      // Audio types

      case 'm4a':
        return 'audio/m4a';

      case 'mp3':
        return 'audio/mp3';

      case 'ogg':
        return 'audio/ogg';

      case 'wav':
        return 'audio/wav';
      // Video types

      case 'mp4':
        return 'video/mp4';

      case 'webm':
        return 'video/webm';

      case 'avi':
        return 'video/avi';

      case 'mov':
        return 'video/quicktime';

      case 'bmp':
        return 'video/bmp';

      case 'wmv':
        return 'video/x-ms-wmv';

      case '3gp':
        return 'video/3gpp';

      case 'mkv':
        return 'video/x-matroska';
      // SVG

      case 'svg':
        return 'image/svg+xml';
      // PDF

      case 'pdf':
        return 'application/pdf';
      // Everything else

      default:
        return 'application/octet-stream';
    }
  };
  /**
   * Gets whether this is audio
   *
   * @returns {Boolean} Is audio
   */


  _proto.isAudio = function isAudio() {
    return this.getContentTypeHeader().indexOf('audio') > -1;
  };
  /**
   * Gets whether this is a video
   *
   * @returns {Boolean} Is video
   */


  _proto.isVideo = function isVideo() {
    return this.getContentTypeHeader().indexOf('video') > -1;
  };
  /**
   * Gets whether this is an image
   *
   * @returns {Boolean} Is image
   */


  _proto.isImage = function isImage() {
    return this.getContentTypeHeader().indexOf('image') > -1;
  };
  /**
   * Gets whether this is a PDF
   *
   * @returns {Boolean} Is PDF
   */


  _proto.isPdf = function isPdf() {
    return this.getContentTypeHeader().indexOf('pdf') > -1;
  };
  /**
   * Applies folder string from tree
   *
   * @param {Object} tree
   */


  _proto.applyFolderFromTree = function applyFolderFromTree(tree) {
    if (tree) {
      for (var i in tree) {
        var item = tree[i];

        if (item.id == this.id) {
          this.folder = item.folder;
          break;
        }
      }
    }
  };
  /**
   * Creates a new Media object
   *
   * @param {Object} file
   *
   * @return {Media} media
   */


  Media.create = function create(file) {
    var media = new Media({
      id: Media.createId()
    });
    return media;
  };

  return Media;
}(Resource);

module.exports = Media;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

var splitPath = function splitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function (path, ext) {
  var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  return splitPath(path)[3];
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Entity = __webpack_require__(12);
/**
 * Basic resource class
 *
 * @memberof HashBrown.Common.Models
 */


var Resource =
/*#__PURE__*/
function (_Entity) {
  _inheritsLoose(Resource, _Entity);

  function Resource() {
    return _Entity.apply(this, arguments) || this;
  }

  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */
  Resource.paramsCheck = function paramsCheck(params) {
    params = params || {}; // Convert from old sync variables

    params.sync = params.sync || {};

    if (typeof params.local !== 'undefined') {
      if (typeof params.sync.isRemote === 'undefined') {
        params.sync.hasRemote = params.local;
      }

      delete params.local;
    }

    if (typeof params.remote !== 'undefined') {
      if (typeof params.sync.isRemote === 'undefined') {
        params.sync.isRemote = params.remote;
      }

      delete params.remote;
    } // Convert from old "locked" state


    if (typeof params.locked !== 'undefined') {
      if (typeof params.isLocked === 'undefined') {
        params.isLocked = params.locked;
      }

      delete params.locked;
    }

    return params;
  };

  return Resource;
}(Entity);

module.exports = Resource;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crypto = __webpack_require__(13);
/**
 * The base class for everything
 *
 * @memberof HashBrown.Common.Models
 */


var Entity =
/*#__PURE__*/
function () {
  /**
   * Constructs an entity
   *
   * @param {Object} params
   */
  function Entity(params) {
    this.structure();
    params = this.constructor.paramsCheck(params);
    Object.seal(this);

    for (var k in params) {
      try {
        if (typeof params[k] !== 'undefined') {
          this[k] = params[k];
        }
      } catch (e) {
        debug.log(e.message, this, 4);
      }
    }
  }
  /**
   * Sets up a structure before sealing the object
   */


  var _proto = Entity.prototype;

  _proto.structure = function structure() {};
  /**
   * Checks the parameters berfore they're committed
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */


  Entity.paramsCheck = function paramsCheck(params) {
    return params;
  };
  /**
   * Generates a new random id
   *
   * @param {Number} length
   *
   * @returns {String} id
   */


  Entity.createId = function createId(length) {
    if (!length) {
      length = 20;
    }

    if (length < 4) {
      length = 4;
    }

    return crypto.randomBytes(length).toString('hex');
  };
  /**
   * Gets a copy of every field in this object as a mutable object
   *
   * @returns {Object} object
   */


  _proto.getObject = function getObject() {
    return JSON.parse(JSON.stringify(this));
  };
  /**
   * Defines a type safe member variable
   *
   * @param {String} type
   * @param {String} name
   * @param {Anything} defaultValue
   */


  _proto.def = function def(type, name, defaultValue) {
    var _this = this;

    if (typeof type !== 'function') {
      throw new TypeError('Parameter \'type\' cannot be of type \'' + typeof type + '\'.');
    }

    if (typeof name !== 'string') {
      throw new TypeError('Parameter \'name\' cannot be of type \'' + typeof name + '\'.');
    }

    if (typeof defaultValue === 'undefined') {
      switch (type) {
        case String:
          defaultValue = '';
          break;

        case Number:
          defaultValue = 0;
          break;

        case Date:
          defaultValue = null;
          break;

        case Boolean:
          defaultValue = false;
          break;

        default:
          defaultValue = null;
          break;
      }
    }

    var thisValue = defaultValue;
    var thisType = type;
    Object.defineProperty(this, name, {
      enumerable: true,
      get: function get() {
        return thisValue;
      },
      set: function set(thatValue) {
        // Auto cast for Booleans
        if (thisType == Boolean) {
          if (!thatValue) {
            thatValue = false;
          } else if (typeof thatValue === 'string') {
            if (thatValue === 'false') {
              thatValue = false;
            } else if (thatValue === 'true') {
              thatValue = true;
            }
          }
        } // Auto cast for numbers


        if (thisType == Number) {
          if (!thatValue) {
            thatValue = 0;
          } else if (thatValue.constructor == String && !isNaN(thatValue)) {
            thatValue = parseFloat(thatValue);
          }
        } // Auto cast for dates


        if (thisType == Date) {
          if (!thatValue) {
            thatValue = null;
          } else if (thatValue.constructor == String || thatValue.constructor == Number) {
            thatValue = new Date(thatValue);
          }
        }

        if (typeof thatValue !== 'undefined') {
          if (thatValue == null) {
            thisValue = thatValue;
            return;
          }

          var thatType = thatValue.constructor;

          if (thisType.name !== thatType.name && thatValue instanceof thisType === false) {
            throw new TypeError(_this.constructor.name + '.' + name + ' is of type \'' + thisType.name + '\' and cannot implicitly be converted to \'' + thatType.name + '\'.');
          } else {
            thisValue = thatValue;
          }
        } else {
          thisValue = defaultValue;
        }
      }
    });
  };

  return Entity;
}();

module.exports = Entity;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(14);
exports.createHash = exports.Hash = __webpack_require__(21);
exports.createHmac = exports.Hmac = __webpack_require__(58);

var algos = __webpack_require__(61);

var algoKeys = Object.keys(algos);
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);

exports.getHashes = function () {
  return hashes;
};

var p = __webpack_require__(63);

exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;

var aes = __webpack_require__(68);

exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;

var dh = __webpack_require__(97);

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;

var sign = __webpack_require__(107);

exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;
exports.createECDH = __webpack_require__(163);

var publicEncrypt = __webpack_require__(164);

exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt; // the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(170);

exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;

exports.createCredentials = function () {
  throw new Error(['sorry, createCredentials is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\n'));
};

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser() {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11');
}

var Buffer = __webpack_require__(16).Buffer;

var crypto = global.crypto || global.msCrypto;

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}

function randomBytes(size, cb) {
  // phantomjs needs to throw
  if (size > 65536) throw new Error('requested too many random bytes'); // in case browserify  isn't using the Uint8Array version

  var rawBytes = new global.Uint8Array(size); // This will not work in older browsers.
  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues

  if (size > 0) {
    // getRandomValues fails on IE if size == 0
    crypto.getRandomValues(rawBytes);
  } // XXX: phantomjs doesn't like a buffer being passed here


  var bytes = Buffer.from(rawBytes.buffer);

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }

  return bytes;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(10)))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(17);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(18);

var ieee754 = __webpack_require__(19);

var isArray = __webpack_require__(20);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  for (var i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(22);

var MD5 = __webpack_require__(23);

var RIPEMD160 = __webpack_require__(48);

var sha = __webpack_require__(49);

var Base = __webpack_require__(57);

function Hash(hash) {
  Base.call(this, 'digest');
  this._hash = hash;
}

inherits(Hash, Base);

Hash.prototype._update = function (data) {
  this._hash.update(data);
};

Hash.prototype._final = function () {
  return this._hash.digest();
};

module.exports = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === 'md5') return new MD5();
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();
  return new Hash(sha(alg));
};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(22);

var HashBase = __webpack_require__(24);

var Buffer = __webpack_require__(16).Buffer;

var ARRAY16 = new Array(16);

function MD5() {
  HashBase.call(this, 64); // state

  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
}

inherits(MD5, HashBase);

MD5.prototype._update = function () {
  var M = ARRAY16;

  for (var i = 0; i < 16; ++i) {
    M[i] = this._block.readInt32LE(i * 4);
  }

  var a = this._a;
  var b = this._b;
  var c = this._c;
  var d = this._d;
  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
  this._a = this._a + a | 0;
  this._b = this._b + b | 0;
  this._c = this._c + c | 0;
  this._d = this._d + d | 0;
};

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;

  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);

    this._update();

    this._blockOffset = 0;
  }

  this._block.fill(0, this._blockOffset, 56);

  this._block.writeUInt32LE(this._length[0], 56);

  this._block.writeUInt32LE(this._length[1], 60);

  this._update(); // produce result


  var buffer = Buffer.allocUnsafe(16);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  return buffer;
};

function rotl(x, n) {
  return x << n | x >>> 32 - n;
}

function fnF(a, b, c, d, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}

function fnG(a, b, c, d, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}

function fnH(a, b, c, d, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}

function fnI(a, b, c, d, m, k, s) {
  return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}

module.exports = MD5;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(16).Buffer;

var Transform = __webpack_require__(25).Transform;

var inherits = __webpack_require__(22);

function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer');
  }
}

function HashBase(blockSize) {
  Transform.call(this);
  this._block = Buffer.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}

inherits(HashBase, Transform);

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null;

  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }

  callback(error);
};

HashBase.prototype._flush = function (callback) {
  var error = null;

  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }

  callback(error);
};

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data');
  if (this._finalized) throw new Error('Digest already called');
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding); // consume data

  var block = this._block;
  var offset = 0;

  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) {
      block[i++] = data[offset++];
    }

    this._update();

    this._blockOffset = 0;
  }

  while (offset < data.length) {
    block[this._blockOffset++] = data[offset++];
  } // update length


  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 0x0100000000 | 0;
    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
  }

  return this;
};

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented');
};

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = true;

  var digest = this._digest();

  if (encoding !== undefined) digest = digest.toString(encoding); // reset state

  this._block.fill(0);

  this._blockOffset = 0;

  for (var i = 0; i < 4; ++i) {
    this._length[i] = 0;
  }

  return digest;
};

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};

module.exports = HashBase;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(26).EventEmitter;

var inherits = __webpack_require__(22);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(27);
Stream.Writable = __webpack_require__(44);
Stream.Duplex = __webpack_require__(45);
Stream.Transform = __webpack_require__(46);
Stream.PassThrough = __webpack_require__(47); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),
/* 26 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.

EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;
  if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.

  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];

      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];
  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;

      case 2:
        handler.call(this, arguments[1]);
        break;

      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower

      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;

    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events) this._events = {}; // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".

  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
  if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.
    this._events[type].push(listener);else // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener]; // Check for listener leak

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);

      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);
  return this;
}; // emits a 'removeListener' event iff the listener was removed


EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;
  if (!isFunction(listener)) throw TypeError('listener must be a function');
  if (!this._events || !this._events[type]) return this;
  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;
  if (!this._events) return this; // not listening for removeListener, no need to emit

  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }

  delete this._events[type];
  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];
    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }

  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(28);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(37);
exports.Duplex = __webpack_require__(36);
exports.Transform = __webpack_require__(42);
exports.PassThrough = __webpack_require__(43);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(29);
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(20);
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(26).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(30);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(16).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = __webpack_require__(31);

util.inherits = __webpack_require__(22);
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(32);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(33);

var destroyImpl = __webpack_require__(35);

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(36);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(41).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(36);
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(41).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(10)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(26).EventEmitter;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 32 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(16).Buffer;

var util = __webpack_require__(34);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 34 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(29);
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(29);
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = __webpack_require__(31);

util.inherits = __webpack_require__(22);
/*</replacement>*/

var Readable = __webpack_require__(28);

var Writable = __webpack_require__(37);

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(29);
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = __webpack_require__(31);

util.inherits = __webpack_require__(22);
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(40)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(30);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(16).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(35);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(36);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(36); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10), __webpack_require__(38).setImmediate, __webpack_require__(15)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(39); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(10)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(16).Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(36);
/*<replacement>*/


var util = __webpack_require__(31);

util.inherits = __webpack_require__(22);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(42);
/*<replacement>*/


var util = __webpack_require__(31);

util.inherits = __webpack_require__(22);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(37);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(36);

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(27).Transform;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(27).PassThrough;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(17).Buffer;

var inherits = __webpack_require__(22);

var HashBase = __webpack_require__(24);

var ARRAY16 = new Array(16);
var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

function RIPEMD160() {
  HashBase.call(this, 64); // state

  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
}

inherits(RIPEMD160, HashBase);

RIPEMD160.prototype._update = function () {
  var words = ARRAY16;

  for (var j = 0; j < 16; ++j) {
    words[j] = this._block.readInt32LE(j * 4);
  }

  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0; // computation

  for (var i = 0; i < 80; i += 1) {
    var tl;
    var tr;

    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
    } else {
      // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
    }

    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  } // update state


  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;

  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);

    this._update();

    this._blockOffset = 0;
  }

  this._block.fill(0, this._blockOffset, 56);

  this._block.writeUInt32LE(this._length[0], 56);

  this._block.writeUInt32LE(this._length[1], 60);

  this._update(); // produce result


  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  buffer.writeInt32LE(this._e, 16);
  return buffer;
};

function rotl(x, n) {
  return x << n | x >>> 32 - n;
}

function fn1(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}

function fn2(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}

function fn3(a, b, c, d, e, m, k, s) {
  return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}

function fn4(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}

function fn5(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}

module.exports = RIPEMD160;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports[algorithm];
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
  return new Algorithm();
};

exports.sha = __webpack_require__(50);
exports.sha1 = __webpack_require__(52);
exports.sha224 = __webpack_require__(53);
exports.sha256 = __webpack_require__(54);
exports.sha384 = __webpack_require__(55);
exports.sha512 = __webpack_require__(56);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */
var inherits = __webpack_require__(22);

var Hash = __webpack_require__(51);

var Buffer = __webpack_require__(16).Buffer;

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);

function Sha() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}

inherits(Sha, Hash);

Sha.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) {
    W[i] = M.readInt32BE(i * 4);
  }

  for (; i < 80; ++i) {
    W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
  }

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

module.exports = Sha;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer; // prototype class for hash functions


function Hash(blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = Buffer.from(data, enc);
  }

  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }

    accum += remainder;
    offset += remainder;

    if (accum % blockSize === 0) {
      this._update(block);
    }
  }

  this._len += length;
  return this;
};

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 0x80; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

  this._block.fill(0, rem + 1);

  if (rem >= this._finalSize) {
    this._update(this._block);

    this._block.fill(0);
  }

  var bits = this._len * 8; // uint32

  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4); // uint64

  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;

    this._block.writeUInt32BE(highBits, this._blockSize - 8);

    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }

  this._update(this._block);

  var hash = this._hash();

  return enc ? hash.toString(enc) : hash;
};

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};

module.exports = Hash;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */
var inherits = __webpack_require__(22);

var Hash = __webpack_require__(51);

var Buffer = __webpack_require__(16).Buffer;

var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);

function Sha1() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}

inherits(Sha1, Hash);

Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};

function rotl1(num) {
  return num << 1 | num >>> 31;
}

function rotl5(num) {
  return num << 5 | num >>> 27;
}

function rotl30(num) {
  return num << 30 | num >>> 2;
}

function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

Sha1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;

  for (var i = 0; i < 16; ++i) {
    W[i] = M.readInt32BE(i * 4);
  }

  for (; i < 80; ++i) {
    W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
  }

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};

module.exports = Sha1;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var inherits = __webpack_require__(22);

var Sha256 = __webpack_require__(54);

var Hash = __webpack_require__(51);

var Buffer = __webpack_require__(16).Buffer;

var W = new Array(64);

function Sha224() {
  this.init();
  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}

inherits(Sha224, Sha256);

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8;
  this._b = 0x367cd507;
  this._c = 0x3070dd17;
  this._d = 0xf70e5939;
  this._e = 0xffc00b31;
  this._f = 0x68581511;
  this._g = 0x64f98fa7;
  this._h = 0xbefa4fa4;
  return this;
};

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  return H;
};

module.exports = Sha224;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var inherits = __webpack_require__(22);

var Hash = __webpack_require__(51);

var Buffer = __webpack_require__(16).Buffer;

var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
var W = new Array(64);

function Sha256() {
  this.init();
  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}

inherits(Sha256, Hash);

Sha256.prototype.init = function () {
  this._a = 0x6a09e667;
  this._b = 0xbb67ae85;
  this._c = 0x3c6ef372;
  this._d = 0xa54ff53a;
  this._e = 0x510e527f;
  this._f = 0x9b05688c;
  this._g = 0x1f83d9ab;
  this._h = 0x5be0cd19;
  return this;
};

function ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}

function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}

Sha256.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;

  for (var i = 0; i < 16; ++i) {
    W[i] = M.readInt32BE(i * 4);
  }

  for (; i < 64; ++i) {
    W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
  }

  for (var j = 0; j < 64; ++j) {
    var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
    var T2 = sigma0(a) + maj(a, b, c) | 0;
    h = g;
    g = f;
    f = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }

  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);
  return H;
};

module.exports = Sha256;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var SHA512 = __webpack_require__(56);

var Hash = __webpack_require__(51);

var Buffer = __webpack_require__(16).Buffer;

var W = new Array(160);

function Sha384() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}

inherits(Sha384, SHA512);

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d;
  this._bh = 0x629a292a;
  this._ch = 0x9159015a;
  this._dh = 0x152fecd8;
  this._eh = 0x67332667;
  this._fh = 0x8eb44a87;
  this._gh = 0xdb0c2e0d;
  this._hh = 0x47b5481d;
  this._al = 0xc1059ed8;
  this._bl = 0x367cd507;
  this._cl = 0x3070dd17;
  this._dl = 0xf70e5939;
  this._el = 0xffc00b31;
  this._fl = 0x68581511;
  this._gl = 0x64f98fa7;
  this._hl = 0xbefa4fa4;
  return this;
};

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H;
};

module.exports = Sha384;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var Hash = __webpack_require__(51);

var Buffer = __webpack_require__(16).Buffer;

var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
var W = new Array(160);

function Sha512() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}

inherits(Sha512, Hash);

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667;
  this._bh = 0xbb67ae85;
  this._ch = 0x3c6ef372;
  this._dh = 0xa54ff53a;
  this._eh = 0x510e527f;
  this._fh = 0x9b05688c;
  this._gh = 0x1f83d9ab;
  this._hh = 0x5be0cd19;
  this._al = 0xf3bcc908;
  this._bl = 0x84caa73b;
  this._cl = 0xfe94f82b;
  this._dl = 0x5f1d36f1;
  this._el = 0xade682d1;
  this._fl = 0x2b3e6c1f;
  this._gl = 0xfb41bd6b;
  this._hl = 0x137e2179;
  return this;
};

function Ch(x, y, z) {
  return z ^ x & (y ^ z);
}

function maj(x, y, z) {
  return x & y | z & (x | y);
}

function sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}

function sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}

function Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}

function Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}

function Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}

function Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}

function getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}

Sha512.prototype._update = function (M) {
  var W = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4);
    W[i + 1] = M.readInt32BE(i * 4 + 4);
  }

  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2];
    var xl = W[i - 15 * 2 + 1];
    var gamma0 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W[i - 2 * 2];
    xl = W[i - 2 * 2 + 1];
    var gamma1 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

    var Wi7h = W[i - 7 * 2];
    var Wi7l = W[i - 7 * 2 + 1];
    var Wi16h = W[i - 16 * 2];
    var Wi16l = W[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W[i] = Wih;
    W[i + 1] = Wil;
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j];
    Wil = W[j + 1];
    var majh = maj(ah, bh, ch);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

    var Kih = K[j];
    var Kil = K[j + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }

  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64);

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }

  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H;
};

module.exports = Sha512;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer;

var Transform = __webpack_require__(25).Transform;

var StringDecoder = __webpack_require__(41).StringDecoder;

var inherits = __webpack_require__(22);

function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === 'string';

  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }

  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }

  this._decoder = null;
  this._encoding = null;
}

inherits(CipherBase, Transform);

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc);
  }

  var outData = this._update(data);

  if (this.hashMode) return this;

  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }

  return outData;
};

CipherBase.prototype.setAutoPadding = function () {};

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state');
};

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state');
};

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state');
};

CipherBase.prototype._transform = function (data, _, next) {
  var err;

  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};

CipherBase.prototype._flush = function (done) {
  var err;

  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }

  done(err);
};

CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0);

  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }

  return outData;
};

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings');

  var out = this._decoder.write(value);

  if (fin) {
    out += this._decoder.end();
  }

  return out;
};

module.exports = CipherBase;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(22);

var Legacy = __webpack_require__(59);

var Base = __webpack_require__(57);

var Buffer = __webpack_require__(16).Buffer;

var md5 = __webpack_require__(60);

var RIPEMD160 = __webpack_require__(48);

var sha = __webpack_require__(49);

var ZEROS = Buffer.alloc(128);

function Hmac(alg, key) {
  Base.call(this, 'digest');

  if (typeof key === 'string') {
    key = Buffer.from(key);
  }

  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
  this._alg = alg;
  this._key = key;

  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
    key = hash.update(key).digest();
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
  var opad = this._opad = Buffer.allocUnsafe(blocksize);

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);

  this._hash.update(ipad);
}

inherits(Hmac, Base);

Hmac.prototype._update = function (data) {
  this._hash.update(data);
};

Hmac.prototype._final = function () {
  var h = this._hash.digest();

  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg);
  return hash.update(this._opad).update(h).digest();
};

module.exports = function createHmac(alg, key) {
  alg = alg.toLowerCase();

  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key);
  }

  if (alg === 'md5') {
    return new Legacy(md5, key);
  }

  return new Hmac(alg, key);
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inherits = __webpack_require__(22);

var Buffer = __webpack_require__(16).Buffer;

var Base = __webpack_require__(57);

var ZEROS = Buffer.alloc(128);
var blocksize = 64;

function Hmac(alg, key) {
  Base.call(this, 'digest');

  if (typeof key === 'string') {
    key = Buffer.from(key);
  }

  this._alg = alg;
  this._key = key;

  if (key.length > blocksize) {
    key = alg(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
  var opad = this._opad = Buffer.allocUnsafe(blocksize);

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  this._hash = [ipad];
}

inherits(Hmac, Base);

Hmac.prototype._update = function (data) {
  this._hash.push(data);
};

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash));

  return this._alg(Buffer.concat([this._opad, h]));
};

module.exports = Hmac;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(23);

module.exports = function (buffer) {
  return new MD5().update(buffer).digest();
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(62);

/***/ }),
/* 62 */
/***/ (function(module) {

module.exports = {"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(64);
exports.pbkdf2Sync = __webpack_require__(67);

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(65);

var defaultEncoding = __webpack_require__(66);

var sync = __webpack_require__(67);

var Buffer = __webpack_require__(16).Buffer;

var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
};
var checks = [];

function checkNative(algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false);
  }

  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false);
  }

  if (checks[algo] !== undefined) {
    return checks[algo];
  }

  ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
    return true;
  }).catch(function () {
    return false;
  });
  checks[algo] = prom;
  return prom;
}

function browserPbkdf2(password, salt, iterations, length, algo) {
  return subtle.importKey('raw', password, {
    name: 'PBKDF2'
  }, false, ['deriveBits']).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3);
  }).then(function (res) {
    return Buffer.from(res);
  });
}

function resolvePromise(promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out);
    });
  }, function (e) {
    process.nextTick(function () {
      callback(e);
    });
  });
}

module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  }

  digest = digest || 'sha1';
  var algo = toBrowser[digest.toLowerCase()];

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out;

      try {
        out = sync(password, salt, iterations, keylen, digest);
      } catch (e) {
        return callback(e);
      }

      callback(null, out);
    });
  }

  checkParameters(password, salt, iterations, keylen);
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding);
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding);
  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
    return sync(password, salt, iterations, keylen, digest);
  }), callback);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(10)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

function checkBuffer(buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string');
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password');
  checkBuffer(salt, 'Salt');

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number');
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations');
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number');
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
    /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length');
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding;
/* istanbul ignore next */

if (process.browser) {
  defaultEncoding = 'utf-8';
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);
  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
}

module.exports = defaultEncoding;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(60);

var RIPEMD160 = __webpack_require__(48);

var sha = __webpack_require__(49);

var checkParameters = __webpack_require__(65);

var defaultEncoding = __webpack_require__(66);

var Buffer = __webpack_require__(16).Buffer;

var ZEROS = Buffer.alloc(128);
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};

function Hmac(alg, key, saltLen) {
  var hash = getDigest(alg);
  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;

  if (key.length > blocksize) {
    key = hash(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
  ipad.copy(ipad1, 0, 0, blocksize);
  this.ipad1 = ipad1;
  this.ipad2 = ipad;
  this.opad = opad;
  this.alg = alg;
  this.blocksize = blocksize;
  this.hash = hash;
  this.size = sizes[alg];
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize);
  var h = this.hash(ipad);
  h.copy(this.opad, this.blocksize);
  return this.hash(this.opad);
};

function getDigest(alg) {
  function shaFunc(data) {
    return sha(alg).update(data).digest();
  }

  function rmd160Func(data) {
    return new RIPEMD160().update(data).digest();
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func;
  if (alg === 'md5') return md5;
  return shaFunc;
}

function pbkdf2(password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen);
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding);
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding);
  digest = digest || 'sha1';
  var hmac = new Hmac(digest, password, salt.length);
  var DK = Buffer.allocUnsafe(keylen);
  var block1 = Buffer.allocUnsafe(salt.length + 4);
  salt.copy(block1, 0, 0, salt.length);
  var destPos = 0;
  var hLen = sizes[digest];
  var l = Math.ceil(keylen / hLen);

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length);
    var T = hmac.run(block1, hmac.ipad1);
    var U = T;

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2);

      for (var k = 0; k < hLen; k++) {
        T[k] ^= U[k];
      }
    }

    T.copy(DK, destPos);
    destPos += hLen;
  }

  return DK;
}

module.exports = pbkdf2;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(69);

var aes = __webpack_require__(77);

var aesModes = __webpack_require__(79);

var desModes = __webpack_require__(96);

var ebtk = __webpack_require__(94);

function createCipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;

  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError('invalid suite type');
  }

  var keys = ebtk(password, false, keyLen, ivLen);
  return createCipheriv(suite, keys.key, keys.iv);
}

function createDecipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;

  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError('invalid suite type');
  }

  var keys = ebtk(password, false, keyLen, ivLen);
  return createDecipheriv(suite, keys.key, keys.iv);
}

function createCipheriv(suite, key, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
  if (desModes[suite]) return new DES({
    key: key,
    iv: iv,
    mode: suite
  });
  throw new TypeError('invalid suite type');
}

function createDecipheriv(suite, key, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
  if (desModes[suite]) return new DES({
    key: key,
    iv: iv,
    mode: suite,
    decrypt: true
  });
  throw new TypeError('invalid suite type');
}

function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}

exports.createCipher = exports.Cipher = createCipher;
exports.createCipheriv = exports.Cipheriv = createCipheriv;
exports.createDecipher = exports.Decipher = createDecipher;
exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(57);

var des = __webpack_require__(70);

var inherits = __webpack_require__(22);

var Buffer = __webpack_require__(16).Buffer;

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
};
modes.des = modes['des-cbc'];
modes.des3 = modes['des-ede3-cbc'];
module.exports = DES;
inherits(DES, CipherBase);

function DES(opts) {
  CipherBase.call(this);
  var modeName = opts.mode.toLowerCase();
  var mode = modes[modeName];
  var type;

  if (opts.decrypt) {
    type = 'decrypt';
  } else {
    type = 'encrypt';
  }

  var key = opts.key;

  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key);
  }

  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)]);
  }

  var iv = opts.iv;

  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv);
  }

  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  });
}

DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data));
};

DES.prototype._final = function () {
  return Buffer.from(this._des.final());
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(71);
exports.Cipher = __webpack_require__(72);
exports.DES = __webpack_require__(74);
exports.CBC = __webpack_require__(75);
exports.EDE = __webpack_require__(76);

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = value >>> 16 & 0xff;
  bytes[2 + off] = value >>> 8 & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
    }

    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
    }

    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }

  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28

  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    }

    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >> j + i & 1;
    }
  }

  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= inR >> j + i & 1;
  } // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60


  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inR >> j + i & 1;
    }

    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }
  }

  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= inL >> j + i & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return num << shift & 0xfffffff | num >>> 28 - shift;
};

var pc2table = [// inL => outL
14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, // inR => outR
15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  var len = pc2table.length >>> 1;

  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= inL >>> pc2table[i] & 0x1;
  }

  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= inR >>> pc2table[i] & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;
  outL = (r & 1) << 5 | r >>> 27;

  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= r >>> i & 0x3f;
  }

  for (var i = 11; i >= 3; i -= 4) {
    outR |= r >>> i & 0x3f;
    outR <<= 6;
  }

  outR |= (r & 0x1f) << 1 | r >>> 31;
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];

exports.substitute = function substitute(inL, inR) {
  var out = 0;

  for (var i = 0; i < 4; i++) {
    var b = inL >>> 18 - i * 6 & 0x3f;
    var sb = sTable[i * 0x40 + b];
    out <<= 4;
    out |= sb;
  }

  for (var i = 0; i < 4; i++) {
    var b = inR >>> 18 - i * 6 & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];
    out <<= 4;
    out |= sb;
  }

  return out >>> 0;
};

var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];

exports.permute = function permute(num) {
  var out = 0;

  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= num >>> permuteTable[i] & 0x1;
  }

  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);

  while (str.length < size) {
    str = '0' + str;
  }

  var out = [];

  for (var i = 0; i < size; i += group) {
    out.push(str.slice(i, i + group));
  }

  return out.join(' ');
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(73);

function Cipher(options) {
  this.options = options;
  this.type = this.options.type;
  this.blockSize = 8;

  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}

module.exports = Cipher;

Cipher.prototype._init = function _init() {// Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0) return [];
  if (this.type === 'decrypt') return this._updateDecrypt(data);else return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);

  for (var i = 0; i < min; i++) {
    this.buffer[this.bufferOff + i] = data[off + i];
  }

  this.bufferOff += min; // Shift next

  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);

  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;
  var count = (this.bufferOff + data.length) / this.blockSize | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);
    if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
  } // Write blocks


  var max = data.length - (data.length - inputOff) % this.blockSize;

  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);

    outputOff += this.blockSize;
  } // Queue rest


  for (; inputOff < data.length; inputOff++, this.bufferOff++) {
    this.buffer[this.bufferOff] = data[inputOff];
  }

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;
  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize); // TODO(indutny): optimize it, this is far from optimal

  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  } // Buffer rest of the input


  inputOff += this._buffer(data, inputOff);
  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer) first = this.update(buffer);
  var last;
  if (this.type === 'encrypt') last = this._finalEncrypt();else last = this._finalDecrypt();
  if (first) return first.concat(last);else return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0) return false;

  while (off < buffer.length) {
    buffer[off++] = 0;
  }

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff)) return [];
  var out = new Array(this.blockSize);

  this._update(this.buffer, 0, out, 0);

  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);

  this._flushBuffer(out, 0);

  return this._unpad(out);
};

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(73);

var inherits = __webpack_require__(22);

var des = __webpack_require__(70);

var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);
  var state = new DESState();
  this._desState = state;
  this.deriveKeys(state, options.key);
}

inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);
  assert.equal(key.length, this.blockSize, 'Invalid key length');
  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);
  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];

  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;
  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4); // Initial Permutation

  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];
  if (this.type === 'encrypt') this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];
  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;

  for (var i = off; i < buffer.length; i++) {
    buffer[i] = value;
  }

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];

  for (var i = buffer.length - pad; i < buffer.length; i++) {
    assert.equal(buffer[i], pad);
  }

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart; // Apply f() x16 times

  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1]; // f(r, k)

    utils.expand(r, state.tmp, 0);
    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);
    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  } // Reverse Initial Permutation


  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart; // Apply f() x16 times

  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1]; // f(r, k)

    utils.expand(l, state.tmp, 0);
    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);
    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  } // Reverse Initial Permutation


  utils.rip(l, r, out, off);
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(73);

var inherits = __webpack_require__(22);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');
  this.iv = new Array(8);

  for (var i = 0; i < this.iv.length; i++) {
    this.iv[i] = iv[i];
  }
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);

    this._cbcInit();
  }

  inherits(CBC, Base);
  var keys = Object.keys(proto);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;
  var iv = state.iv;

  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++) {
      iv[i] ^= inp[inOff + i];
    }

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++) {
      iv[i] = out[outOff + i];
    }
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++) {
      out[outOff + i] ^= iv[i];
    }

    for (var i = 0; i < this.blockSize; i++) {
      iv[i] = inp[inOff + i];
    }
  }
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(73);

var inherits = __webpack_require__(22);

var des = __webpack_require__(70);

var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');
  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [DES.create({
      type: 'encrypt',
      key: k1
    }), DES.create({
      type: 'decrypt',
      key: k2
    }), DES.create({
      type: 'encrypt',
      key: k3
    })];
  } else {
    this.ciphers = [DES.create({
      type: 'decrypt',
      key: k3
    }), DES.create({
      type: 'encrypt',
      key: k2
    }), DES.create({
      type: 'decrypt',
      key: k1
    })];
  }
}

function EDE(options) {
  Cipher.call(this, options);
  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}

inherits(EDE, Cipher);
module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);

  state.ciphers[1]._update(out, outOff, out, outOff);

  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(78);

var deciphers = __webpack_require__(95);

var modes = __webpack_require__(89);

function getCiphers() {
  return Object.keys(modes);
}

exports.createCipher = exports.Cipher = ciphers.createCipher;
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
exports.createDecipher = exports.Decipher = deciphers.createDecipher;
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(79);

var AuthCipher = __webpack_require__(90);

var Buffer = __webpack_require__(16).Buffer;

var StreamCipher = __webpack_require__(93);

var Transform = __webpack_require__(57);

var aes = __webpack_require__(91);

var ebtk = __webpack_require__(94);

var inherits = __webpack_require__(22);

function Cipher(mode, key, iv) {
  Transform.call(this);
  this._cache = new Splitter();
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._mode = mode;
  this._autopadding = true;
}

inherits(Cipher, Transform);

Cipher.prototype._update = function (data) {
  this._cache.add(data);

  var chunk;
  var thing;
  var out = [];

  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }

  return Buffer.concat(out);
};

var PADDING = Buffer.alloc(16, 0x10);

Cipher.prototype._final = function () {
  var chunk = this._cache.flush();

  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);

    this._cipher.scrub();

    return chunk;
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();

    throw new Error('data not multiple of block length');
  }
};

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
  return this;
};

function Splitter() {
  this.cache = Buffer.allocUnsafe(0);
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }

  return null;
};

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length;
  var padBuff = Buffer.allocUnsafe(len);
  var i = -1;

  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }

  return Buffer.concat([this.cache, padBuff]);
};

function createCipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  if (typeof password === 'string') password = Buffer.from(password);
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);
  if (typeof iv === 'string') iv = Buffer.from(iv);
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv);
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv);
  }

  return new Cipher(config.module, password, iv);
}

function createCipher(suite, password) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  var keys = ebtk(password, false, config.key, config.iv);
  return createCipheriv(suite, keys.key, keys.iv);
}

exports.createCipheriv = createCipheriv;
exports.createCipher = createCipher;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(80),
  CBC: __webpack_require__(81),
  CFB: __webpack_require__(83),
  CFB8: __webpack_require__(84),
  CFB1: __webpack_require__(85),
  OFB: __webpack_require__(86),
  CTR: __webpack_require__(87),
  GCM: __webpack_require__(87)
};

var modes = __webpack_require__(89);

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode];
}

module.exports = modes;

/***/ }),
/* 80 */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block);
};

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block);
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(82);

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev);
  self._prev = self._cipher.encryptBlock(data);
  return self._prev;
};

exports.decrypt = function (self, block) {
  var pad = self._prev;
  self._prev = block;

  var out = self._cipher.decryptBlock(block);

  return xor(out, pad);
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor(a, b) {
  var length = Math.min(a.length, b.length);
  var buffer = new Buffer(length);

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i];
  }

  return buffer;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer;

var xor = __webpack_require__(82);

function encryptStart(self, data, decrypt) {
  var len = data.length;
  var out = xor(data, self._cache);
  self._cache = self._cache.slice(len);
  self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
  return out;
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0);
  var len;

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev);
      self._prev = Buffer.allocUnsafe(0);
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length;
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
      data = data.slice(len);
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
      break;
    }
  }

  return out;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer;

function encryptByte(self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev);

  var out = pad[0] ^ byteParam;
  self._prev = Buffer.concat([self._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
  return out;
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = Buffer.allocUnsafe(len);
  var i = -1;

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }

  return out;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer;

function encryptByte(self, byteParam, decrypt) {
  var pad;
  var i = -1;
  var len = 8;
  var out = 0;
  var bit, value;

  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev);
    bit = byteParam & 1 << 7 - i ? 0x80 : 0;
    value = pad[0] ^ bit;
    out += (value & 0x80) >> i % 8;
    self._prev = shiftIn(self._prev, decrypt ? bit : value);
  }

  return out;
}

function shiftIn(buffer, value) {
  var len = buffer.length;
  var i = -1;
  var out = Buffer.allocUnsafe(buffer.length);
  buffer = Buffer.concat([buffer, Buffer.from([value])]);

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
  }

  return out;
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = Buffer.allocUnsafe(len);
  var i = -1;

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }

  return out;
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(82);

function getBlock(self) {
  self._prev = self._cipher.encryptBlock(self._prev);
  return self._prev;
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)]);
  }

  var pad = self._cache.slice(0, chunk.length);

  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(82);

var Buffer = __webpack_require__(16).Buffer;

var incr32 = __webpack_require__(88);

function getBlock(self) {
  var out = self._cipher.encryptBlockRaw(self._prev);

  incr32(self._prev);
  return out;
}

var blockSize = 16;

exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize);
  var start = self._cache.length;
  self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);

  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self);
    var offset = start + i * blockSize;

    self._cache.writeUInt32BE(out[0], offset + 0);

    self._cache.writeUInt32BE(out[1], offset + 4);

    self._cache.writeUInt32BE(out[2], offset + 8);

    self._cache.writeUInt32BE(out[3], offset + 12);
  }

  var pad = self._cache.slice(0, chunk.length);

  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};

/***/ }),
/* 88 */
/***/ (function(module, exports) {

function incr32(iv) {
  var len = iv.length;
  var item;

  while (len--) {
    item = iv.readUInt8(len);

    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}

module.exports = incr32;

/***/ }),
/* 89 */
/***/ (function(module) {

module.exports = {"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(91);

var Buffer = __webpack_require__(16).Buffer;

var Transform = __webpack_require__(57);

var inherits = __webpack_require__(22);

var GHASH = __webpack_require__(92);

var xor = __webpack_require__(82);

var incr32 = __webpack_require__(88);

function xorTest(a, b) {
  var out = 0;
  if (a.length !== b.length) out++;
  var len = Math.min(a.length, b.length);

  for (var i = 0; i < len; ++i) {
    out += a[i] ^ b[i];
  }

  return out;
}

function calcIv(self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
  }

  var ghash = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash.update(iv);

  if (toPad) {
    toPad = 16 - toPad;
    ghash.update(Buffer.alloc(toPad, 0));
  }

  ghash.update(Buffer.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer.alloc(8);
  tail.writeUIntBE(ivBits, 0, 8);
  ghash.update(tail);
  self._finID = ghash.state;
  var out = Buffer.from(self._finID);
  incr32(out);
  return out;
}

function StreamCipher(mode, key, iv, decrypt) {
  Transform.call(this);
  var h = Buffer.alloc(4, 0);
  this._cipher = new aes.AES(key);

  var ck = this._cipher.encryptBlock(h);

  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer.from(iv);
  this._cache = Buffer.allocUnsafe(0);
  this._secCache = Buffer.allocUnsafe(0);
  this._decrypt = decrypt;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}

inherits(StreamCipher, Transform);

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;

    if (rump < 16) {
      rump = Buffer.alloc(rump, 0);

      this._ghash.update(rump);
    }
  }

  this._called = true;

  var out = this._mode.encrypt(this, chunk);

  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }

  this._len += chunk.length;
  return out;
};

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data');
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data');
  this._authTag = tag;

  this._cipher.scrub();
};

StreamCipher.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state');
  return this._authTag;
};

StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state');
  this._authTag = tag;
};

StreamCipher.prototype.setAAD = function setAAD(buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state');

  this._ghash.update(buf);

  this._alen += buf.length;
};

module.exports = StreamCipher;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/
var Buffer = __webpack_require__(16).Buffer;

function asUInt32Array(buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }

  return out;
}

function scrubVec(v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0;
  }
}

function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s0 = M[0] ^ keySchedule[0];
  var s1 = M[1] ^ keySchedule[1];
  var s2 = M[2] ^ keySchedule[2];
  var s3 = M[3] ^ keySchedule[3];
  var t0, t1, t2, t3;
  var ksRow = 4;

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
    s0 = t0;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }

  t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
  t0 = t0 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [t0, t1, t2, t3];
} // AES constants


var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

var G = function () {
  // Compute double table
  var d = new Array(256);

  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1;
    } else {
      d[j] = j << 1 ^ 0x11b;
    }
  }

  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [[], [], [], []];
  var INV_SUB_MIX = [[], [], [], []]; // Walk GF(2^8)

  var x = 0;
  var xi = 0;

  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
    sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
    SBOX[x] = sx;
    INV_SBOX[sx] = x; // Compute multiplication

    var x2 = d[x];
    var x4 = d[x2];
    var x8 = d[x4]; // Compute sub bytes, mix columns tables

    var t = d[sx] * 0x101 ^ sx * 0x1010100;
    SUB_MIX[0][x] = t << 24 | t >>> 8;
    SUB_MIX[1][x] = t << 16 | t >>> 16;
    SUB_MIX[2][x] = t << 8 | t >>> 24;
    SUB_MIX[3][x] = t; // Compute inv sub bytes, inv mix columns tables

    t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
    INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
    INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
    INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
    INV_SUB_MIX[3][sx] = t;

    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]];
      xi ^= d[d[xi]];
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  };
}();

function AES(key) {
  this._key = asUInt32Array(key);

  this._reset();
}

AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;

AES.prototype._reset = function () {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];

  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k];
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1];

    if (k % keySize === 0) {
      t = t << 8 | t >>> 24;
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
      t ^= RCON[k / keySize | 0] << 24;
    } else if (keySize > 6 && k % keySize === 4) {
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t;
  }

  var invKeySchedule = [];

  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
    }
  }

  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M);
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M);
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M); // swap

  var m1 = M[1];
  M[1] = M[3];
  M[3] = m1;
  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};

module.exports.AES = AES;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer;

var ZEROES = Buffer.alloc(16, 0);

function toArray(buf) {
  return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
}

function fromArray(out) {
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}

function GHASH(key) {
  this.h = key;
  this.state = Buffer.alloc(16, 0);
  this.cache = Buffer.allocUnsafe(0);
} // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua


GHASH.prototype.ghash = function (block) {
  var i = -1;

  while (++i < block.length) {
    this.state[i] ^= block[i];
  }

  this._multiply();
};

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h);
  var Zi = [0, 0, 0, 0];
  var j, xi, lsbVi;
  var i = -1;

  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;

    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0];
      Zi[1] ^= Vi[1];
      Zi[2] ^= Vi[2];
      Zi[3] ^= Vi[3];
    } // Store the value of LSB(V_i)


    lsbVi = (Vi[3] & 1) !== 0; // V_i+1 = V_i >> 1

    for (j = 3; j > 0; j--) {
      Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
    }

    Vi[0] = Vi[0] >>> 1; // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R

    if (lsbVi) {
      Vi[0] = Vi[0] ^ 0xe1 << 24;
    }
  }

  this.state = fromArray(Zi);
};

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf]);
  var chunk;

  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16));
  }

  this.ghash(fromArray([0, abl, 0, bl]));
  return this.state;
};

module.exports = GHASH;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(91);

var Buffer = __webpack_require__(16).Buffer;

var Transform = __webpack_require__(57);

var inherits = __webpack_require__(22);

function StreamCipher(mode, key, iv, decrypt) {
  Transform.call(this);
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._cache = Buffer.allocUnsafe(0);
  this._secCache = Buffer.allocUnsafe(0);
  this._decrypt = decrypt;
  this._mode = mode;
}

inherits(StreamCipher, Transform);

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};

StreamCipher.prototype._final = function () {
  this._cipher.scrub();
};

module.exports = StreamCipher;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(16).Buffer;

var MD5 = __webpack_require__(23);
/* eslint-disable camelcase */


function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary');

  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary');
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length');
  }

  var keyLen = keyBits / 8;
  var key = Buffer.alloc(keyLen);
  var iv = Buffer.alloc(ivLen || 0);
  var tmp = Buffer.alloc(0);

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5();
    hash.update(tmp);
    hash.update(password);
    if (salt) hash.update(salt);
    tmp = hash.digest();
    var used = 0;

    if (keyLen > 0) {
      var keyStart = key.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key, keyStart, 0, used);
      keyLen -= used;
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen;
      var length = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }

  tmp.fill(0);
  return {
    key: key,
    iv: iv
  };
}

module.exports = EVP_BytesToKey;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(90);

var Buffer = __webpack_require__(16).Buffer;

var MODES = __webpack_require__(79);

var StreamCipher = __webpack_require__(93);

var Transform = __webpack_require__(57);

var aes = __webpack_require__(91);

var ebtk = __webpack_require__(94);

var inherits = __webpack_require__(22);

function Decipher(mode, key, iv) {
  Transform.call(this);
  this._cache = new Splitter();
  this._last = void 0;
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._mode = mode;
  this._autopadding = true;
}

inherits(Decipher, Transform);

Decipher.prototype._update = function (data) {
  this._cache.add(data);

  var chunk;
  var thing;
  var out = [];

  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }

  return Buffer.concat(out);
};

Decipher.prototype._final = function () {
  var chunk = this._cache.flush();

  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error('data not multiple of block length');
  }
};

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
  return this;
};

function Splitter() {
  this.cache = Buffer.allocUnsafe(0);
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};

Splitter.prototype.get = function (autoPadding) {
  var out;

  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }

  return null;
};

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache;
};

function unpad(last) {
  var padded = last[15];

  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data');
  }

  var i = -1;

  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error('unable to decrypt data');
    }
  }

  if (padded === 16) return;
  return last.slice(0, 16 - padded);
}

function createDecipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  if (typeof iv === 'string') iv = Buffer.from(iv);
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);
  if (typeof password === 'string') password = Buffer.from(password);
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true);
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true);
  }

  return new Decipher(config.module, password, iv);
}

function createDecipher(suite, password) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  var keys = ebtk(password, false, config.key, config.iv);
  return createDecipheriv(suite, keys.key, keys.iv);
}

exports.createDecipher = createDecipher;
exports.createDecipheriv = createDecipheriv;

/***/ }),
/* 96 */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
};
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
};
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
};
exports['des-ede3'] = {
  key: 24,
  iv: 0
};
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
};
exports['des-ede'] = {
  key: 16,
  iv: 0
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(98);

var primes = __webpack_require__(105);

var DH = __webpack_require__(106);

function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');
  return new DH(prime, gen);
}

var ENCODINGS = {
  'binary': true,
  'hex': true,
  'base64': true
};

function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator);
  }

  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }

  return new DH(prime, generator, true);
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(14);

module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;

var BN = __webpack_require__(99);

var TWENTYFOUR = new BN(24);

var MillerRabin = __webpack_require__(102);

var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null) return primes;
  var limit = 0x100000;
  var res = [];
  res[0] = 2;

  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));

    for (var j = 0; j < i && res[j] <= sqrt; j++) {
      if (k % res[j] === 0) break;
    }

    if (i !== j && res[j] <= sqrt) continue;
    res[i++] = k;
  }

  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++) {
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }
  }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }

  gen = new BN(gen);
  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));

    while (num.bitLength() > bits) {
      num.ishrn(1);
    }

    if (num.isEven()) {
      num.iadd(ONE);
    }

    if (!num.testn(1)) {
      num.iadd(TWO);
    }

    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }

    n2 = num.shrn(1);

    if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict'; // Utils

  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  } // Could use `inherits` module, but don't want to move from single file
  // architecture yet.


  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  } // BN


  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0; // Reduction context

    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }

  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;
  var Buffer;

  try {
    Buffer = __webpack_require__(101).Buffer;
  } catch (e) {}

  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }

    assert(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, '');
    var start = 0;

    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();
    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }

    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }

    if (endian !== 'le') return; // Reverse the bytes

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');

    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;

    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }

    return this.strip();
  };

  function parseHex(str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r <<= 4; // 'a' - 'f'

      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa; // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa; // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }

    return r;
  }

  BN.prototype._parseHex = function _parseHex(number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w; // Scan 24-bit chunks and add them to the number

    var off = 0;

    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= w << off & 0x3ffffff; // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb

      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
      off += 24;

      if (off >= 26) {
        off -= 26;
        j++;
      }
    }

    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= w << off & 0x3ffffff;
      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
    }

    this.strip();
  };

  function parseBase(str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul; // 'a'

      if (c >= 49) {
        r += c - 49 + 0xa; // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa; // '0' - '9'
      } else {
        r += c;
      }
    }

    return r;
  }

  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1; // Find length of limb in base

    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }

    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;

    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);
      this.imuln(limbPow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }

    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }

    return this;
  }; // Remove leading `0` from `this`


  BN.prototype.strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }

    return this._normSign();
  };

  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }

    return this;
  };

  BN.prototype.inspect = function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };
  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */


  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;

    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;

      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;

        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }

        off += 2;

        if (off >= 26) {
          off -= 26;
          i--;
        }
      }

      if (carry !== 0) {
        out = carry.toString(16) + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;

      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }

      if (this.isZero()) {
        out = '0' + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];

    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }

    return this.negative !== 0 ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON() {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer(endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');
    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);
    var b, i;
    var q = this.clone();

    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;

      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }

      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }

      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }

      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }

      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;
    var t = w;
    var r = 0;

    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }

    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }

    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }

    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }

    if ((t & 0x1) === 0) {
      r++;
    }

    return r;
  }; // Return number of used bits in a BN


  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];

    var hi = this._countBits(w);

    return (this.length - 1) * 26 + hi;
  };

  function toBitArray(num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
    }

    return w;
  } // Number of trailing zero bits


  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;

    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);

      r += b;
      if (b !== 26) break;
    }

    return r;
  };

  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }

    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }

    return this.clone();
  };

  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  }; // Return negative clone of `this`


  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  }; // Or `num` with `this` in-place


  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  }; // Or `num` with `this`


  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  }; // And `num` with `this` in-place


  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;

    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;
    return this.strip();
  };

  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  }; // And `num` with `this`


  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  }; // Xor `num` with `this` in-place


  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;
    return this.strip();
  };

  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  }; // Xor `num` with `this`


  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  }; // Not ``this`` with ``width`` bitwidth


  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26; // Extend the buffer with leading zeroes

    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    } // Handle complete words


    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    } // Handle the residue


    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    } // And remove leading zeroes


    return this.strip();
  };

  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  }; // Set `bit` of `this`


  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  }; // Add `num` to `this` in-place


  BN.prototype.iadd = function iadd(num) {
    var r; // negative + positive

    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign(); // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    } // a.length > b.length


    var a, b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;

    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++; // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  }; // Add `num` to `this`


  BN.prototype.add = function add(num) {
    var res;

    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
  }; // Subtract `num` from `this` in-place


  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign(); // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    } // At this point both numbers are positive


    var cmp = this.cmp(num); // Optimization - zeroify

    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    } // a > b


    var a, b;

    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    } // Copy rest of the words


    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  }; // Subtract `num` from `this`


  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };

  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }

      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }

    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  } // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).


  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */

    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */

    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */

    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */

    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */

    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */

    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */

    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */

    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */

    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */

    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */

    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */

    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */

    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */

    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */

    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */

    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */

    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */

    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */

    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;

    if (c !== 0) {
      o[19] = c;
      out.length++;
    }

    return out;
  }; // Polyfill comb


  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;

    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }

      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }

    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo(self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;

    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  }; // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion


  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;

    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  }; // Returns binary-reversed representation of `x`


  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;

    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }

    return rb;
  }; // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm


  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;
      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];
          var ro = rtws[p + j + s];
          var io = itws[p + j + s];
          var rx = rtwdf_ * ro - itwdf_ * io;
          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;
          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;
          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;
          /* jshint maxdepth : false */

          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;

    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];
      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;
      t = iws[i];
      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;

    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;

    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);
      rws[2 * i] = carry & 0x1fff;
      carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;
      carry = carry >>> 13;
    } // Pad with zeroes


    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);

    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  }; // Multiply `this` by `num`


  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  }; // Multiply employing FFT


  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  }; // In-place Multiplication


  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000); // Carry

    var carry = 0;

    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  }; // `this` * `this`


  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  }; // `this` * `this` in-place


  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  }; // Math.pow(`this`, `num`)


  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1); // Skip leading zeroes

    var res = this;

    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;
        res = res.mul(q);
      }
    }

    return res;
  }; // Shift-left in-place


  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  }; // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits


  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;

    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h); // Extended mode, copy masked part

    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }

      maskedWords.length = s;
    }

    if (s === 0) {// No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;

      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;

    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    } // Push carried bits as a mask


    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  }; // Shift-left


  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  }; // Shift-right


  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  }; // Test if n bit is set


  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) return false; // Check bit and return

    var w = this.words[s];
    return !!(w & q);
  }; // Return only lowers bits of number (in-place)


  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }

    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  }; // Return only lowers bits of number


  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  }; // Add plain number `num` to `this`


  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num); // Possible sign change

    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    } // Add without checks


    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num; // Carry

    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;

      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }

    this.length = Math.max(this.length, i + 1);
    return this;
  }; // Subtract plain number `num` from `this`


  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
  };

  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;

    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }

    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip(); // Subtraction overflow

    assert(carry === -1);
    carry = 0;

    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }

    this.negative = 1;
    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num; // Normalize

    var bhi = b.words[b.length - 1] | 0;

    var bhiBits = this._countBits(bhi);

    shift = 26 - bhiBits;

    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    } // Initialize quotient


    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);

      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);

    if (diff.negative === 0) {
      a = diff;

      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)

      qj = Math.min(qj / bhi | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);

      while (a.negative !== 0) {
        qj--;
        a.negative = 0;

        a._ishlnsubmul(b, 1, j);

        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }

      if (q) {
        q.words[j] = qj;
      }
    }

    if (q) {
      q.strip();
    }

    a.strip(); // Denormalize

    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested


  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;

    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    } // Both numbers are positive at this point
    // Strip both numbers to approximate shift value


    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    } // Very short reduction


    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  }; // Find `this` / `num`


  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  }; // Find `this` % `num`


  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  }; // Find Round(`this` / `num`)


  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num); // Fast case - exact division

    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half); // Round down

    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn(num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  }; // In-place division by number


  BN.prototype.idivn = function idivn(num) {
    assert(num <= 0x3ffffff);
    var carry = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    } // A * x + B * y = x


    var A = new BN(1);
    var B = new BN(0); // C * x + D * y = y

    var C = new BN(0);
    var D = new BN(1);
    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
        ;
      }

      if (i > 0) {
        x.iushrn(i);

        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
        ;
      }

      if (j > 0) {
        y.iushrn(j);

        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  }; // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed


  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
        ;
      }

      if (i > 0) {
        a.iushrn(i);

        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
        ;
      }

      if (j > 0) {
        b.iushrn(j);

        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;

    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0; // Remove common factor of two

    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }

      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);

      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  }; // Invert number in the field F(num)


  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  }; // And first word and num


  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  }; // Increment at the bit position in-line


  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) {
      this._expand(s + 1);

      this.words[s] |= q;
      return this;
    } // Add bit and propagate, if needed


    var carry = q;

    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this.strip();
    var res;

    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');
      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }

    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`


  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Unsigned comparison


  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;
      if (a === b) continue;

      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }

      break;
    }

    return res;
  };

  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  }; //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //


  BN.red = function red(num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');

    this.red._verify1(this);

    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');

    this.red._verify1(this);

    return this.red.isqr(this);
  }; // Square root over p


  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');

    this.red._verify1(this);

    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');

    this.red._verify1(this);

    return this.red.invm(this);
  }; // Return negative clone of `this` % `red modulo`


  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');

    this.red._verify1(this);

    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');

    this.red._verify1(this);

    return this.red.pow(this, num);
  }; // Prime numbers with efficient reduction


  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  }; // Pseudo-Mersenne prime

  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };

  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }

  inherits(K256, MPrime);

  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);

    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }

    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    } // Shift by 9 limbs


    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }

    prev >>>= 22;
    input.words[i - 10] = prev;

    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

    var lo = 0;

    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    } // Fast length reduction


    if (num.words[num.length - 1] === 0) {
      num.length--;

      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }

    return num;
  };

  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }

  inherits(P224, MPrime);

  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }

  inherits(P192, MPrime);

  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }

  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;

    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;
      num.words[i] = lo;
      carry = hi;
    }

    if (carry !== 0) {
      num.words[num.length++] = carry;
    }

    return num;
  }; // Exported mostly for testing purposes, use plain name instead


  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];
    var prime;

    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }

    primes[name] = prime;
    return prime;
  }; //
  // Base reduction engine
  //


  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);

      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };

  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);

    var res = a.add(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res;
  };

  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);

    var res = a.sub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);

    var res = a.isub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res;
  };

  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);

    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);

    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);

    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1); // Fast case

    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)


    var q = this.m.subn(1);
    var s = 0;

    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }

    assert(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg(); // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.

    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;

    while (t.cmp(one) !== 0) {
      var tmp = t;

      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }

      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));
      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);

    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;

    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;

    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];

      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;

        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }

      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  }; //
  // Montgomery method engine
  //


  BN.mont = function mont(num) {
    return new Mont(num);
  };

  function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();

    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }

  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(100)(module)))

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 101 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(99);

var brorand = __webpack_require__(103);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}

module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8); // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.

  do {
    var a = new bn(this.rand.generate(min_bytes));
  } while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);
  if (!k) k = Math.max(1, len / 48 | 0); // Find d and s, (n - 1) = (2 ^ s) * d;

  var n1 = n.subn(1);

  for (var s = 0; !n1.testn(s); s++) {}

  var d = n.shrn(s);
  var rn1 = n1.toRed(red);
  var prime = true;

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    if (cb) cb(a);
    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();
      if (x.cmp(rone) === 0) return false;
      if (x.cmp(rn1) === 0) break;
    }

    if (i === s) return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);
  if (!k) k = Math.max(1, len / 48 | 0); // Find d and s, (n - 1) = (2 ^ s) * d;

  var n1 = n.subn(1);

  for (var s = 0; !n1.testn(s); s++) {}

  var d = n.shrn(s);
  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0) return g;
    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();
      if (x.cmp(rone) === 0) return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0) break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r) r = new Rand(null);
  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}

module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
}; // Emulate crypto API using randy


Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes) return this.rand.getBytes(n);
  var res = new Uint8Array(n);

  for (var i = 0; i < res.length; i++) {
    res[i] = this.rand.getByte();
  }

  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    }; // Safari's WebWorkers do not have `crypto`

  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function () {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(104);

    if (typeof crypto.randomBytes !== 'function') throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {}
}

/***/ }),
/* 104 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 105 */
/***/ (function(module) {

module.exports = {"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(99);

var MillerRabin = __webpack_require__(102);

var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);

var primes = __webpack_require__(98);

var randomBytes = __webpack_require__(14);

module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }

  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }

  this._priv = new BN(priv);
  return this;
}

var primeCache = {};

function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');

  if (hex in primeCache) {
    return primeCache[hex];
  }

  var error = 0;

  if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }

    primeCache[hex] = error;
    return error;
  }

  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }

  var rem;

  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }

      break;

    case '05':
      rem = prime.mod(TEN);

      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }

      break;

    default:
      error += 4;
  }

  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;

  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}

Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function get() {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }

    return this._primeCode;
  }
});

DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }

  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();

  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }

  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }

  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());

  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(21);

var stream = __webpack_require__(25);

var inherits = __webpack_require__(22);

var sign = __webpack_require__(108);

var verify = __webpack_require__(162);

var algorithms = __webpack_require__(62);

Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex');
  algorithms[key.toLowerCase()] = algorithms[key];
});

function Sign(algorithm) {
  stream.Writable.call(this);
  var data = algorithms[algorithm];
  if (!data) throw new Error('Unknown message digest');
  this._hashType = data.hash;
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}

inherits(Sign, stream.Writable);

Sign.prototype._write = function _write(data, _, done) {
  this._hash.update(data);

  done();
};

Sign.prototype.update = function update(data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc);

  this._hash.update(data);

  return this;
};

Sign.prototype.sign = function signMethod(key, enc) {
  this.end();

  var hash = this._hash.digest();

  var sig = sign(hash, key, this._hashType, this._signType, this._tag);
  return enc ? sig.toString(enc) : sig;
};

function Verify(algorithm) {
  stream.Writable.call(this);
  var data = algorithms[algorithm];
  if (!data) throw new Error('Unknown message digest');
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}

inherits(Verify, stream.Writable);

Verify.prototype._write = function _write(data, _, done) {
  this._hash.update(data);

  done();
};

Verify.prototype.update = function update(data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc);

  this._hash.update(data);

  return this;
};

Verify.prototype.verify = function verifyMethod(key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc);
  this.end();

  var hash = this._hash.digest();

  return verify(sig, hash, key, this._signType, this._tag);
};

function createSign(algorithm) {
  return new Sign(algorithm);
}

function createVerify(algorithm) {
  return new Verify(algorithm);
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(58);

var crt = __webpack_require__(109);

var EC = __webpack_require__(110).ec;

var BN = __webpack_require__(99);

var parseKeys = __webpack_require__(140);

var curves = __webpack_require__(161);

function sign(hash, key, hashType, signType, tag) {
  var priv = parseKeys(key);

  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');
    return ecSign(hash, priv);
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type');
    return dsaSign(hash, priv, hashType);
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type');
  }

  hash = Buffer.concat([tag, hash]);
  var len = priv.modulus.byteLength();
  var pad = [0, 1];

  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff);
  }

  pad.push(0x00);
  var i = -1;

  while (++i < hash.length) {
    pad.push(hash[i]);
  }

  var out = crt(pad, priv);
  return out;
}

function ecSign(hash, priv) {
  var curveId = curves[priv.curve.join('.')];
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'));
  var curve = new EC(curveId);
  var key = curve.keyFromPrivate(priv.privateKey);
  var out = key.sign(hash);
  return new Buffer(out.toDER());
}

function dsaSign(hash, priv, algo) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var g = priv.params.g;
  var r = new BN(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKey(x, q, hash, algo);

  while (s === false) {
    k = makeKey(q, kv, algo);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);

    if (s.cmpn(0) === 0) {
      s = false;
      r = new BN(0);
    }
  }

  return toDER(r, s);
}

function toDER(r, s) {
  r = r.toArray();
  s = s.toArray(); // Pad values

  if (r[0] & 0x80) r = [0].concat(r);
  if (s[0] & 0x80) s = [0].concat(s);
  var total = r.length + s.length + 4;
  var res = [0x30, total, 0x02, r.length];
  res = res.concat(r, [0x02, s.length], s);
  return new Buffer(res);
}

function getKey(x, q, hash, algo) {
  x = new Buffer(x.toArray());

  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length);
    zeros.fill(0);
    x = Buffer.concat([zeros, x]);
  }

  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = new Buffer(hlen);
  v.fill(1);
  var k = new Buffer(hlen);
  k.fill(0);
  k = createHmac(algo, k).update(v).update(new Buffer([0])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  k = createHmac(algo, k).update(v).update(new Buffer([1])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  return {
    k: k,
    v: v
  };
}

function bits2int(obits, q) {
  var bits = new BN(obits);
  var shift = (obits.length << 3) - q.bitLength();
  if (shift > 0) bits.ishrn(shift);
  return bits;
}

function bits2octets(bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = new Buffer(bits.toArray());

  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length);
    zeros.fill(0);
    out = Buffer.concat([zeros, out]);
  }

  return out;
}

function makeKey(q, kv, algo) {
  var t;
  var k;

  do {
    t = new Buffer(0);

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      t = Buffer.concat([t, kv.v]);
    }

    k = bits2int(t, q);
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest();
    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
  } while (k.cmp(q) !== -1);

  return k;
}

function makeR(g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}

module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(99);

var randomBytes = __webpack_require__(14);

module.exports = crt;

function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder: r.invm(priv.modulus)
  };
}

function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}

crt.getr = getr;

function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));

  while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }

  return r;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;
elliptic.version = __webpack_require__(111).version;
elliptic.utils = __webpack_require__(112);
elliptic.rand = __webpack_require__(103);
elliptic.curve = __webpack_require__(114);
elliptic.curves = __webpack_require__(119); // Protocols

elliptic.ec = __webpack_require__(133);
elliptic.eddsa = __webpack_require__(137);

/***/ }),
/* 111 */
/***/ (function(module) {

module.exports = {"_args":[["elliptic@6.4.1","/home/mrzapp/Development/Web/hashbrown-cms"]],"_development":true,"_from":"elliptic@6.4.1","_id":"elliptic@6.4.1","_inBundle":false,"_integrity":"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==","_location":"/elliptic","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"elliptic@6.4.1","name":"elliptic","escapedName":"elliptic","rawSpec":"6.4.1","saveSpec":null,"fetchSpec":"6.4.1"},"_requiredBy":["/browserify-sign","/create-ecdh"],"_resolved":"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz","_spec":"6.4.1","_where":"/home/mrzapp/Development/Web/hashbrown-cms","author":{"name":"Fedor Indutny","email":"fedor@indutny.com"},"bugs":{"url":"https://github.com/indutny/elliptic/issues"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},"description":"EC cryptography","devDependencies":{"brfs":"^1.4.3","coveralls":"^2.11.3","grunt":"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2","istanbul":"^0.4.2","jscs":"^2.9.0","jshint":"^2.6.0","mocha":"^2.1.0"},"files":["lib"],"homepage":"https://github.com/indutny/elliptic","keywords":["EC","Elliptic","curve","Cryptography"],"license":"MIT","main":"lib/elliptic.js","name":"elliptic","repository":{"type":"git","url":"git+ssh://git@github.com/indutny/elliptic.git"},"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","test":"npm run lint && npm run unit","unit":"istanbul test _mocha --reporter=spec test/index.js","version":"grunt dist && git add dist/"},"version":"6.4.1"};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

var BN = __webpack_require__(99);

var minAssert = __webpack_require__(73);

var minUtils = __webpack_require__(113);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode; // Represent num in a w-NAF form

function getNAF(num, w) {
  var naf = [];
  var ws = 1 << w + 1;
  var k = num.clone();

  while (k.cmpn(1) >= 0) {
    var z;

    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf.push(z); // Optimization, shift by word if possible

    var shift = k.cmpn(0) !== 0 && k.andln(ws - 1) === 0 ? w + 1 : 1;

    for (var i = 1; i < shift; i++) {
      naf.push(0);
    }

    k.iushrn(shift);
  }

  return naf;
}

utils.getNAF = getNAF; // Represent k1, k2 in a Joint Sparse Form

function getJSF(k1, k2) {
  var jsf = [[], []];
  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;

  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = k1.andln(3) + d1 & 3;
    var m24 = k2.andln(3) + d2 & 3;
    if (m14 === 3) m14 = -1;
    if (m24 === 3) m24 = -1;
    var u1;

    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = k1.andln(7) + d1 & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
    }

    jsf[0].push(u1);
    var u2;

    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = k2.andln(7) + d2 & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
    }

    jsf[1].push(u2); // Second phase

    if (2 * d1 === u1 + 1) d1 = 1 - d1;
    if (2 * d2 === u2 + 1) d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}

utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;

  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
  };
}

utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
}

utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}

utils.intFromLE = intFromLE;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];

  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++) {
      res[i] = msg[i] | 0;
    }

    return res;
  }

  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0) msg = '0' + msg;

    for (var i = 0; i < msg.length; i += 2) {
      res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi) res.push(hi, lo);else res.push(lo);
    }
  }

  return res;
}

utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}

utils.zero2 = zero2;

function toHex(msg) {
  var res = '';

  for (var i = 0; i < msg.length; i++) {
    res += zero2(msg[i].toString(16));
  }

  return res;
}

utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex') return toHex(arr);else return arr;
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;
curve.base = __webpack_require__(115);
curve.short = __webpack_require__(116);
curve.mont = __webpack_require__(117);
curve.edwards = __webpack_require__(118);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(99);

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16); // Use Montgomery, when there is no fast reduction for the prime

  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p); // Useful for many curves

  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red); // Curve configuration, optional

  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed); // Temporary arrays

  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4); // Generalized Greg Maxwell's trick

  var adjustCount = this.n && this.p.div(this.n);

  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}

module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);

  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3; // Translate into more windowed form

  var repr = [];

  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;

    for (var k = j + doubles.step - 1; k >= j; k--) {
      nafW = (nafW << 1) + naf[k];
    }

    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);

  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
    }

    a = a.add(b);
  }

  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4; // Precompute window

  var nafPoints = p._getNAFPoints(w);

  w = nafPoints.wnd;
  var wnd = nafPoints.points; // Get NAF form

  var naf = getNAF(k, w); // Add `this`*(N+1) for every w-NAF index

  var acc = this.jpoint(null, null, null);

  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--) {
      k++;
    }

    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;
    var z = naf[i];
    assert(z !== 0);

    if (p.type === 'affine') {
      // J +- P
      if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      // J +- J
      if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }

  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3; // Fill all arrays

  var max = 0;

  for (var i = 0; i < len; i++) {
    var p = points[i];

    var nafPoints = p._getNAFPoints(defW);

    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  } // Comb small window NAFs


  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;

    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [points[a],
    /* 1 */
    null,
    /* 3 */
    null,
    /* 5 */
    points[b]
    /* 7 */
    ]; // Try to avoid Projective points, if possible

    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [-3,
    /* -1 -1 */
    -1,
    /* -1 0 */
    -5,
    /* -1 1 */
    -7,
    /* 0 -1 */
    0,
    /* 0 0 */
    7,
    /* 0 1 */
    5,
    /* 1 -1 */
    1,
    /* 1 0 */
    3
    /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);

    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;

  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;

      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0) zero = false;
      }

      if (!zero) break;
      k++;
      i--;
    }

    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
    }
  } // Zeroify references


  for (var i = 0; i < len; i++) {
    wnd[i] = null;
  }

  if (jacobianResult) return acc;else return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}

BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq()
/*other*/
{
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);
  var len = this.p.byteLength(); // uncompressed, hybrid-odd, hybrid-even

  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }

  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);
  if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
  return [0x04].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed) return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed) return false;
  var doubles = this.precomputed.doubles;
  if (!doubles) return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;

  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++) {
      acc = acc.dbl();
    }

    doubles.push(acc);
  }

  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();

  for (var i = 1; i < max; i++) {
    res[i] = res[i - 1].add(dbl);
  }

  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;

  for (var i = 0; i < k; i++) {
    r = r.dbl();
  }

  return r;
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(114);

var elliptic = __webpack_require__(110);

var BN = __webpack_require__(99);

var inherits = __webpack_require__(22);

var Base = curve.base;
var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0; // If the curve is endomorphic, precalculate beta and lambda

  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}

inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return; // Compute beta and lambda, that lambda * P = (beta * Px; Py)

  var beta;
  var lambda;

  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p); // Choose the smallest beta


    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }

  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);

    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  } // Get basis vectors, used for balanced length-two representation


  var basis;

  if (conf.basis) {
    basis = conf.basis.map(function (vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)); // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt

  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1); // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)

  var a0;
  var b0; // First vector

  var a1;
  var b1; // Second vector

  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;

  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }

    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }

  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());

  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  } // Normalize signs


  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }

  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b); // Calculate answer

  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return {
    k1: k1,
    k2: k2
  };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point'); // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf) return true;
  var x = point.x;
  var y = point.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;

  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);

    var p = points[i];

    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }

    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }

  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult); // Clean-up references to points and coefficients


  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }

  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');

  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16); // Force redgomery representation when loading from JSON

    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }

    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}

inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo) return;
  var pre = this.precomputed;
  if (pre && pre.beta) return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

  if (pre) {
    var curve = this.curve;

    var endoMul = function endoMul(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };

    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }

  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed) return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string') obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2]) return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf) return p; // P + O = P

  if (p.inf) return this; // P + P = 2P

  if (this.eq(p)) return this.dbl(); // P + (-P) = O

  if (this.neg().eq(p)) return this.curve.point(null, null); // P + Q = O

  if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf) return this; // 2P = O

  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf) return this;
  var res = this.curve.point(this.x, this.y.redNeg());

  if (_precompute && this.precomputed) {
    var pre = this.precomputed;

    var negate = function negate(p) {
      return p.neg();
    };

    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }

  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');

  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }

  if (!this.x.red) this.x = this.x.toRed(this.curve.red);
  if (!this.y.red) this.y = this.y.toRed(this.curve.red);
  if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}

inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity()) return p; // P + O = P

  if (p.isInfinity()) return this; // 12M + 4S + 7A

  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity()) return p.toJ(); // P + O = P

  if (p.isInfinity()) return this; // 8M + 3S + 7A

  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0) return this;
  if (this.isInfinity()) return this;
  if (!pow) return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;

    for (var i = 0; i < pow; i++) {
      r = r.dbl();
    }

    return r;
  } // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A


  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr(); // Reuse results

  var jyd = jy.redAdd(jy);

  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;
  if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a; a = 0

    var m = xx.redAdd(xx).redIAdd(xx); // T = M ^ 2 - 2*S

    var t = m.redSqr().redISub(s).redISub(s); // 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2*Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A
    // A = X1^2
    var a = this.x.redSqr(); // B = Y1^2

    var b = this.y.redSqr(); // C = B^2

    var c = b.redSqr(); // D = 2 * ((X1 + B)^2 - A - C)

    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d); // E = 3 * A

    var e = a.redAdd(a).redIAdd(a); // F = E^2

    var f = e.redSqr(); // 8 * C

    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8); // X3 = F - 2 * D

    nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C

    ny = e.redMul(d.redISub(nx)).redISub(c8); // Z3 = 2 * Y1 * Z1

    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a

    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a); // T = M^2 - 2 * S

    var t = m.redSqr().redISub(s).redISub(s); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2 * Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S
    // delta = Z1^2
    var delta = this.z.redSqr(); // gamma = Y1^2

    var gamma = this.y.redSqr(); // beta = X1 * gamma

    var beta = this.x.redMul(gamma); // alpha = 3 * (X1 - delta) * (X1 + delta)

    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha); // X3 = alpha^2 - 8 * beta

    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta

    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2

    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a; // 4M + 6S + 10A

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA) return this.dbl().add(this); // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...
  // XX = X1^2

  var xx = this.x.redSqr(); // YY = Y1^2

  var yy = this.y.redSqr(); // ZZ = Z1^2

  var zz = this.z.redSqr(); // YYYY = YY^2

  var yyyy = yy.redSqr(); // M = 3 * XX + a * ZZ2; a = 0

  var m = xx.redAdd(xx).redIAdd(xx); // MM = M^2

  var mm = m.redSqr(); // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM

  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm); // EE = E^2

  var ee = e.redSqr(); // T = 16*YYYY

  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t); // U = (M + E)^2 - MM - EE - T

  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t); // X3 = 4 * (X1 * EE - 4 * YY * U)

  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx); // Y3 = 8 * Y1 * (U * (T - U) - E * EE)

  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny); // Z3 = (Z1 + E)^2 - ZZ - EE

  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);
  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine') return this.eq(p.toJ());
  if (this === p) return true; // x1 * z2^2 == x2 * z1^2

  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false; // y1 * z2^3 == y2 * z1^3

  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(114);

var BN = __webpack_require__(99);

var inherits = __webpack_require__(22);

var Base = curve.base;

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}

inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');

  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  }
}

inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {// No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A
  // A = X1 + Z1
  var a = this.x.redAdd(this.z); // AA = A^2

  var aa = a.redSqr(); // B = X1 - Z1

  var b = this.x.redSub(this.z); // BB = B^2

  var bb = b.redSqr(); // C = AA - BB

  var c = aa.redSub(bb); // X3 = AA * BB

  var nx = aa.redMul(bb); // Z3 = C * (BB + A24 * C)

  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A
  // A = X2 + Z2
  var a = this.x.redAdd(this.z); // B = X2 - Z2

  var b = this.x.redSub(this.z); // C = X3 + Z3

  var c = p.x.redAdd(p.z); // D = X3 - Z3

  var d = p.x.redSub(p.z); // DA = D * A

  var da = d.redMul(a); // CB = C * B

  var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2

  var nx = diff.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2

  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q

  var b = this.curve.point(null, null); // (N / 2) * Q

  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) {
    bits.push(t.andln(1));
  }

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c); // N * Q = 2 * ((N / 2) * Q + Q))

      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c); // N * Q + Q = 2 * ((N / 2) * Q + Q)

      a = a.dbl();
    }
  }

  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();
  return this.x.fromRed();
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(114);

var elliptic = __webpack_require__(110);

var BN = __webpack_require__(99);

var inherits = __webpack_require__(22);

var Base = curve.base;
var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, 'edwards', conf);
  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}

inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA) return num.redNeg();else return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC) return num;else return this.c.redMul(num);
}; // Just for compatibility with Short curve


EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red) y = y.toRed(this.red); // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)

  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd) throw new Error('invalid point');else return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error('invalid point');
  if (x.fromRed().isOdd() !== odd) x = x.redNeg();
  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity()) return true; // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)

  point.normalize();
  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');

  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one; // Use extended coordinates

    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
    }
  }
}

inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S
  // A = X1^2
  var a = this.x.redSqr(); // B = Y1^2

  var b = this.y.redSqr(); // C = 2 * Z1^2

  var c = this.z.redSqr();
  c = c.redIAdd(c); // D = a * A

  var d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B


  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B

  var g = d.redAdd(b); // F = G - C

  var f = g.redSub(c); // H = D - B

  var h = d.redSub(b); // X3 = E * F

  var nx = e.redMul(f); // Y3 = G * H

  var ny = g.redMul(h); // T3 = E * H

  var nt = e.redMul(h); // Z3 = F * G

  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S
  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr(); // C = X1^2

  var c = this.x.redSqr(); // D = Y1^2

  var d = this.y.redSqr();
  var nx;
  var ny;
  var nz;

  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c); // F = E + D


    var f = e.redAdd(d);

    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)); // Y3 = F * (E - D)

      ny = f.redMul(e.redSub(d)); // Z3 = F^2 - 2 * F

      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr(); // J = F - 2 * H

      var j = f.redSub(h).redISub(h); // X3 = (B-C-D)*J

      nx = b.redSub(c).redISub(d).redMul(j); // Y3 = F * (E - D)

      ny = f.redMul(e.redSub(d)); // Z3 = F * J

      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d); // H = (c * Z1)^2

    var h = this.curve._mulC(this.z).redSqr(); // J = E - 2 * H


    var j = e.redSub(h).redSub(h); // X3 = c * (B - E) * J

    nx = this.curve._mulC(b.redISub(e)).redMul(j); // Y3 = c * E * (C - D)

    ny = this.curve._mulC(e).redMul(c.redISub(d)); // Z3 = E * J

    nz = e.redMul(j);
  }

  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this; // Double in extended coordinates

  if (this.curve.extended) return this._extDbl();else return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M
  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)

  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2

  var c = this.t.redMul(this.curve.dd).redMul(p.t); // D = Z1 * 2 * Z2

  var d = this.z.redMul(p.z.redAdd(p.z)); // E = B - A

  var e = b.redSub(a); // F = D - C

  var f = d.redSub(c); // G = D + C

  var g = d.redAdd(c); // H = B + A

  var h = b.redAdd(a); // X3 = E * F

  var nx = e.redMul(f); // Y3 = G * H

  var ny = g.redMul(h); // T3 = E * H

  var nt = e.redMul(h); // Z3 = F * G

  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S
  // A = Z1 * Z2
  var a = this.z.redMul(p.z); // B = A^2

  var b = a.redSqr(); // C = X1 * X2

  var c = this.x.redMul(p.x); // D = Y1 * Y2

  var d = this.y.redMul(p.y); // E = d * C * D

  var e = this.curve.d.redMul(c).redMul(d); // F = B - E

  var f = b.redSub(e); // G = B + E

  var g = b.redAdd(e); // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)

  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;

  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))); // Z3 = F * G

    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c)); // Z3 = c * F * G

    nz = this.curve._mulC(f).redMul(g);
  }

  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity()) return p;
  if (p.isInfinity()) return this;
  if (this.curve.extended) return this._extAdd(p);else return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne) return this; // Normalize coordinates

  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t) this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
}; // Compatibility with BaseCurve


Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(120);

var elliptic = __webpack_require__(110);

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short') this.curve = new elliptic.curve.short(options);else if (options.type === 'edwards') this.curve = new elliptic.curve.edwards(options);else this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;
  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}

curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
});
defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
});
defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
});
defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
});
defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
});
defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['9']
});
defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', // 4/5
  '6666666666666666666666666666666666666666666666666666666666666658']
});
var pre;

try {
  pre = __webpack_require__(132);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,
  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [{
    a: '3086d221a7d46bcde86c90e49284eb15',
    b: '-e4437ed6010e88286f547fa90abfe4c3'
  }, {
    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
    b: '3086d221a7d46bcde86c90e49284eb15'
  }],
  gRed: false,
  g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;
hash.utils = __webpack_require__(121);
hash.common = __webpack_require__(122);
hash.sha = __webpack_require__(123);
hash.ripemd = __webpack_require__(130);
hash.hmac = __webpack_require__(131); // Proxy hash functions to the main object

hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(73);

var inherits = __webpack_require__(22);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }

  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }

  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];

  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;

      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);

        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;

      for (i = 0; i < msg.length; i += 2) {
        res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    }
  } else {
    for (i = 0; i < msg.length; i++) {
      res[i] = msg[i] | 0;
    }
  }

  return res;
}

exports.toArray = toArray;

function toHex(msg) {
  var res = '';

  for (var i = 0; i < msg.length; i++) {
    res += zero2(msg[i].toString(16));
  }

  return res;
}

exports.toHex = toHex;

function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
  return res >>> 0;
}

exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';

  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little') w = htonl(w);
    res += zero8(w.toString(16));
  }

  return res;
}

exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}

exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
}

exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);

  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }

  return res;
}

exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);

  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];

    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 0xff;
      res[k + 2] = m >>> 8 & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 0xff;
      res[k + 1] = m >>> 8 & 0xff;
      res[k] = m & 0xff;
    }
  }

  return res;
}

exports.split32 = split32;

function rotr32(w, b) {
  return w >>> b | w << 32 - b;
}

exports.rotr32 = rotr32;

function rotl32(w, b) {
  return w << b | w >>> 32 - b;
}

exports.rotl32 = rotl32;

function sum32(a, b) {
  return a + b >>> 0;
}

exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return a + b + c >>> 0;
}

exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return a + b + c + d >>> 0;
}

exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}

exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}

exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}

exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}

exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}

exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}

exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}

exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}

exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = al << 32 - num | ah >>> num;
  return r >>> 0;
}

exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}

exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

exports.shr64_lo = shr64_lo;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var assert = __webpack_require__(73);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}

exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length; // Enough data, try updating

  if (this.pending.length >= this._delta8) {
    msg = this.pending; // Process pending data in blocks

    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0) this.pending = null;
    msg = utils.join32(msg, 0, msg.length - r, this.endian);

    for (var i = 0; i < msg.length; i += this._delta32) {
      this._update(msg, i, i + this._delta32);
    }
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);
  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 0x80;

  for (var i = 1; i < k; i++) {
    res[i] = 0;
  } // Append length


  len <<= 3;

  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++) {
      res[i++] = 0;
    }

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++) {
      res[i++] = 0;
    }
  }

  return res;
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(124);
exports.sha224 = __webpack_require__(126);
exports.sha256 = __webpack_require__(127);
exports.sha384 = __webpack_require__(128);
exports.sha512 = __webpack_require__(129);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var common = __webpack_require__(122);

var shaCommon = __webpack_require__(125);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];

function SHA1() {
  if (!(this instanceof SHA1)) return new SHA1();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) {
    W[i] = msg[start + i];
  }

  for (; i < W.length; i++) {
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
  }

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0) return ch32(x, y, z);
  if (s === 1 || s === 3) return p32(x, y, z);
  if (s === 2) return maj32(x, y, z);
}

exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return x & y ^ ~x & z;
}

exports.ch32 = ch32;

function maj32(x, y, z) {
  return x & y ^ x & z ^ y & z;
}

exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}

exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}

exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}

exports.g1_256 = g1_256;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var SHA256 = __webpack_require__(127);

function SHA224() {
  if (!(this instanceof SHA224)) return new SHA224();
  SHA256.call(this);
  this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
}

utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var common = __webpack_require__(122);

var shaCommon = __webpack_require__(125);

var assert = __webpack_require__(73);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

function SHA256() {
  if (!(this instanceof SHA256)) return new SHA256();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
  this.k = sha256_K;
  this.W = new Array(64);
}

utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) {
    W[i] = msg[start + i];
  }

  for (; i < W.length; i++) {
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
  }

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert(this.k.length === W.length);

  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var SHA512 = __webpack_require__(129);

function SHA384() {
  if (!(this instanceof SHA384)) return new SHA384();
  SHA512.call(this);
  this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
}

utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var common = __webpack_require__(122);

var assert = __webpack_require__(73);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

function SHA512() {
  if (!(this instanceof SHA512)) return new SHA512();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
  this.k = sha512_K;
  this.W = new Array(160);
}

utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W; // 32 x 32bit words

  for (var i = 0; i < 32; i++) {
    W[i] = msg[start + i];
  }

  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2

    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14]; // i - 7

    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15

    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32]; // i - 16

    var c3_lo = W[i - 31];
    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert(this.k.length === W.length);

  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ ~xh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ ~xl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ xh & zh ^ yh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ xl & zl ^ yl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2); // 34

  var c2_hi = rotr64_hi(xl, xh, 7); // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2); // 34

  var c2_lo = rotr64_lo(xl, xh, 7); // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9); // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9); // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29); // 61

  var c2_hi = shr64_hi(xh, xl, 6);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29); // 61

  var c2_lo = shr64_lo(xh, xl, 6);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var common = __webpack_require__(122);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160)) return new RIPEMD160();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.endian = 'little';
}

utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;

  for (var j = 0; j < 80; j++) {
    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }

  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
}

function K(j) {
  if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
}

var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(121);

var assert = __webpack_require__(73);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}

module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize); // Add padding to key

  for (var i = key.length; i < this.blockSize; i++) {
    key.push(0);
  }

  for (i = 0; i < key.length; i++) {
    key[i] ^= 0x36;
  }

  this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a

  for (i = 0; i < key.length; i++) {
    key[i] ^= 0x6a;
  }

  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
  },
  naf: {
    wnd: 7,
    points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
  }
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(99);

var HmacDRBG = __webpack_require__(134);

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(135);

var Signature = __webpack_require__(136);

function EC(options) {
  if (!(this instanceof EC)) return new EC(options); // Shortcut `elliptic.ec(curve-name)`

  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);
    options = elliptic.curves[options];
  } // Shortcut for `elliptic.ec(elliptic.curves.curveName)`


  if (options instanceof elliptic.curves.PresetCurve) options = {
    curve: options
  };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g; // Point on curve

  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1); // Hash for function for DRBG

  this.hash = options.hash || options.curve.hash;
}

module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options) options = {}; // Instantiate Hmac_DRBG

  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));

  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0) continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0) msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }

  if (!options) options = {};
  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16)); // Zero-extend key to provide enough entropy

  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes); // Zero-extend nonce to have the same byte size as N

  var nonce = msg.toArray('be', bytes); // Instantiate Hmac_DRBG

  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  }); // Number of bytes to generate

  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity()) continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0) continue;
    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0) continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0); // Use complement of `s`, if it is > `n / 2`

    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({
      r: r,
      s: s,
      recoveryParam: recoveryParam
    });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex'); // Perform primitive values validation

  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false; // Validate signature

  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  } // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K


  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity()) return false; // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`

  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);
  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s; // A set LSB signifies that the y-coordinate is odd

  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate'); // 1.1. Let x = r + jn.

  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)

  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null) return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;

    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q)) return i;
  }

  throw new Error('Unable to find valid recovery factor');
};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(120);

var utils = __webpack_require__(113);

var assert = __webpack_require__(73);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._init(entropy, nonce, pers);
}

module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);

  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);

  this._reseed = 1;
  this.reseedInterval = 0x1000000000000; // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0x00]);

  if (seed) kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed) return;
  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));

  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); // Optional encoding

  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  } // Optional additional data


  if (add) {
    add = utils.toArray(add, addEnc || 'hex');

    this._update(add);
  }

  var temp = [];

  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);

  this._update(add);

  this._reseed++;
  return utils.encode(res, enc);
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(99);

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })

  if (options.priv) this._importPrivate(options.priv, options.privEnc);
  if (options.pub) this._importPublic(options.pub, options.pubEnc);
}

module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair) return priv;
  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();
  if (pub.isInfinity()) return {
    result: false,
    reason: 'Invalid public key'
  };
  if (!pub.validate()) return {
    result: false,
    reason: 'Public key is not a point'
  };
  if (!pub.mul(this.ec.curve.n).isInfinity()) return {
    result: false,
    reason: 'Public key * N != O'
  };
  return {
    result: true,
    reason: null
  };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub) this.pub = this.ec.g.mul(this.priv);
  if (!enc) return this.pub;
  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method

  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }

    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }

  this.pub = this.ec.curve.decodePoint(key, enc);
}; // ECDH


KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
}; // ECDSA


KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(99);

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature) return options;
  if (this._importDER(options, enc)) return;
  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
}

module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];

  if (!(initial & 0x80)) {
    return initial;
  }

  var octetLen = initial & 0xf;
  var val = 0;

  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;

  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }

  if (i === 0) {
    return buf;
  }

  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();

  if (data[p.place++] !== 0x30) {
    return false;
  }

  var len = getLength(data, p);

  if (len + p.place !== data.length) {
    return false;
  }

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var slen = getLength(data, p);

  if (data.length !== slen + p.place) {
    return false;
  }

  var s = data.slice(p.place, slen + p.place);

  if (r[0] === 0 && r[1] & 0x80) {
    r = r.slice(1);
  }

  if (s[0] === 0 && s[1] & 0x80) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;
  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }

  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);

  while (--octets) {
    arr.push(len >>> (octets << 3) & 0xff);
  }

  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray(); // Pad values

  if (r[0] & 0x80) r = [0].concat(r); // Pad values

  if (s[0] & 0x80) s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }

  var arr = [0x02];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [0x30];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(120);

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;

var KeyPair = __webpack_require__(138);

var Signature = __webpack_require__(139);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');
  if (!(this instanceof EDDSA)) return new EDDSA(curve);
  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);
  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/

EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({
    R: R,
    S: S,
    Rencoded: Rencoded
  });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/


EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();

  for (var i = 0; i < arguments.length; i++) {
    hash.update(arguments[i]);
  }

  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature) return sig;
  return new Signature(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/


EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/

function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub)) this._pub = params.pub;else this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(eddsa, {
    pub: pub
  });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair) return secret;
  return new KeyPair(eddsa, {
    secret: secret
  });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;
  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;
  return a;
});
cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(99);

var elliptic = __webpack_require__(110);

var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/

function Signature(eddsa, sig) {
  this.eddsa = eddsa;
  if (typeof sig !== 'object') sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');
  if (eddsa.isPoint(sig.R)) this._R = sig.R;
  if (sig.S instanceof BN) this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var asn1 = __webpack_require__(141);

var aesid = __webpack_require__(159);

var fixProc = __webpack_require__(160);

var ciphers = __webpack_require__(77);

var compat = __webpack_require__(63);

module.exports = parseKeys;

function parseKeys(buffer) {
  var password;

  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }

  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer);
  }

  var stripped = fixProc(buffer, password);
  var type = stripped.tag;
  var data = stripped.data;
  var subtype, ndata;

  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
    // falls through

    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der');
      }

      subtype = ndata.algorithm.algorithm.join('.');

      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');

        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: 'ec',
            data: ndata
          };

        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          };

        default:
          throw new Error('unknown key id ' + subtype);
      }

      throw new Error('unknown key type ' + type);

    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der');
      data = decrypt(data, password);
    // falls through

    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');

      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');

        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          };

        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          };

        default:
          throw new Error('unknown key id ' + subtype);
      }

      throw new Error('unknown key type ' + type);

    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der');

    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der');

    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      };

    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der');
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };

    default:
      throw new Error('unknown key type ' + type);
  }
}

parseKeys.signature = asn1.signature;

function decrypt(data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
  var iv = data.algorithm.decrypt.cipher.iv;
  var cipherText = data.subjectPrivateKey;
  var keylen = parseInt(algo.split('-')[1], 10) / 8;
  var key = compat.pbkdf2Sync(password, salt, iters, keylen);
  var cipher = ciphers.createDecipheriv(algo, key, iv);
  var out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer.concat(out);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(142);

exports.certificate = __webpack_require__(158);
var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('modulus').int(), this.key('publicExponent').int(), this.key('privateExponent').int(), this.key('prime1').int(), this.key('prime2').int(), this.key('exponent1').int(), this.key('exponent2').int(), this.key('coefficient').int());
});
exports.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int());
});
exports.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
});
exports.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(this.key('algorithm').objid(), this.key('none').null_().optional(), this.key('curve').objid().optional(), this.key('params').seq().obj(this.key('p').int(), this.key('q').int(), this.key('g').int()).optional());
});
var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(this.key('version').int(), this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPrivateKey').octstr());
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(this.key('algorithm').seq().obj(this.key('id').objid(), this.key('decrypt').seq().obj(this.key('kde').seq().obj(this.key('id').objid(), this.key('kdeparams').seq().obj(this.key('salt').octstr(), this.key('iters').int())), this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr()))), this.key('subjectPrivateKey').octstr());
});
exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('p').int(), this.key('q').int(), this.key('g').int(), this.key('pub_key').int(), this.key('priv_key').int());
});
exports.DSAPrivateKey = DSAPrivateKey;
exports.DSAparam = asn1.define('DSAparam', function () {
  this.int();
});
var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').optional().explicit(0).use(ECParameters), this.key('publicKey').optional().explicit(1).bitstr());
});
exports.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  });
});
exports.signature = asn1.define('signature', function () {
  this.seq().obj(this.key('r').int(), this.key('s').int());
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;
asn1.bignum = __webpack_require__(99);
asn1.define = __webpack_require__(143).define;
asn1.base = __webpack_require__(146);
asn1.constants = __webpack_require__(150);
asn1.decoders = __webpack_require__(152);
asn1.encoders = __webpack_require__(155);

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(142);

var inherits = __webpack_require__(22);

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;
  this.decoders = {};
  this.encoders = {};
}

;

Entity.prototype._createNamed = function createNamed(base) {
  var named;

  try {
    named = __webpack_require__(144).runInThisContext('(function ' + this.name + '(entity) {\n' + '  this._initNamed(entity);\n' + '})');
  } catch (e) {
    named = function named(entity) {
      this._initNamed(entity);
    };
  }

  inherits(named, base);

  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der'; // Lazily create decoder

  if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der'; // Lazily create encoder

  if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc,
/* internal */
reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(145);

var Object_keys = function Object_keys(obj) {
  if (Object.keys) return Object.keys(obj);else {
    var res = [];

    for (var key in obj) {
      res.push(key);
    }

    return res;
  }
};

var forEach = function forEach(xs, fn) {
  if (xs.forEach) return xs.forEach(fn);else for (var i = 0; i < xs.length; i++) {
    fn(xs[i], i, xs);
  }
};

var defineProp = function () {
  try {
    Object.defineProperty({}, '_', {});
    return function (obj, name, value) {
      Object.defineProperty(obj, name, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: value
      });
    };
  } catch (e) {
    return function (obj, name, value) {
      obj[name] = value;
    };
  }
}();

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function', 'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}

Context.prototype = {};

var Script = exports.Script = function NodeScript(code) {
  if (!(this instanceof Script)) return new Script(code);
  this.code = code;
};

Script.prototype.runInContext = function (context) {
  if (!(context instanceof Context)) {
    throw new TypeError("needs a 'context' argument.");
  }

  var iframe = document.createElement('iframe');
  if (!iframe.style) iframe.style = {};
  iframe.style.display = 'none';
  document.body.appendChild(iframe);
  var win = iframe.contentWindow;
  var wEval = win.eval,
      wExecScript = win.execScript;

  if (!wEval && wExecScript) {
    // win.eval() magically appears when this is called in IE:
    wExecScript.call(win, 'null');
    wEval = win.eval;
  }

  forEach(Object_keys(context), function (key) {
    win[key] = context[key];
  });
  forEach(globals, function (key) {
    if (context[key]) {
      win[key] = context[key];
    }
  });
  var winKeys = Object_keys(win);
  var res = wEval.call(win, this.code);
  forEach(Object_keys(win), function (key) {
    // Avoid copying circular objects like `top` and `window` by only
    // updating existing context properties or new properties in the `win`
    // that was only introduced after the eval.
    if (key in context || indexOf(winKeys, key) === -1) {
      context[key] = win[key];
    }
  });
  forEach(globals, function (key) {
    if (!(key in context)) {
      defineProp(context, key, win[key]);
    }
  });
  document.body.removeChild(iframe);
  return res;
};

Script.prototype.runInThisContext = function () {
  return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
  var ctx = Script.createContext(context);
  var res = this.runInContext(ctx);
  forEach(Object_keys(ctx), function (key) {
    context[key] = ctx[key];
  });
  return res;
};

forEach(Object_keys(Script.prototype), function (name) {
  exports[name] = Script[name] = function (code) {
    var s = Script(code);
    return s[name].apply(s, [].slice.call(arguments, 1));
  };
});

exports.createScript = function (code) {
  return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
  var copy = new Context();

  if (typeof context === 'object') {
    forEach(Object_keys(context), function (key) {
      copy[key] = context[key];
    });
  }

  return copy;
};

/***/ }),
/* 145 */
/***/ (function(module, exports) {

var indexOf = [].indexOf;

module.exports = function (arr, obj) {
  if (indexOf) return arr.indexOf(obj);

  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }

  return -1;
};

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;
base.Reporter = __webpack_require__(147).Reporter;
base.DecoderBuffer = __webpack_require__(148).DecoderBuffer;
base.EncoderBuffer = __webpack_require__(148).EncoderBuffer;
base.Node = __webpack_require__(149);

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}

exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;
  return {
    obj: state.obj,
    pathLen: state.path.length
  };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null) state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;
  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;
  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;
  var inherited = msg instanceof ReporterError;

  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function (elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial) throw err;
  if (!inherited) state.errors.push(err);
  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial) return result;
  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}

;
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }

  return this;
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var Reporter = __webpack_require__(146).Reporter;

var Buffer = __webpack_require__(17).Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);

  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}

inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return {
    offset: this.offset,
    reporter: Reporter.prototype.save.call(this)
  };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;
  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);
  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);else return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun');
  var res = new DecoderBuffer(this.base); // Share reporter state

  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function (item) {
      if (!(item instanceof EncoderBuffer)) item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}

exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out) out = new Buffer(this.length);
  if (!offset) offset = 0;
  if (this.length === 0) return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function (item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number') out[offset] = this.value;else if (typeof this.value === 'string') out.write(this.value, offset);else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(146).Reporter;

var EncoderBuffer = __webpack_require__(146).EncoderBuffer;

var DecoderBuffer = __webpack_require__(146).DecoderBuffer;

var assert = __webpack_require__(73); // Supported tags


var tags = ['seq', 'seqof', 'set', 'setof', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc', 'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str', 'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr']; // Public methods list

var methods = ['key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any', 'contains'].concat(tags); // Overrided methods list

var overrided = ['_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool'];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null; // State

  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null; // Should create new instance on each method

  if (!state.parent) {
    state.children = [];

    this._wrap();
  }
}

module.exports = Node;
var stateProps = ['enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit', 'contains'];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function (prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function (method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;
  assert(state.parent === null);
  body.call(this); // Filter children

  state.children = state.children.filter(function (child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState; // Filter children and args

  var children = args.filter(function (arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function (arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children; // Replace parent to maintain backward link

    children.forEach(function (child) {
      child._baseState.parent = this;
    }, this);
  }

  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function (arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object) return arg;
      var res = {};
      Object.keys(arg).forEach(function (key) {
        if (key == (key | 0)) key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
}; //
// Overrided methods
//


overrided.forEach(function (method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
}); //
// Public methods
//

tags.forEach(function (tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;
  assert(state.use === null);
  state.use = item;
  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;
  state.optional = true;
  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;
  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;
  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0) this._useArgs(args);
  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;
  assert(state.key === null);
  state.key = newKey;
  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;
  state.any = true;
  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;
  assert(state.choice === null);
  state.choice = obj;

  this._useArgs(Object.keys(obj).map(function (key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;
  assert(state.use === null);
  state.contains = item;
  return this;
}; //
// Decoding
//


Node.prototype._decode = function decode(input, options) {
  var state = this._baseState; // Decode root node

  if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options));
  var result = state['default'];
  var present = true;
  var prevKey = null;
  if (state.key !== null) prevKey = input.enterKey(state.key); // Check if tag is there

  if (state.optional) {
    var tag = null;
    if (state.explicit !== null) tag = state.explicit;else if (state.implicit !== null) tag = state.implicit;else if (state.tag !== null) tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();

      try {
        if (state.choice === null) this._decodeGeneric(state.tag, input, options);else this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }

      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);
      if (input.isError(present)) return present;
    }
  } // Push object on stack


  var prevObj;
  if (state.obj && present) prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);

      if (input.isError(explicit)) return explicit;
      input = explicit;
    }

    var start = input.offset; // Unwrap implicit and normal values

    if (state.use === null && state.choice === null) {
      if (state.any) var save = input.save();

      var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);

      if (input.isError(body)) return body;
      if (state.any) result = input.raw(save);else input = body;
    }

    if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, 'tagged');
    if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, 'content'); // Select proper method for tag

    if (state.any) result = result;else if (state.choice === null) result = this._decodeGeneric(state.tag, input, options);else result = this._decodeChoice(input, options);
    if (input.isError(result)) return result; // Decode children

    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    } // Decode contained/encoded by schema, only in bit or octet strings


    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  } // Pop object


  if (state.obj && present) result = input.leaveObject(prevObj); // Set key

  if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result);else if (prevKey !== null) input.exitKey(prevKey);
  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;
  if (tag === 'seq' || tag === 'set') return null;
  if (tag === 'seqof' || tag === 'setof') return this._decodeList(input, tag, state.args[0], options);else if (/str$/.test(tag)) return this._decodeStr(input, tag, options);else if (tag === 'objid' && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options);else if (tag === 'objid') return this._decodeObjid(input, null, null, options);else if (tag === 'gentime' || tag === 'utctime') return this._decodeTime(input, tag, options);else if (tag === 'null_') return this._decodeNull(input, options);else if (tag === 'bool') return this._decodeBool(input, options);else if (tag === 'objDesc') return this._decodeStr(input, tag, options);else if (tag === 'int' || tag === 'enum') return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {
  var state = this._baseState; // Create altered use decoder if implicit is set

  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];

  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }

  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;
  Object.keys(state.choice).some(function (key) {
    var save = input.save();
    var node = state.choice[key];

    try {
      var value = node._decode(input, options);

      if (input.isError(value)) return false;
      result = {
        type: key,
        value: value
      };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }

    return true;
  }, this);
  if (!match) return input.error('Choice not matched');
  return result;
}; //
// Encoding
//


Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data) return;

  var result = this._encodeValue(data, reporter, parent);

  if (result === undefined) return;
  if (this._skipDefault(result, reporter, parent)) return;
  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState; // Decode root node

  if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
  var result = null; // Set reporter to share it with a child class

  this.reporter = reporter; // Check if data is there

  if (state.optional && data === undefined) {
    if (state['default'] !== null) data = state['default'];else return;
  } // Encode children first


  var content = null;
  var primitive = false;

  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function (child) {
      if (child._baseState.tag === 'null_') return child._encode(null, reporter, data);
      if (child._baseState.key === null) return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);
      if (typeof data !== 'object') return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);

      reporter.leaveKey(prevKey);
      return res;
    }, this).filter(function (child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1)) return reporter.error('Too many args for : ' + state.tag);
      if (!Array.isArray(data)) return reporter.error('seqof/setof, but data is not Array');
      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function (item) {
        var state = this._baseState;
        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  } // Encode data itself


  var result;

  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null) reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
    }
  } // Wrap in explicit


  if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, 'context', result);
  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;
  var node = state.choice[data.type];

  if (!node) {
    assert(false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice)));
  }

  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;
  if (/str$/.test(tag)) return this._encodeStr(data, tag);else if (tag === 'objid' && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);else if (tag === 'objid') return this._encodeObjid(data, null, null);else if (tag === 'gentime' || tag === 'utctime') return this._encodeTime(data, tag);else if (tag === 'null_') return this._encodeNull();else if (tag === 'int' || tag === 'enum') return this._encodeInt(data, state.args && state.reverseArgs[0]);else if (tag === 'bool') return this._encodeBool(data);else if (tag === 'objDesc') return this._encodeStr(data, tag);else throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports; // Helper

constants._reverse = function reverse(map) {
  var res = {};
  Object.keys(map).forEach(function (key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key) key = key | 0;
    var value = map[key];
    res[value] = key;
  });
  return res;
};

constants.der = __webpack_require__(151);

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(150);

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);
exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;
decoders.der = __webpack_require__(153);
decoders.pem = __webpack_require__(154);

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var asn1 = __webpack_require__(142);

var base = asn1.base;
var bignum = asn1.bignum; // Import DER constants

var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity; // Construct base tree

  this.tree = new DERNode();

  this.tree._init(entity.body);
}

;
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer)) data = new base.DecoderBuffer(data, options);
  return this.tree._decode(data, options);
}; // Tree methods


function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}

inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty()) return false;
  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag)) return decodedTag;
  buffer.restore(state);
  return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + 'of' === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag)) return decodedTag;
  var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"'); // Failure

  if (buffer.isError(len)) return len;

  if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"'); // Indefinite length... find END tag

  var state = buffer.save();

  var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');

  if (buffer.isError(res)) return res;
  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag)) return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len)) return len;
    var res;
    if (tag.primitive || len !== null) res = buffer.skip(len);else res = this._skipUntilEnd(buffer, fail); // Failure

    if (buffer.isError(res)) return res;
    if (tag.tagStr === 'end') break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
  var result = [];

  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');

    if (buffer.isError(possibleEnd)) return possibleEnd;
    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd) break;
    result.push(res);
  }

  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused)) return unused;
    return {
      unused: unused,
      data: buffer.raw()
    };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1) return buffer.error('Decoding of string type: bmpstr length mismatch');
    var str = '';

    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }

    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');

    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' + 'numstr unsupported characters');
    }

    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');

    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' + 'printstr unsupported characters');
    }

    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;

  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;

    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }

  if (subident & 0x80) identifiers.push(ident);
  var first = identifiers[0] / 40 | 0;
  var second = identifiers[0] % 40;
  if (relative) result = identifiers;else result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined) tmp = values[result.join('.')];
    if (tmp !== undefined) result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();

  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70) year = 2000 + year;else year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res)) return res;else return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);
  if (values) res = values[res.toString(10)] || res;
  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function') entity = entity(obj);
  return entity._getDecoder('der').tree;
}; // Utility methods


function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag)) return tag;
  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0; // Multi-octet tag - load

  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;

    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct)) return oct;
      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }

  var tagStr = der.tag[tag];
  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len)) return len; // Indefinite form

  if (!primitive && len === 0x80) return null; // Definite form

  if ((len & 0x80) === 0) {
    // Short form
    return len;
  } // Long form


  var num = len & 0x7f;
  if (num > 4) return buf.error('length octect is too long');
  len = 0;

  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j)) return j;
    len |= j;
  }

  return len;
}

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var Buffer = __webpack_require__(17).Buffer;

var DERDecoder = __webpack_require__(153);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}

;
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);
  var label = options.label.toUpperCase();
  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;

  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null) continue;
    if (match[2] !== label) continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN') break;
      start = i;
    } else {
      if (match[1] !== 'END') break;
      end = i;
      break;
    }
  }

  if (start === -1 || end === -1) throw new Error('PEM section not found for: ' + label);
  var base64 = lines.slice(start + 1, end).join(''); // Remove excessive symbols

  base64.replace(/[^a-z0-9\+\/=]+/gi, '');
  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;
encoders.der = __webpack_require__(156);
encoders.pem = __webpack_require__(157);

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var Buffer = __webpack_require__(17).Buffer;

var asn1 = __webpack_require__(142);

var base = asn1.base; // Import DER constants

var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity; // Construct base tree

  this.tree = new DERNode();

  this.tree._init(entity.body);
}

;
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
}; // Tree methods


function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}

inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter); // Short form

  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([header, content]);
  } // Long form
  // Count octets required to store length


  var lenOctets = 1;

  for (var i = content.length; i >= 0x100; i >>= 8) {
    lenOctets++;
  }

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) {
    header[i] = j & 0xff;
  }

  return this._createEncoderBuffer([header, content]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);

    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }

    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space');
    }

    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark');
    }

    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values) return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);

    for (var i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  } else if (Array.isArray(id)) {
    id = id.slice();

    for (var i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  } // Count number of octets


  var size = 0;

  for (var i = 0; i < id.length; i++) {
    var ident = id[i];

    for (size++; ident >= 0x80; ident >>= 7) {
      size++;
    }
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;

  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;

    while ((ident >>= 7) > 0) {
      objid[offset--] = 0x80 | ident & 0x7f;
    }
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10) return '0' + num;else return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
  } else if (tag === 'utctime') {
    str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values) return this.reporter.error('String int or enum given, but no values map');

    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
    }

    num = values[num];
  } // Bignum, assume big endian


  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();

    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }

    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0) size++;
    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0) out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80) return this._createEncoderBuffer(num);
  if (num < 0x100) return this._createEncoderBuffer([0, num]);
  var size = 1;

  for (var i = num; i >= 0x100; i >>= 8) {
    size++;
  }

  var out = new Array(size);

  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }

  if (out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function') entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null) return false;
  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
  if (data.length !== state.defaultBuffer.length) return false;

  for (i = 0; i < data.length; i++) {
    if (data[i] !== state.defaultBuffer[i]) return false;
  }

  return true;
}; // Utility methods


function encodeTag(tag, primitive, cls, reporter) {
  var res;
  if (tag === 'seqof') tag = 'seq';else if (tag === 'setof') tag = 'set';
  if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;else return reporter.error('Unknown tag: ' + tag);
  if (res >= 0x1f) return reporter.error('Multi-octet tag encoding unsupported');
  if (!primitive) res |= 0x20;
  res |= der.tagClassByName[cls || 'universal'] << 6;
  return res;
}

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(22);

var DEREncoder = __webpack_require__(156);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}

;
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);
  var p = buf.toString('base64');
  var out = ['-----BEGIN ' + options.label + '-----'];

  for (var i = 0; i < p.length; i += 64) {
    out.push(p.slice(i, i + 64));
  }

  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen


var asn = __webpack_require__(142);

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(this.key('type').objid(), this.key('value').any());
});
var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(this.key('algorithm').objid(), this.key('parameters').optional());
});
var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
});
var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue);
});
var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName);
});
var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = asn.define('Validity', function () {
  this.seq().obj(this.key('notBefore').use(Time), this.key('notAfter').use(Time));
});
var Extension = asn.define('Extension', function () {
  this.seq().obj(this.key('extnID').objid(), this.key('critical').bool().def(false), this.key('extnValue').octstr());
});
var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(this.key('version').explicit(0).int(), this.key('serialNumber').int(), this.key('signature').use(AlgorithmIdentifier), this.key('issuer').use(Name), this.key('validity').use(Validity), this.key('subject').use(Name), this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo), this.key('issuerUniqueID').implicit(1).bitstr().optional(), this.key('subjectUniqueID').implicit(2).bitstr().optional(), this.key('extensions').explicit(3).seqof(Extension).optional());
});
var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(this.key('tbsCertificate').use(TBSCertificate), this.key('signatureAlgorithm').use(AlgorithmIdentifier), this.key('signatureValue').bitstr());
});
module.exports = X509Certificate;

/***/ }),
/* 159 */
/***/ (function(module) {

module.exports = {"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"};

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m;

var evp = __webpack_require__(94);

var ciphers = __webpack_require__(77);

module.exports = function (okey, password) {
  var key = okey.toString();
  var match = key.match(findProc);
  var decrypted;

  if (!match) {
    var match2 = key.match(fullRegex);
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64');
  } else {
    var suite = 'aes' + match[1];
    var iv = new Buffer(match[2], 'hex');
    var cipherText = new Buffer(match[3].replace(/[\r\n]/g, ''), 'base64');
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    var out = [];
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer.concat(out);
  }

  var tag = key.match(startRegex)[1];
  return {
    tag: tag,
    data: decrypted
  };
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 161 */
/***/ (function(module) {

module.exports = {"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(99);

var EC = __webpack_require__(110).ec;

var parseKeys = __webpack_require__(140);

var curves = __webpack_require__(161);

function verify(sig, hash, key, signType, tag) {
  var pub = parseKeys(key);

  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type');
    return dsaVerify(sig, hash, pub);
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type');
  }

  hash = Buffer.concat([tag, hash]);
  var len = pub.modulus.byteLength();
  var pad = [1];
  var padNum = 0;

  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff);
    padNum++;
  }

  pad.push(0x00);
  var i = -1;

  while (++i < hash.length) {
    pad.push(hash[i]);
  }

  pad = new Buffer(pad);
  var red = BN.mont(pub.modulus);
  sig = new BN(sig).toRed(red);
  sig = sig.redPow(new BN(pub.publicExponent));
  sig = new Buffer(sig.fromRed().toArray());
  var out = padNum < 8 ? 1 : 0;
  len = Math.min(sig.length, pad.length);
  if (sig.length !== pad.length) out = 1;
  i = -1;

  while (++i < len) {
    out |= sig[i] ^ pad[i];
  }

  return out === 0;
}

function ecVerify(sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')];
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));
  var curve = new EC(curveId);
  var pubkey = pub.data.subjectPrivateKey.data;
  return curve.verify(hash, sig, pubkey);
}

function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montp = BN.mont(p);
  var w = s.invm(q);
  var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
  return v.cmp(r) === 0;
}

function checkValue(b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig');
  if (b.cmp(q) >= q) throw new Error('invalid sig');
}

module.exports = verify;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(110);

var BN = __webpack_require__(99);

module.exports = function createECDH(curve) {
  return new ECDH(curve);
};

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
};
aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
  this.curveType = aliases[curve];

  if (!this.curveType) {
    this.curveType = {
      name: curve
    };
  }

  this.curve = new elliptic.ec(this.curveType.name); // eslint-disable-line new-cap

  this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair();
  return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8';

  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc);
  }

  var otherPub = this.curve.keyFromPublic(other).getPublic();
  var out = otherPub.mul(this.keys.getPrivate()).getX();
  return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true);

  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7;
    } else {
      key[0] = 6;
    }
  }

  return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }

  this.keys._importPublic(pub);

  return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8';

  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }

  var _priv = new BN(priv);

  _priv = _priv.toString(16);
  this.keys = this.curve.genKeyPair();

  this.keys._importPrivate(_priv);

  return this;
};

function formatReturnValue(bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray();
  }

  var buf = new Buffer(bn);

  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length);
    zeros.fill(0);
    buf = Buffer.concat([zeros, buf]);
  }

  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17).Buffer))

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(165);
exports.privateDecrypt = __webpack_require__(169);

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(140);

var randomBytes = __webpack_require__(14);

var createHash = __webpack_require__(21);

var mgf = __webpack_require__(166);

var xor = __webpack_require__(167);

var BN = __webpack_require__(99);

var withPublic = __webpack_require__(168);

var crt = __webpack_require__(109);

var Buffer = __webpack_require__(16).Buffer;

module.exports = function publicEncrypt(publicKey, msg, reverse) {
  var padding;

  if (publicKey.padding) {
    padding = publicKey.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }

  var key = parseKeys(publicKey);
  var paddedMsg;

  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new BN(msg);

    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }

  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg) {
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;

  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }

  var ps = Buffer.alloc(k - mLen - hLen2 - 2);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));
}

function pkcs1(key, msg, reverse) {
  var mLen = msg.length;
  var k = key.modulus.byteLength();

  if (mLen > k - 11) {
    throw new Error('message too long');
  }

  var ps;

  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }

  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));
}

function nonZero(len) {
  var out = Buffer.allocUnsafe(len);
  var i = 0;
  var cache = randomBytes(len * 2);
  var cur = 0;
  var num;

  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2);
      cur = 0;
    }

    num = cache[cur++];

    if (num) {
      out[i++] = num;
    }
  }

  return out;
}

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(21);

var Buffer = __webpack_require__(16).Buffer;

module.exports = function (seed, len) {
  var t = Buffer.alloc(0);
  var i = 0;
  var c;

  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }

  return t.slice(0, len);
};

function i2ops(c) {
  var out = Buffer.allocUnsafe(4);
  out.writeUInt32BE(c, 0);
  return out;
}

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;

  while (++i < len) {
    a[i] ^= b[i];
  }

  return a;
};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(99);

var Buffer = __webpack_require__(16).Buffer;

function withPublic(paddedMsg, key) {
  return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}

module.exports = withPublic;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(140);

var mgf = __webpack_require__(166);

var xor = __webpack_require__(167);

var BN = __webpack_require__(99);

var crt = __webpack_require__(109);

var createHash = __webpack_require__(21);

var withPublic = __webpack_require__(168);

var Buffer = __webpack_require__(16).Buffer;

module.exports = function privateDecrypt(privateKey, enc, reverse) {
  var padding;

  if (privateKey.padding) {
    padding = privateKey.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }

  var key = parseKeys(privateKey);
  var k = key.modulus.byteLength();

  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }

  var msg;

  if (reverse) {
    msg = withPublic(new BN(enc), key);
  } else {
    msg = crt(enc, key);
  }

  var zBuffer = Buffer.alloc(k - msg.length);
  msg = Buffer.concat([zBuffer, msg], k);

  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg) {
  var k = key.modulus.byteLength();
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
  var hLen = iHash.length;

  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }

  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb = msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));

  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }

  var i = hLen;

  while (db[i] === 0) {
    i++;
  }

  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }

  return db.slice(i);
}

function pkcs1(key, msg, reverse) {
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;

  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }

  var ps = msg.slice(2, i - 1);

  if (p1.toString('hex') !== '0002' && !reverse || p1.toString('hex') !== '0001' && reverse) {
    status++;
  }

  if (ps.length < 8) {
    status++;
  }

  if (status) {
    throw new Error('decryption error');
  }

  return msg.slice(i);
}

function compare(a, b) {
  a = Buffer.from(a);
  b = Buffer.from(b);
  var dif = 0;
  var len = a.length;

  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }

  var i = -1;

  while (++i < len) {
    dif += a[i] ^ b[i];
  }

  return dif;
}

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser() {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11');
}

var safeBuffer = __webpack_require__(16);

var randombytes = __webpack_require__(14);

var Buffer = safeBuffer.Buffer;
var kBufferMaxLength = safeBuffer.kMaxLength;
var crypto = global.crypto || global.msCrypto;
var kMaxUint32 = Math.pow(2, 32) - 1;

function assertOffset(offset, length) {
  if (typeof offset !== 'number' || offset !== offset) {
    // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number');
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32');
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range');
  }
}

function assertSize(size, offset, length) {
  if (typeof size !== 'number' || size !== size) {
    // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number');
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32');
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small');
  }
}

if (crypto && crypto.getRandomValues || !process.browser) {
  exports.randomFill = randomFill;
  exports.randomFillSync = randomFillSync;
} else {
  exports.randomFill = oldBrowser;
  exports.randomFillSync = oldBrowser;
}

function randomFill(buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }

  if (typeof offset === 'function') {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === 'function') {
    cb = size;
    size = buf.length - offset;
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function');
  }

  assertOffset(offset, buf.length);
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size, cb);
}

function actualFill(buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer;
    var uint = new Uint8Array(ourBuf, offset, size);
    crypto.getRandomValues(uint);

    if (cb) {
      process.nextTick(function () {
        cb(null, buf);
      });
      return;
    }

    return buf;
  }

  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err);
      }

      bytes.copy(buf, offset);
      cb(null, buf);
    });
    return;
  }

  var bytes = randombytes(size);
  bytes.copy(buf, offset);
  return buf;
}

function randomFillSync(buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0;
  }

  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }

  assertOffset(offset, buf.length);
  if (size === undefined) size = buf.length - offset;
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(10)))

/***/ }),
/* 171 */,
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var ContentSchema = __webpack_require__(173);

var FieldSchema = __webpack_require__(175);

var RequestHelper = __webpack_require__(3);

var SchemaHelperCommon = __webpack_require__(176);
/**
 * The client side Schema helper
 *
 * @memberof HashBrown.Client.Helpers
 */


var SchemaHelper =
/*#__PURE__*/
function (_SchemaHelperCommon) {
  _inheritsLoose(SchemaHelper, _SchemaHelperCommon);

  function SchemaHelper() {
    return _SchemaHelperCommon.apply(this, arguments) || this;
  }

  /**
   * Gets a Schema with all parent fields
   *
   * @param {String} id
   *
   * @returns {Promise} Schema with parent fields
   */
  SchemaHelper.getSchemaWithParentFields = function getSchemaWithParentFields(id) {
    if (!id) {
      return Promise.resolve(null);
    }

    return RequestHelper.request('get', 'schemas/' + id + '/?withParentFields=true').then(function (schema) {
      return Promise.resolve(SchemaHelper.getModel(schema));
    });
  };
  /**
   * Gets a FieldSchema with all parent configs
   *
   * @param {String} id
   *
   * @returns {FieldSchema} Compiled FieldSchema
   */


  SchemaHelper.getFieldSchemaWithParentConfigs = function getFieldSchemaWithParentConfigs(id) {
    var fieldSchema = this.getSchemaByIdSync(id);

    if (fieldSchema) {
      var nextSchema = this.getSchemaByIdSync(fieldSchema.parentSchemaId);
      var compiledSchema = new FieldSchema(fieldSchema.getObject());

      while (nextSchema) {
        compiledSchema.appendConfig(nextSchema.config);
        nextSchema = this.getSchemaByIdSync(nextSchema.parentSchemaId);
      }

      return compiledSchema;
    }
  };
  /**
   * Gets a Schema by id
   *
   * @param {String} id
   *
   * @return {Promise} Promise
   */


  SchemaHelper.getSchemaById = function getSchemaById(id) {
    var _this = this;

    return RequestHelper.request('get', 'schemas/' + id).then(function (schema) {
      return Promise.resolve(_this.getModel(schema));
    });
  };
  /**
   * Gets all Schemas by type (sync)
   *
   * @param {String} type
   *
   * @returns {Array} All Schemas
   */


  SchemaHelper.getAllSchemasSync = function getAllSchemasSync(type) {
    if (!type) {
      return resources.schemas;
    }

    return resources.schemas.filter(function (schema) {
      if (schema.id == type + 'Base') {
        return false;
      }

      return schema.type === type;
    });
  };
  /**
   * Gets a Schema by id (sync)
   *
   * @param {String} id
   *
   * @return {Promise} Promise
   */


  SchemaHelper.getSchemaByIdSync = function getSchemaByIdSync(id) {
    for (var i in resources.schemas) {
      var schema = resources.schemas[i];

      if (schema.id == id) {
        if (schema instanceof ContentSchema || schema instanceof FieldSchema) {
          return schema;
        }

        return this.getModel(schema);
      }
    }
  };

  return SchemaHelper;
}(SchemaHelperCommon);

module.exports = SchemaHelper;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Schema = __webpack_require__(174);
/**
 * Schema for content nodes
 *
 * @memberof HashBrown.Common.Models
 */


var ContentSchema =
/*#__PURE__*/
function (_Schema) {
  _inheritsLoose(ContentSchema, _Schema);

  function ContentSchema(properties) {
    return _Schema.call(this, ContentSchema.paramsCheck(properties)) || this;
  }

  var _proto = ContentSchema.prototype;

  _proto.structure = function structure() {
    _Schema.prototype.structure.call(this);

    this.def(String, 'defaultTabId');
    this.def(Object, 'tabs', {});
    this.def(Object, 'fields', {
      properties: {}
    });
    this.def(Array, 'allowedChildSchemas', []);
    this.name = 'New content schema';
    this.type = 'content';
  };
  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */


  ContentSchema.paramsCheck = function paramsCheck(params) {
    if (!params.fields) {
      params.fields = {};
    }

    if (!params.fields.properties) {
      params.fields.properties = {};
    }

    return _Schema.paramsCheck.call(this, params);
  };
  /**
   * Checks whether a tab is the default one
   *
   * @param {String} tabId
   *
   * @returns {Boolean} Is the tab default
   */


  _proto.isDefaultTab = function isDefaultTab(tabId) {
    return !this.defaultTabId && tabId === 'meta' || this.defaultTabId === tabId;
  };

  return ContentSchema;
}(Schema);

module.exports = ContentSchema;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Resource = __webpack_require__(11);
/**
 * The base class for all Schema types
 *
 * @memberof HashBrown.Common.Models
 */


var Schema =
/*#__PURE__*/
function (_Resource) {
  _inheritsLoose(Schema, _Resource);

  function Schema() {
    return _Resource.apply(this, arguments) || this;
  }

  var _proto = Schema.prototype;

  /**
   * Structure
   */
  _proto.structure = function structure() {
    this.def(String, 'id');
    this.def(String, 'name');
    this.def(String, 'icon');
    this.def(String, 'parentSchemaId');
    this.def(Boolean, 'isLocked'); // Sync

    this.def(Object, 'sync');
    this.def(Array, 'hiddenProperties', []);
  };
  /**
   * Checks whether a property is hidden
   *
   * @param {String} name
   *
   * @returns {Boolean} Is hidden
   */


  _proto.isPropertyHidden = function isPropertyHidden(name) {
    return this.hiddenProperties.indexOf(name) > -1;
  };
  /**
   * Creates a new schema
   *
   * @param {Schema} parentSchema
   *
   * @returns {Schema} schema
   */


  Schema.create = function create(parentSchema) {
    checkParam(parentSchema, 'parentSchema', HashBrown.Models.Schema);
    return HashBrown.Helpers.SchemaHelper.getModel({
      id: Schema.createId(),
      icon: parentSchema.icon || 'file',
      type: parentSchema.type,
      editorId: parentSchema.editorId,
      parentSchemaId: parentSchema.id
    });
  };

  return Schema;
}(Resource);

module.exports = Schema;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Schema = __webpack_require__(174);
/**
 * Schema for content fields
 *
 * @memberof HashBrown.Common.Models
 */


var FieldSchema =
/*#__PURE__*/
function (_Schema) {
  _inheritsLoose(FieldSchema, _Schema);

  function FieldSchema() {
    return _Schema.apply(this, arguments) || this;
  }

  var _proto = FieldSchema.prototype;

  /**
   * Structure
   */
  _proto.structure = function structure() {
    _Schema.prototype.structure.call(this);

    this.def(String, 'editorId');
    this.def(Object, 'config', {});
    this.name = 'New field schema';
    this.type = 'field';
  };
  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */


  FieldSchema.paramsCheck = function paramsCheck(params) {
    params = _Schema.paramsCheck.call(this, params); // Backwards compatible editor names

    if (params.editorId && params.editorId.indexOf('Editor') < 0) {
      params.editorId = params.editorId[0].toUpperCase() + params.editorId.substring(1) + 'Editor';
    }

    return params;
  };
  /**
   * Appends properties to this config
   *
   * @param {Object} config
   */


  _proto.appendConfig = function appendConfig(config) {
    function recurse(source, target) {
      for (var k in source) {
        // If key doesn't exist, append immediately
        if (!target[k]) {
          target[k] = source[k];
        } else if (target[k] instanceof Object && source[k] instanceof Object || target[k] instanceof Array && source[k] instanceof Array) {
          recurse(source[k], target[k]);
        }
      }
    }

    recurse(config, this.config);
  };

  return FieldSchema;
}(Schema);

module.exports = FieldSchema;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The common base for SchemaHelper
 *
 * @memberof HashBrown.Common.Helpers
 */

var SchemaHelper =
/*#__PURE__*/
function () {
  function SchemaHelper() {}

  /**
   * Gets all parent fields
   *
   * @param {String} id
   *
   * @returns {Promise(Schema)} schema
   */
  SchemaHelper.getSchemaWithParentFields = function getSchemaWithParentFields(id) {
    return new Promise(function (callback) {
      callback();
    });
  };
  /**
   * Gets the appropriate model
   *
   * @param {Object} properties
   *
   * @return {Schema} Schema
   */


  SchemaHelper.getModel = function getModel(properties) {
    if (!properties) {
      return null;
    } // If the properties object is already a recognised model, return it


    if (properties instanceof HashBrown.Models.ContentSchema || properties instanceof HashBrown.Models.FieldSchema) {
      return properties;
    } // If the properties object is using an unrecognised model, serialise it


    if (typeof properties.getObject === 'function') {
      properties = properties.getObject();
    }

    if (properties.type === 'content') {
      return new HashBrown.Models.ContentSchema(properties);
    } else if (properties.type === 'field') {
      return new HashBrown.Models.FieldSchema(properties);
    }

    throw new Error('Schema data is incorrectly formatted: ' + JSON.stringify(properties));
  };
  /**
   * Merges two Schemas
   *
   * @param Schema childSchema
   * @param Schema parentSchema
   *
   * @returns {Schema} Merged Schema
   */


  SchemaHelper.mergeSchemas = function mergeSchemas(childSchema, parentSchema) {
    checkParam(childSchema, 'childSchema', HashBrown.Models.Schema);
    checkParam(parentSchema, 'parentSchema', HashBrown.Models.Schema);
    childSchema = childSchema.getObject();
    parentSchema = parentSchema.getObject();
    var mergedSchema = parentSchema; // Recursive merge

    function merge(parentValues, childValues) {
      for (var k in childValues) {
        if (typeof parentValues[k] === 'object' && typeof childValues[k] === 'object') {
          merge(parentValues[k], childValues[k]);
        } else if (childValues[k]) {
          parentValues[k] = childValues[k];
        }
      }
    } // Overwrite native values 


    mergedSchema.id = childSchema.id;
    mergedSchema.name = childSchema.name;
    mergedSchema.parentSchemaId = childSchema.parentSchemaId;
    mergedSchema.icon = childSchema.icon || mergedSchema.icon; // Specific values for schema types

    switch (mergedSchema.type) {
      case 'field':
        mergedSchema.editorId = mergedSchema.editorId || parentSchema.editorId; // Merge config

        if (!mergedSchema.config) {
          mergedSchema.config = {};
        }

        if (!parentSchema.config) {
          parentSchema.config = {};
        }

        merge(mergedSchema.config, childSchema.config);
        break;

      case 'content':
        // Merge tabs
        if (!mergedSchema.tabs) {
          mergedSchema.tabs = {};
        }

        if (!childSchema.tabs) {
          childSchema.tabs = {};
        }

        merge(mergedSchema.tabs, childSchema.tabs); // Merge fields

        if (!mergedSchema.fields) {
          mergedSchema.fields = {};
        }

        if (!mergedSchema.fields.properties) {
          mergedSchema.fields.properties = {};
        }

        if (!childSchema.fields) {
          childSchema.fields = {};
        }

        if (!childSchema.fields.properties) {
          childSchema.fields.properties = {};
        }

        merge(mergedSchema.fields, childSchema.fields); // Set default tab id

        mergedSchema.defaultTabId = childSchema.defaultTabId || mergedSchema.defaultTabId;
        break;
    }

    return this.getModel(mergedSchema);
  };

  return SchemaHelper;
}();

module.exports = SchemaHelper;

/***/ }),
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var base;

if (typeof window !== 'undefined') {
  base = window;
} else if (typeof global !== 'undefined') {
  base = global;
}

if (!base) {
  throw new Error('Base not found');
}
/**
 * Throws an error if parameter was null (used as a default param hack)
 *
 * @param {String} name
 */


base.requiredParam = function (name) {
  throw new Error('Parameter "' + name + '" is required');
};
/**
 * Checks a parameter for type
 *
 * @param {Anything} value
 * @param {String} name
 * @param {Type} type
 */


base.checkParam = function (value, name, type) {
  if (value === undefined) {
    throw new Error('Parameter "' + name + '" is required');
  }

  if (value === null) {
    return;
  }

  if (value.constructor === type) {
    return;
  }

  if (value.prototype instanceof type) {
    return;
  }

  if (value instanceof type) {
    return;
  }

  if (value === type) {
    return;
  }

  var valueTypeName = typeof value;

  if (value.constructor) {
    valueTypeName = value.constructor.name;
  } else if (value.prototype) {
    valueTypename = value.prototype.name;
  }

  throw new TypeError('Parameter "' + name + '" is of type "' + valueTypeName + '", should be "' + type.name + '". Value was: ' + (valueTypeName === 'Object' ? JSON.stringify(value) : value.toString()));
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @namespace HashBrown.Client.Models
 */

module.exports = {
  Content: __webpack_require__(188),
  Connection: __webpack_require__(190),
  ContentSchema: __webpack_require__(173),
  Deployer: __webpack_require__(193),
  Entity: __webpack_require__(12),
  FieldSchema: __webpack_require__(175),
  Form: __webpack_require__(194),
  Media: __webpack_require__(8),
  Processor: __webpack_require__(192),
  Project: __webpack_require__(195),
  Schema: __webpack_require__(174),
  Template: __webpack_require__(196),
  User: __webpack_require__(197)
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var ContentCommon = __webpack_require__(189);

var ProjectHelper = __webpack_require__(7);
/**
 * The client-side content model
 *
 * @memberof HashBrown.Client.Models
 */


var Content =
/*#__PURE__*/
function (_ContentCommon) {
  _inheritsLoose(Content, _ContentCommon);

  function Content() {
    return _ContentCommon.apply(this, arguments) || this;
  }

  var _proto = Content.prototype;

  /**
   * Gets settings
   *
   * @param {String} key
   *
   * @returns {Object} Settings
   */
  _proto.getSettings = function getSettings(key) {
    var parentContent = this.getParent(); // Loop through parents to find governing setting

    while (parentContent != null) {
      parentContent.settingsSanityCheck(key); // We found a governing parent, return those settings

      if (parentContent.settings[key].applyToChildren) {
        var settings = parentContent.settings; // Make clone as to avoid interference with inherent values

        settings = JSON.parse(JSON.stringify(settings));
        settings[key].governedBy = parentContent.id;
        return settings[key];
      }

      parentContent = parentContent.getParent();
    }

    this.settingsSanityCheck(key);
    return this.settings[key];
  };
  /**
   * Gets parent Content
   *
   * @returns {Content} Parent
   */


  _proto.getParent = function getParent() {
    return HashBrown.Helpers.ContentHelper.getContentByIdSync(this.parentId);
  };

  return Content;
}(ContentCommon);

module.exports = Content;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Resource = __webpack_require__(11);
/**
 * The base class for all Content types
 *
 * @memberof HashBrown.Common.Models
 */


var Content =
/*#__PURE__*/
function (_Resource) {
  _inheritsLoose(Content, _Resource);

  function Content() {
    return _Resource.apply(this, arguments) || this;
  }

  var _proto = Content.prototype;

  _proto.structure = function structure() {
    // Fundamental fields
    this.def(String, 'id');
    this.def(String, 'parentId');
    this.def(String, 'createdBy');
    this.def(String, 'updatedBy');
    this.def(Date, 'createDate');
    this.def(Date, 'updateDate');
    this.def(String, 'schemaId');
    this.def(Number, 'sort', -1);
    this.def(Boolean, 'isLocked'); // Publishing

    this.def(Date, 'publishOn');
    this.def(Date, 'unpublishOn');
    this.def(Boolean, 'isPublished');
    this.def(Boolean, 'hasPreview'); // Sync

    this.def(Object, 'sync'); // Extensible properties

    this.def(Object, 'properties', {}); // Settings

    this.def(Object, 'settings', {
      publishing: {
        connectionId: ''
      }
    });
  };
  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */


  Content.paramsCheck = function paramsCheck(params) {
    params = _Resource.paramsCheck.call(this, params); // Ensure correct type for dates

    function parseDate(input) {
      var result;

      if (typeof input === 'string' && !isNaN(input)) {
        result = new Date(parseInt(input));
      } else {
        result = new Date(input);
      }

      return result;
    }

    params.createDate = parseDate(params.createDate);
    params.updateDate = parseDate(params.updateDate);
    return params;
  };
  /**
   * Creates a new Content object
   *
   * @param {String} schemaId
   * @param {Object} properties
   *
   * @returns {Content} New Content object
   */


  Content.create = function create(schemaId, properties) {
    if (typeof schemaId !== 'string') {
      throw new Error('Schema ID was not provided');
    }

    var defaultProperties = {
      title: 'New content'
    };
    var content = new Content({
      id: Content.createId(),
      createDate: new Date(),
      updateDate: new Date(),
      schemaId: schemaId,
      properties: properties || defaultProperties
    });
    return content;
  };
  /**
   * Adopts a list of tasks, turning them into un/publish dates
   *
   * @param {Array} tasks
   */


  _proto.adoptTasks = function adoptTasks(tasks) {
    if (!tasks) {
      return;
    }

    for (var i in tasks) {
      switch (tasks[i].type) {
        case 'publish':
          this.publishOn = tasks[i].date;
          break;

        case 'unpublish':
          this.unpublishOn = tasks[i].date;
          break;
      }
    }
  };
  /**
   * Gets parent Content
   *
   * @param {String} project
   * @param {String} environment
   *
   * @returns {Promise} Parent
   */


  _proto.getParent = function getParent(project, environment) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);

    if (!this.parentId) {
      return Promise.resolve(null);
    }

    return HashBrown.Helpers.ContentHelper.getContentById(project, environment, this.parentId).then(function (parentContent) {
      return Promise.resolve(parentContent);
    }).catch(function (e) {
      return Promise.resolve(null);
    });
  };
  /**
   * Gets all parents
   *
   * @param {String} project
   * @param {String} environment
   *
   * @returns {Promise} parents
   */


  _proto.getParents = function getParents(project, environment) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    var parents = [];

    var getNextParent = function getNextParent(content) {
      return content.getParent(project, environment).then(function (parentContent) {
        if (parentContent) {
          parents.push(parentContent);
          return getNextParent(parentContent);
        } else {
          return Promise.resolve(parents);
        }
      });
    };

    return getNextParent(this);
  };
  /**
   * Settings sanity check
   *
   * @param {String} key
   */


  _proto.settingsSanityCheck = function settingsSanityCheck(key) {
    this.settings = this.settings || {};

    if (key) {
      this.settings[key] = this.settings[key] || {};
    }

    this.settings.publishing = this.settings.publishing || {};

    if (Array.isArray(this.settings.publishing.connections)) {
      this.settings.publishing.connectionId = this.settings.publishing.connections[0];
      delete this.settings.publishing.connections;
    }
  };
  /**
   * Gets settings
   *
   * @param {String} key
   *
   * @returns {Promise} Settings
   */


  _proto.getSettings = function getSettings(key) {
    return Promise.resolve({});
  };
  /**
   * Gets all meta fields
   *
   * @returns {Object} Meta
   */


  _proto.getMeta = function getMeta() {
    return {
      id: this.id,
      parentId: this.parentId,
      createDate: this.createDate,
      updateDate: this.updateDate,
      createdBy: this.createdBy,
      updatedBy: this.updatedBy
    };
  };
  /**
   * Shorthand to get property value
   *
   * @param {String} key
   * @param {String} language
   *
   * @returns {Object} value
   */


  _proto.prop = function prop(key, language) {
    return this.getPropertyValue(key, language);
  };
  /**
   * Gets a property value
   *
   * @param {String} key
   * @param {String} language
   *
   * @returns {Object} value
   */


  _proto.getPropertyValue = function getPropertyValue(key, language) {
    if (!this.properties) {
      this.properties = {};
    }

    if (language && typeof this.properties[key] === 'object') {
      return this.properties[key][language];
    } else {
      return this.properties[key];
    }
  };
  /**
   * Sets a property value
   *
   * @param {String} key
   * @param {String|Number|Object} value
   * @param {String} language
   */


  _proto.setPropertyValue = function setPropertyValue(key, value, language) {
    if (!this.properties) {
      this.properties = {};
    }

    if (language && typeof this.properties[key] === 'object') {
      this.properties[key][language] = value;
    } else {
      this.properties[key] = value;
    }
  };
  /**
   * Returns all properties in a given language
   *
   * @param {String} language
   *
   * @returns {Object} properties
   */


  _proto.getLocalizedProperties = function getLocalizedProperties(language) {
    // Create references
    // NOTE: We're cloning the "properties" value to avoid destroying the structure
    var localizedProperties = {};
    var allProperties = JSON.parse(JSON.stringify(this.properties)); // Flatten properties recursively

    function flattenRecursively(source, target) {
      // Loop through all keys
      for (var key in source) {
        var value = source[key]; // If the value is an object type, examine it further

        if (value && typeof value === 'object') {
          // If multilingual flag is set, assign value directly
          if (value._multilingual) {
            if (typeof value[language] === 'undefined') {
              value[language] = null;
            }

            target[key] = value[language]; // If not, recurse into the object
          } else {
            // If this value was created with the ArrayEditor, filter out Schema ids
            // by assigning the "value" of each item directly to the array
            if (Array.isArray(value)) {
              for (var i in value) {
                if (!value[i].value) {
                  continue;
                }

                value[i] = value[i].value;
              }
            } // Prepare target data type for either Object or Array


            if (Array.isArray(value)) {
              target[key] = [];
            } else {
              target[key] = {};
            }

            flattenRecursively(value, target[key]);
          } // If not, just return the localised value

        } else {
          target[key] = value;
        }
      }
    }

    flattenRecursively(allProperties, localizedProperties);
    return localizedProperties;
  };
  /**
   * Gets the content type
   *
   * @returns {String} type
   */


  _proto.getType = function getType() {
    return this.constructor.name;
  };
  /**
   * Gets the schema information
   *
   * @returns {Promise} Schema
   */


  _proto.getSchema = function getSchema() {
    return Promise.resolve();
  };

  return Content;
}(Resource);

module.exports = Content;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var ConnectionCommon = __webpack_require__(191);
/**
 * The client side Connection class
 *
 * @memberof HashBrown.Client.Models
 */


var Connection =
/*#__PURE__*/
function (_ConnectionCommon) {
  _inheritsLoose(Connection, _ConnectionCommon);

  function Connection() {
    return _ConnectionCommon.apply(this, arguments) || this;
  }

  var _proto = Connection.prototype;

  /**
   * Structure
   */
  _proto.structure = function structure() {
    _ConnectionCommon.prototype.structure.call(this);

    this.def(Object, 'processor', {});
    this.def(Object, 'deployer', {});
  };

  return Connection;
}(ConnectionCommon);

module.exports = Connection;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Path = __webpack_require__(9);

var Processor = __webpack_require__(192);

var Deployer = __webpack_require__(193);

var Resource = __webpack_require__(11);
/**
 * The Connection class
 *
 * @memberof HashBrown.Common.Models
 */


var Connection =
/*#__PURE__*/
function (_Resource) {
  _inheritsLoose(Connection, _Resource);

  function Connection() {
    return _Resource.apply(this, arguments) || this;
  }

  var _proto = Connection.prototype;

  /**
   * Structure
   */
  _proto.structure = function structure() {
    this.def(String, 'id');
    this.def(String, 'title');
    this.def(String, 'url');
    this.def(Boolean, 'isLocked'); // Sync

    this.def(Object, 'sync');
  };
  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */


  Connection.paramsCheck = function paramsCheck(params) {
    // Backwards compatibility: Convert from old structure
    if (params.type || params.preset) {
      params.settings = params.settings || {};
      params.settings.url = params.settings.url || params.url;
      var newParams = this.getPresetSettings(params.type || params.preset, params.settings);
      newParams.id = params.id;
      newParams.title = params.title;
      newParams.url = params.url;
      newParams.isLocked = params.isLocked;
      newParams.sync = params.sync;
      params = newParams;
    } // Deployer and processor


    if (!params.processor) {
      params.processor = {};
    }

    if (!params.deployer) {
      params.deployer = {};
    }

    if (!params.deployer.paths) {
      params.deployer.paths = {};
    }

    if (!params.deployer.paths.templates) {
      params.deployer.paths.templates = {};
    }

    return _Resource.paramsCheck.call(this, params);
  };
  /**
   * Gets preset settings
   *
   * @param {String} preset
   * @param {Object} oldSettings
   */


  Connection.getPresetSettings = function getPresetSettings(preset, oldSettings) {
    oldSettings = oldSettings || {};
    var settings;

    switch (preset) {
      case 'GitHub Pages':
        settings = {
          processor: {
            alias: 'jekyll',
            fileExtension: '.md'
          },
          deployer: oldSettings.isLocal ? {
            alias: 'filesystem',
            rootPath: oldSettings.localPath,
            paths: {
              templates: {
                partial: '/_includes/partials/',
                page: '/_layouts/'
              },
              content: '/content/',
              media: '/media/'
            }
          } : {
            alias: 'github',
            token: oldSettings.token || '',
            org: oldSettings.org || '',
            repo: oldSettings.repo || '',
            branch: oldSettings.branch || '',
            paths: {
              templates: {
                partial: '/_includes/partials/',
                page: '/_layouts/'
              },
              content: '/content/',
              media: '/media/'
            }
          }
        };
        break;

      case 'HashBrown Driver':
        settings = {
          processor: {
            alias: 'json',
            fileExtension: ''
          },
          deployer: {
            alias: 'api',
            url: (oldSettings.url || 'https://example.com') + '/api/',
            token: oldSettings.token || '',
            paths: {
              templates: {
                partial: '/templates/partial/',
                page: '/templates/page/'
              },
              content: '/content/',
              media: '/media/'
            }
          }
        };
        break;
    }

    return settings;
  };
  /**
   * Creates a new Connection object
   *
   * @return {Connection} connection
   */


  Connection.create = function create() {
    return new Connection({
      id: Connection.createId(),
      title: 'New connection'
    });
  };
  /**
   * Gets the remote URL
   *
   * @param {Boolean} withSlash
   *
   * @returns {String} URL
   */


  _proto.getRemoteUrl = function getRemoteUrl(withSlash) {
    if (withSlash === void 0) {
      withSlash = false;
    }

    var url = this.url;

    if (!withSlash && url[url.length - 1] == '/') {
      url = url.substring(0, url.length - 1);
    } else if (withSlash && url[url.length - 1] != '/') {
      url += '/';
    }

    return url;
  };

  return Connection;
}(Resource);

module.exports = Connection;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Entity = __webpack_require__(12);
/**
 * A class for processing Content before it is deployed
 *
 * @memberof HashBrown.Common.Models
 */


var Processor =
/*#__PURE__*/
function (_Entity) {
  _inheritsLoose(Processor, _Entity);

  _createClass(Processor, null, [{
    key: "name",
    // Getter: Display name of this Processor
    get: function get() {
      return 'Processor';
    } // Getter: Alias of this Processor (used to link with the client-side editor)

  }, {
    key: "alias",
    get: function get() {
      return 'processor';
    }
    /**
     * Constructor
     */

  }]);

  function Processor(params) {
    var _this;

    _this = _Entity.call(this, params) || this;
    _this.name = _this.constructor.name;
    _this.alias = _this.constructor.alias;
    return _this;
  }
  /**
   * Structure
   */


  var _proto = Processor.prototype;

  _proto.structure = function structure() {
    this.def(String, 'name');
    this.def(String, 'alias');
    this.def(String, 'fileExtension');
  };
  /**
   * Processes a Content node
   *
   * @param {Content} content
   *
   * @returns {Object} Output
   */


  _proto.process = function process(content) {
    return null;
  };

  return Processor;
}(Entity);

module.exports = Processor;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Entity = __webpack_require__(12);
/**
 * A class for deploying and retrieving data to and from a server
 *
 * @memberof HashBrown.Common.Models
 */


var Deployer =
/*#__PURE__*/
function (_Entity) {
  _inheritsLoose(Deployer, _Entity);

  _createClass(Deployer, null, [{
    key: "name",
    // Name and alias
    get: function get() {
      return 'Deployer';
    }
  }, {
    key: "alias",
    get: function get() {
      return 'deployer';
    }
    /**
     * Constructor
     */

  }]);

  function Deployer(params) {
    var _this;

    _this = _Entity.call(this, params) || this;
    _this.name = _this.constructor.name;
    _this.alias = _this.constructor.alias;

    if (!_this.paths) {
      _this.paths = {};
    }

    if (!_this.paths.templates) {
      _this.paths.templates = {};
    }

    return _this;
  }
  /**
   * Structure
   */


  var _proto = Deployer.prototype;

  _proto.structure = function structure() {
    this.def(String, 'name');
    this.def(String, 'alias');
    this.def(Object, 'paths', {
      templates: {
        page: '',
        partial: ''
      },
      media: '',
      content: ''
    });
  };
  /**
   * Gets the root path
   *
   * @returns {String} Root
   */


  _proto.getRootPath = function getRootPath() {
    throw new Error('The method "getRootPath" must be overridden');
  };
  /**
   * Gets a deployment path
   *
   * @param {String} query
   * @param {String} filename
   *
   * @returns {String} Path
   */


  _proto.getPath = function getPath(query, filename) {
    // The "query" variable is a syntax for getting the paths defined in the config
    var lvl1 = query ? query.split('/')[0] : null;
    var lvl2 = query ? query.split('/')[1] : null; // Start with the root path

    var path = this.getRootPath(); // Add slash if needed

    if (path.lastIndexOf('/') !== path.length - 1) {
      path += '/';
    } // Add level 2 path if it exists


    if (lvl1 && lvl2 && this.paths[lvl1][lvl2] && typeof this.paths[lvl1][lvl2] === 'string') {
      path += this.paths[lvl1][lvl2];
    } // Add level 1 path if it exists
    else if (lvl1 && this.paths[lvl1] && typeof this.paths[lvl1] === 'string') {
        path += this.paths[lvl1];
      } // Add slash if needed


    if (path.lastIndexOf('/') !== path.length - 1) {
      path += '/';
    } // Add filename if needed


    if (filename) {
      path += filename;
    } // Remove any unwanted double slashes


    path = path.replace(/\/\//g, '/'); // Add back double slashes for protocols

    path = path.replace(':/', '://');
    return path;
  };
  /**
   * Tests this deployment
   *
   * @returns {Promise} Result
   */


  _proto.test = function test() {
    return Promise.reject(new Error('The "test" method should be overridden.'));
  };
  /**
   * Sets a file
   *
   * @param {String} path
   * @param {String} base64
   *
   * @returns {Promise} Result
   */


  _proto.setFile = function setFile(path, content) {
    return Promise.reject(new Error('The "setFile" method should be overridden.'));
  };
  /**
   * Gets a file
   *
   * @param {String} path
   *
   * @returns {Promise} File
   */


  _proto.getFile = function getFile(path) {
    return Promise.reject(new Error('The "getFile" method should be overridden.'));
  };
  /**
   * Removes a file
   *
   * @param {String} path
   *
   * @returns {Promise} Result
   */


  _proto.removeFile = function removeFile(path) {
    return Promise.reject(new Error('The "removeFile" method should be overridden.'));
  };
  /**
   * Gets a list of files
   *
   * @param {String} path
   *
   * @returns {Promise} Files
   */


  _proto.getFolder = function getFolder(path) {
    return Promise.reject(new Error('The "getFolder" method should be overridden.'));
  };
  /**
   * Removes a folder
   *
   * @param {String} path
   *
   * @returns {Promise} Result
   */


  _proto.removeFolder = function removeFolder(path) {
    return Promise.reject(new Error('The "removeFolder" method should be overridden.'));
  };

  return Deployer;
}(Entity);

module.exports = Deployer;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Resource = __webpack_require__(11);
/**
 * The Form class
 *
 * @memberof HashBrown.Common.Models
 */


var Form =
/*#__PURE__*/
function (_Resource) {
  _inheritsLoose(Form, _Resource);

  function Form() {
    return _Resource.apply(this, arguments) || this;
  }

  var _proto = Form.prototype;

  /**
   * Structure
   */
  _proto.structure = function structure() {
    // Fundamental fields
    this.def(String, 'id');
    this.def(String, 'title');
    this.def(String, 'allowedOrigin');
    this.def(String, 'redirect');
    this.def(Boolean, 'appendRedirect');
    this.def(Boolean, 'isLocked'); // Sync

    this.def(Object, 'sync'); // Mutable fields

    this.def(Object, 'inputs', {});
    this.def(Array, 'entries', []);
  };
  /**
   * Creates a new Form object
   *
   * @return {Form} form
   */


  Form.create = function create() {
    var form = new Form({
      id: Form.createId(),
      title: 'New form',
      inputs: {},
      entries: []
    });
    return form;
  };
  /**
   * Clears all entries
   */


  _proto.clearAllEntries = function clearAllEntries() {
    this.entries = [];
  };
  /**
   * Adds an entry
   *
   * @param {Object} entry
   */


  _proto.addEntry = function addEntry(entry) {
    if (!entry) {
      return;
    }

    var filteredEntry = {};
    var duplicateChecks = {}; // Only accept values as defined by the "inputs" variable

    for (var k in this.inputs) {
      // Register fields to check for duplicates
      if (this.inputs[k].checkDuplicates) {
        duplicateChecks[k] = {};
      } // Apply regex pattern


      if (this.inputs[k].pattern) {
        var regexp = new RegExp(this.inputs[k].pattern);

        if (!regexp.test(entry[k])) {
          throw new Error('Field "' + k + '" is incorrectly formatted');
        }
      } // Check if a required field is missing


      if (this.inputs[k].required == true && !entry[k]) {
        throw new Error('Field "' + k + '" is required');
      }

      filteredEntry[k] = entry[k];
    } // Copy to new entries array to avoid changing original before duplicate check


    var newEntries = (this.entries || []).concat(); // Add timestamp

    filteredEntry.time = new Date().toISOString();
    newEntries.push(filteredEntry); // Look for duplicates

    for (var duplicateKey in duplicateChecks) {
      for (var _iterator = newEntries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _entry = _ref;

        // Does this entry have the field we're checking for?
        if (!_entry[duplicateKey]) {
          continue;
        } // Does this entry have a field value that already exists?


        if (duplicateChecks[duplicateKey][_entry[duplicateKey]]) {
          throw new Error('Field "' + duplicateKey + '" is a duplicate');
        }

        duplicateChecks[duplicateKey][_entry[duplicateKey]] = true;
      }
    } // Assign new entries array to original variable


    this.entries = newEntries;
  };

  return Form;
}(Resource);

module.exports = Form;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Entity = __webpack_require__(12);

var Connection = __webpack_require__(191);
/**
 * The Project class
 *
 * @memberof HashBrown.Common.Models
 */


var Project =
/*#__PURE__*/
function (_Entity) {
  _inheritsLoose(Project, _Entity);

  function Project(params) {
    return _Entity.call(this, Project.checkParams(params)) || this;
  }
  /**
   * Performs a sanity check of the params
   *
   * @param {Object} params
   *
   * @returns {Object} Params
   */


  Project.checkParams = function checkParams(params) {
    params = params || {};

    if (!params.id) {
      throw new Error('No id was provided for the Project constructor');
    }

    if (!params.settings) {
      params.settings = {};
    }

    if (!params.settings.info) {
      params.settings.info = {};
    }

    if (!params.settings.info.name) {
      params.settings.info.name = params.id;
    }

    if (!params.settings.languages) {
      params.settings.languages = ['en'];
    }

    if (!params.settings.sync) {
      params.settings.sync = {};
    } // Delete old flags


    delete params.useAutoBackup;
    delete params.backupStorage; // Restore from old languages structure

    if (!Array.isArray(params.settings.languages)) {
      var languages = [];

      for (var key in params.settings.languages) {
        if (key === 'section') {
          continue;
        }

        languages.push(params.settings.languages[key]);
      }

      params.settings.languages = languages;
    }

    return params;
  };
  /**
   * Defines the structure of this project
   */


  var _proto = Project.prototype;

  _proto.structure = function structure() {
    this.def(String, 'id');
    this.def(Array, 'users', []);
    this.def(Object, 'settings', {});
    this.def(Array, 'environments', []);
    this.def(Array, 'backups', []);
  };
  /**
   * Creates a database safe name
   *
   * @param {String} name
   *
   * @returns {String} Safe name
   */


  Project.safeName = function safeName(name) {
    return name.toLowerCase().replace('.', '_').replace(/[^a-z_]/g, '');
  };
  /**
   * Creates a new project
   *
   * @param {String} name
   *
   * @returns {Project} New Project
   */


  Project.create = function create(name) {
    var project = new Project({
      id: Entity.createId(10)
    });
    project.settings.usedBy = 'project';
    project.settings.info = {
      name: name
    };
    return project;
  };

  return Project;
}(Entity);

module.exports = Project;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Resource = __webpack_require__(11);
/**
 * The Template model
 *
 * @memberof HashBrown.Common.Models
 */


var Template =
/*#__PURE__*/
function (_Resource) {
  _inheritsLoose(Template, _Resource);

  function Template(params) {
    var _this;

    _this = _Resource.call(this, params) || this;

    _this.updateId();

    return _this;
  }
  /**
   * Checks the format of the params
   *
   * @params {Object} params
   *
   * @returns {Object} Params
   */


  Template.paramsCheck = function paramsCheck(params) {
    params = _Resource.paramsCheck.call(this, params);
    delete params.remote;
    delete params.sync;
    delete params.isRemote;
    return params;
  };
  /**
   * Structure
   */


  var _proto = Template.prototype;

  _proto.structure = function structure() {
    this.def(String, 'id');
    this.def(String, 'parentId');
    this.def(String, 'icon', 'code');
    this.def(String, 'name');
    this.def(String, 'type');
    this.def(String, 'remotePath');
    this.def(String, 'folder');
    this.def(String, 'markup');
  };
  /**
   * Updates id from name
   */


  _proto.updateId = function updateId() {
    this.id = this.name.substring(0, this.name.lastIndexOf('.'));
  };

  return Template;
}(Resource);

module.exports = Template;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Entity = __webpack_require__(12);
/**
 * A model for Users
 *
 * @memberof HashBrown.Common.Models
 */


var User =
/*#__PURE__*/
function (_Entity) {
  _inheritsLoose(User, _Entity);

  function User(params) {
    return _Entity.call(this, params) || this;
  }

  var _proto = User.prototype;

  _proto.structure = function structure() {
    this.def(String, 'id');
    this.def(Boolean, 'isAdmin', false);
    this.def(Boolean, 'isCurrent', false);
    this.def(String, 'username');
    this.def(String, 'fullName');
    this.def(String, 'email');
    this.def(Object, 'scopes', {});
  };
  /**
   * Gets all project scopes
   *
   * @param {String} project
   * @param {Boolean} upsert
   *
   * @returns {Array} scopes
   */


  _proto.getScopes = function getScopes(project, upsert) {
    if (!this.scopes) {
      this.scopes = {};
    }

    if (!this.scopes[project] && upsert) {
      this.scopes[project] = [];
    }

    return this.scopes[project];
  };
  /**
   * Checks if a user has a project scope
   *
   * @param {String} project
   * @param {String} scope
   *
   * @returns {Boolean} hasScope
   */


  _proto.hasScope = function hasScope(project, scope) {
    if (this.isAdmin) {
      return true;
    }

    if (!project) {
      return false;
    }

    if (!scope && !this.scopes[project]) {
      return false;
    }

    if (!Array.isArray(this.scopes[project])) {
      this.scopes[project] = [];
    }

    if (!scope) {
      return true;
    }

    return this.scopes[project].indexOf(scope) > -1;
  };
  /**
   * Removes a scope
   *
   * @param {String} project
   * @param {String|Boolean} scope
   */


  _proto.removeScope = function removeScope(project, scope) {
    if (!project) {
      return;
    }

    if (!this.scopes) {
      return;
    }

    if (!this.scopes[project]) {
      return;
    }

    if (scope) {
      var scopeIndex = this.scopes[project].indexOf(scope);
      this.scopes[project].splice(scopeIndex, 1);
    } else {
      delete this.scopes[project];
    }
  };
  /**
   * Grants a user a scope
   *
   * @param {String} project
   * @param {String} scope
   */


  _proto.giveScope = function giveScope(project, scope) {
    if (!project) {
      return;
    }

    if (!this.scopes) {
      this.scopes = {};
    }

    if (!this.scopes[project]) {
      this.scopes[project] = [];
    }

    if (!scope) {
      return;
    }

    if (this.scopes[project].indexOf(scope) > -1) {
      return;
    }

    this.scopes[project].push(scope);
  };

  return User;
}(Entity);

module.exports = User;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @namespace HashBrown.Client.Views.Widgets
 */

module.exports = {
  Dropdown: __webpack_require__(199),
  Chips: __webpack_require__(201),
  Input: __webpack_require__(202)
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Widget = __webpack_require__(200);
/**
 * A multi purpose dropdown
 *
 * @memberof HashBrown.Client.Views.Widgets
 */


var Dropdown =
/*#__PURE__*/
function (_Widget) {
  _inheritsLoose(Dropdown, _Widget);

  /**
   * Constructor
   */
  function Dropdown(params) {
    var _this;

    if (params.optionsUrl) {
      params.isAsync = true;
      HashBrown.Helpers.RequestHelper.request('get', params.optionsUrl).then(function (options) {
        _this.options = options;

        _this.fetch();
      });
    }

    _this = _Widget.call(this, params) || this;
    _this.optionIcons = {};
    return _this;
  }
  /**
   * Gets option icon
   *
   * @param {String} label
   *
   * @returns {String} Icon
   */


  var _proto = Dropdown.prototype;

  _proto.getOptionIcon = function getOptionIcon(label) {
    if (!this.iconKey || !this.labelKey || !this.options) {
      return '';
    }

    for (var key in this.options) {
      var value = this.options[key];
      var optionLabel = this.labelKey ? value[this.labelKey] : value;

      if (typeof optionLabel !== 'string') {
        optionLabel = optionLabel ? optionLabel.toString() : '';
      }

      if (optionLabel === label) {
        return value[this.iconKey] || '';
      }
    }

    return '';
  };
  /**
   * Converts options into a flattened structure
   *
   * @returns {Object} Options
   */


  _proto.getFlattenedOptions = function getFlattenedOptions() {
    if (!this.labelKey && !this.valueKey && this.options && !Array.isArray(this.options)) {
      return this.options;
    }

    var options = {};

    for (var key in this.options) {
      var value = this.options[key];
      var optionLabel = this.labelKey ? value[this.labelKey] : value;
      var optionValue = this.valueKey ? value[this.valueKey] : value;

      if (typeof optionValue !== 'string') {
        optionValue = optionValue ? optionValue.toString() : '';
      }

      if (typeof optionLabel !== 'string') {
        optionLabel = optionLabel ? optionLabel.toString() : '';
      } // Check for disabled options


      var isDisabled = false;

      if (this.disabledOptions && Array.isArray(this.disabledOptions)) {
        for (var disabledKey in this.disabledOptions) {
          var disabledValue = this.disabledOptions[disabledKey];
          var disabledOptionValue = this.valueKey ? disabledValue[this.valueKey] : disabledValue;

          if (typeof disabledOptionValue !== 'string') {
            disabledOptionValue = disabledOptionValue.toString();
          }

          if (optionValue === disabledOptionValue) {
            isDisabled = true;
            break;
          }
        }
      }

      if (isDisabled) {
        continue;
      }

      options[optionLabel] = optionValue;
    } // Sort options alphabetically


    var sortedOptions = {};

    for (var _iterator = Object.keys(options).sort(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var label = _ref;
      sortedOptions[options[label]] = label;
    }

    return sortedOptions;
  };
  /**
   * Gets the current value label
   *
   * @returns {String} Value label
   */


  _proto.getValueLabel = function getValueLabel() {
    this.sanityCheck();

    if (this.icon) {
      return '<span class="widget--dropdown__value__tool-icon fa fa-' + this.icon + '"></span>';
    }

    var label = this.placeholder || '(none)';
    var options = this.getFlattenedOptions();

    if (this.useMultiple) {
      var labels = [];

      for (var key in options) {
        var value = options[key];

        if (value && this.value.indexOf(key) > -1) {
          labels.push(value);
        }
      }

      label = labels.join(', ');
    } else {
      label = options[this.value] === 0 ? '0' : options[this.value] || label;
    }

    return label;
  };
  /**
   * Performs a sanity check of the value
   */


  _proto.sanityCheck = function sanityCheck() {
    if (this.useMultiple && !Array.isArray(this.value)) {
      this.value = [];
    } else if (!this.useMultiple && Array.isArray(this.value)) {
      this.value = null;
    }
  };
  /**
   * Updates all selected classes
   */


  _proto.updateSelectedClasses = function updateSelectedClasses() {
    var btnOptions = this.element.querySelectorAll('.widget--dropdown__option');

    if (!btnOptions) {
      return;
    }

    for (var i = 0; i < btnOptions.length; i++) {
      var value = btnOptions[i].dataset.value;
      var hasValue = Array.isArray(this.value) ? this.value.indexOf(value) > -1 : this.value === value;
      btnOptions[i].classList.toggle('selected', hasValue);
    }
  };
  /**
   * Updates all position classes
   */


  _proto.updatePositionClasses = function updatePositionClasses() {
    var _this2 = this;

    setTimeout(function () {
      var toggle = _this2.element.querySelector('.widget--dropdown__toggle');

      var isChecked = toggle.checked;
      toggle.checked = true;

      var bounds = _this2.element.querySelector('.widget--dropdown__options').getBoundingClientRect();

      toggle.checked = isChecked;
      var isAtRight = bounds.right >= window.innerWidth - 10;
      var isAtBottom = bounds.bottom >= window.innerHeight - 10;

      _this2.element.classList.toggle('right', isAtRight);

      _this2.element.classList.toggle('bottom', isAtBottom);
    }, 1);
  };
  /**
   * Event: Change value
   *
   * @param {Object} newValue
   */


  _proto.onChangeInternal = function onChangeInternal(newValue) {
    this.sanityCheck(); // Change multiple value

    if (this.useMultiple) {
      // First check if value was already selected, remove if found
      var foundValue = false;

      for (var i in this.value) {
        if (this.value[i] === newValue) {
          this.value.splice(i, 1);
          foundValue = true;
          break;
        }
      } // If value was not selected, add it


      if (!foundValue) {
        if (!newValue) {
          this.value = [];
        } else {
          this.value.push(newValue);
        }
      } // Change single value

    } else {
      this.value = newValue;
    } // Update classes


    this.updateSelectedClasses(); // Update value label

    var divValue = this.element.querySelector('.widget--dropdown__value');

    if (divValue) {
      divValue.innerHTML = this.getValueLabel();
    } // Cancel


    this.toggle(false); // The value is a function, execute it and return

    if (typeof this.value === 'function') {
      this.value();
      return;
    } // Change event


    if (typeof this.onChange === 'function') {
      this.onChange(this.value);
    }
  };
  /**
   * Event: Typeahead
   *
   * @param {String} query
   */


  _proto.onTypeahead = function onTypeahead(query) {
    var btnOptions = this.element.querySelectorAll('.widget--dropdown__option');

    if (!btnOptions) {
      return;
    }

    query = (query || '').toLowerCase();

    for (var i = 0; i < btnOptions.length; i++) {
      var value = btnOptions[i].innerHTML.toLowerCase();
      var isMatch = query.length < 2 || value.indexOf(query) > -1;
      btnOptions[i].classList.toggle('hidden', !isMatch);
    }
  };
  /**
   * Toggles open/closed
   *
   * @param {Boolean} isOpen
   */


  _proto.toggle = function toggle(isOpen) {
    var toggle = this.element.querySelector('.widget--dropdown__toggle');

    if (typeof isOpen === 'undefined') {
      isOpen = !toggle.checked;
    }

    toggle.checked = isOpen;

    if (!isOpen) {
      this.trigger('cancel');
    } else {
      if (this.useTypeAhead) {
        this.element.querySelector('.widget--dropdown__typeahead').focus();
      }
    }

    this.updatePositionClasses();
    this.updateSelectedClasses();
  };
  /**
   * Template
   */


  _proto.template = function template() {
    var _this3 = this;

    return _.div({
      title: this.tooltip,
      class: 'widget widget--dropdown dropdown' + (this.icon ? ' has-icon' : '')
    }, // Value
    _.div({
      class: 'widget--dropdown__value'
    }, this.getValueLabel()), // Toggle
    _.input({
      class: 'widget--dropdown__toggle',
      type: 'checkbox'
    }).click(function (e) {
      _this3.toggle(e.currentTarget.checked);
    }), // Typeahead input
    _.if(this.useTypeAhead, _.span({
      class: 'widget--dropdown__typeahead__icon fa fa-search'
    }), _.input({
      class: 'widget--dropdown__typeahead',
      type: 'text'
    }).on('input', function (e) {
      _this3.onTypeahead(e.currentTarget.value);
    })), // Dropdown options
    _.div({
      class: 'widget--dropdown__options'
    }, _.each(this.getFlattenedOptions(), function (optionValue, optionLabel) {
      var optionIcon = _this3.getOptionIcon(optionLabel); // Reverse keys option


      if (_this3.reverseKeys) {
        var key = optionLabel;
        var value = optionValue;
        optionValue = key;
        optionLabel = value;
      }

      if (!optionValue || optionValue === '---') {
        return _.div({
          class: 'widget--dropdown__separator'
        }, optionLabel);
      }

      return _.button({
        class: 'widget--dropdown__option',
        'data-value': optionValue
      }, _.if(optionIcon, _.span({
        class: 'widget--dropdown__option__icon fa fa-' + optionIcon
      })), optionLabel).click(function (e) {
        _this3.onChangeInternal(optionValue);
      });
    })), // Clear button
    _.if(this.useClearButton, _.button({
      class: 'widget--dropdown__clear fa fa-remove',
      title: 'Clear selection'
    }).click(function (e) {
      _this3.onChangeInternal(null);
    })));
  };

  return Dropdown;
}(Widget);

module.exports = Dropdown;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A standard widget
 *
 * @memberof HashBrown.Client.Views.Widgets
 */

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Widget =
/*#__PURE__*/
function (_Crisp$View) {
  _inheritsLoose(Widget, _Crisp$View);

  /**
   * Constructor
   */
  function Widget(params) {
    var _this;

    _this = _Crisp$View.call(this, params) || this;

    if (!params.isAsync) {
      _this.fetch();
    }

    return _this;
  }
  /**
   * Adds a notifying message
   *
   * @param {String} message
   */


  var _proto = Widget.prototype;

  _proto.notify = function notify(message) {
    var notifier = this.element.querySelector('.widget__notifier');

    if (!message) {
      if (notifier) {
        notifier.parentElement.removeChild(notifier);
      }

      return;
    }

    if (!notifier) {
      notifier = _.div({
        class: 'widget__notifier'
      }, message);

      _.append(this.element, notifier);
    }

    notifier.innerHTML = message;
  };

  return Widget;
}(Crisp.View);

module.exports = Widget;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Widget = __webpack_require__(200);
/**
 * A group of chips
 *
 * @memberof HashBrown.Client.Views.Widgets
 */


var Chips =
/*#__PURE__*/
function (_Widget) {
  _inheritsLoose(Chips, _Widget);

  function Chips() {
    return _Widget.apply(this, arguments) || this;
  }

  var _proto = Chips.prototype;

  /**
   * Event: Change
   */
  _proto.onChangeInternal = function onChangeInternal() {
    if (typeof this.onChange !== 'function') {
      return;
    }

    this.onChange(this.value);
  };
  /**
   * Pre render
   */


  _proto.prerender = function prerender() {
    // Array check
    // NOTE: Array is the default mode for this widget
    if (this.useArray === true || typeof this.useArray === 'undefined') {
      // Check format
      if (!this.value || !Array.isArray(this.value)) {
        this.value = [];
      }

      if (!this.disabledValue || !Array.isArray(this.disabledValue)) {
        this.disabledValue = [];
      } // Check empty values


      for (var i = this.value.length - 1; i >= 0; i--) {
        if (!this.value[i]) {
          this.value.splice(i, 1);
        }
      } // Check for empty values or duplicates in disabled value


      for (var _i = this.disabledValue.length - 1; _i >= 0; _i--) {
        if (!this.disabledValue[_i] || this.value.indexOf(this.disabledValue[_i]) > -1) {
          this.disabledValue.splice(_i, 1);
        }
      } // Object check

    } else if (this.useArray === false || this.useObject === true) {
      // Check format
      if (!this.value || Array.isArray(this.value) || typeof this.value !== 'object') {
        this.value = {};
      }

      if (!this.disabledValue || Array.isArray(this.disabledValue) || typeof this.disabledValue !== 'object') {
        this.disabledValue = {};
      } // Check empty values


      for (var k in this.value) {
        if (!k || !this.value[k]) {
          delete this.value[k];
        }
      } // Check for empty values or duplicates in disabled value


      for (var _k in this.disabledValue) {
        if (!_k || !this.disabledValue[_k] || this.value[_k]) {
          delete this.value[_k];
        }
      }
    }
  };
  /**
   * Template
   */


  _proto.template = function template() {
    var _this = this;

    return _.div({
      class: 'widget widget--chips'
    }, _.each(this.disabledValue, function (i, item) {
      return _.div({
        class: 'widget--chips__chip'
      }, _.input({
        class: 'widget--chips__chip__input',
        disabled: true,
        value: item
      }));
    }), _.each(this.value, function (i, item) {
      return _.div({
        class: 'widget--chips__chip'
      }, _.if(_this.useObject === true || _this.useArray === false || _this.valueKey, _.input({
        class: 'widget--chips__chip__input',
        title: 'The key',
        type: 'text',
        value: item[_this.valueKey] || i,
        pattern: '.{1,}'
      }).on('change', function (e) {
        if (_this.valueKey) {
          item[_this.valueKey] = e.currentTarget.value || '';
        } else {
          i = e.currentTarget.value || '';
          _this.value[i] = item;
        }

        _this.onChangeInternal();
      })), _.input({
        class: 'widget--chips__chip__input',
        title: 'The label',
        type: 'text',
        value: _this.labelKey ? item[_this.labelKey] : item,
        pattern: '.{1,}'
      }).on('change', function (e) {
        if (_this.labelKey) {
          item[_this.labelKey] = e.currentTarget.value || '';
        } else {
          _this.value[i] = e.currentTarget.value || '';
        }

        _this.onChangeInternal();
      }), _.button({
        class: 'widget--chips__chip__remove fa fa-remove',
        title: 'Remove item'
      }).click(function () {
        _this.value.splice(i, 1);

        _this.onChangeInternal();

        _this.fetch();
      }));
    }), _.button({
      class: 'widget widget--button round widget--chips__add fa fa-plus',
      title: 'Add item'
    }).click(function () {
      var newValue = _this.placeholder || 'New item';
      var newKey = newValue.toLowerCase().replace(/[^a-zA-Z]/g, '');

      if (_this.useObject === true || _this.useArray === false) {
        _this.value[newKey] = newValue;
      } else if (_this.valueKey && _this.labelKey) {
        var newObject = {};
        newObject[_this.valueKey] = newKey;
        newObject[_this.labelKey] = newValue;

        _this.value.push(newObject);
      } else {
        _this.value.push(newValue);
      }

      _this.onChangeInternal();

      _this.fetch();
    }));
  };

  return Chips;
}(Widget);

module.exports = Chips;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Widget = __webpack_require__(200);
/**
 * A versatile input widget
 *
 * @memberof HashBrown.Client.Views.Widgets
 */


var Input =
/*#__PURE__*/
function (_Widget) {
  _inheritsLoose(Input, _Widget);

  function Input() {
    return _Widget.apply(this, arguments) || this;
  }

  var _proto = Input.prototype;

  /**
   * Event: Change value
   *
   * @param {Anything} newValue
   */
  _proto.onChangeInternal = function onChangeInternal(newValue) {
    this.value = newValue;

    if (typeof this.onChange !== 'function') {
      return;
    }

    this.onChange(this.value);
  };
  /**
   * Template
   */


  _proto.template = function template() {
    var _this = this;

    var config = {
      placeholder: this.placeholder,
      title: this.tooltip,
      type: this.type || 'text',
      class: 'widget widget--input ' + (this.type || 'text'),
      value: this.value,
      name: this.name
    };

    if (this.type === 'number' || this.type === 'range') {
      config.step = this.step || 'any';
      config.min = this.min;
      config.max = this.max;
    }

    switch (this.type) {
      case 'range':
        return _.div({
          class: config.class,
          title: config.title
        }, _.input({
          class: 'widget--input__range-input',
          type: 'range',
          value: this.value,
          min: config.min,
          max: config.max,
          step: config.step
        }).on('input', function (e) {
          _this.onChangeInternal(e.currentTarget.value);

          e.currentTarget.nextElementSibling.innerHTML = e.currentTarget.value;
        }), _.div({
          class: 'widget--input__range-extra'
        }, this.value));

      case 'checkbox':
        return _.div({
          class: config.class,
          title: config.title
        }, _.if(config.placeholder, _.label({
          for: 'checkbox-' + this.guid,
          class: 'widget--input__checkbox-label'
        }, config.placeholder)), _.input({
          id: 'checkbox-' + this.guid,
          class: 'widget--input__checkbox-input',
          type: 'checkbox',
          checked: this.value
        }).on('change', function (e) {
          _this.onChangeInternal(e.currentTarget.checked);
        }), _.div({
          class: 'widget--input__checkbox-background'
        }), _.div({
          class: 'widget--input__checkbox-switch'
        }));

      case 'file':
        return _.form({
          class: config.class + (typeof this.onSubmit === 'function' ? ' widget-group' : ''),
          title: config.title
        }, _.label({
          for: 'file-' + this.guid,
          class: 'widget--input__file-browse widget widget--button expanded'
        }, this.placeholder || 'Browse...'), _.input({
          id: 'file-' + this.guid,
          class: 'widget--input__file-input',
          type: 'file',
          name: this.name || 'file',
          multiple: this.useMultiple,
          directory: this.useDirectory
        }).on('change', function (e) {
          var names = [];
          var files = e.currentTarget.files;
          var btnBrowse = e.currentTarget.parentElement.querySelector('.widget--input__file-browse');
          var btnSubmit = e.currentTarget.parentElement.querySelector('.widget--input__file-submit');

          if (btnSubmit) {
            btnSubmit.classList.toggle('disabled', !files || files.length < 1);
          }

          _this.onChangeInternal(files);

          if (files && files.length > 0) {
            for (var i = 0; i < files.length; i++) {
              names.push(files[i].name + ' (' + Math.round(files[i].size / 1000) + 'kb)');
            }
          }

          if (names.length > 0) {
            btnBrowse.innerHTML = names.join(', ');
          } else {
            btnBrowse.innerHTML = _this.placeholder || 'Browse...';
          }
        }), _.if(typeof this.onSubmit === 'function', _.button({
          class: 'widget widget--button widget--input__file-submit disabled',
          type: 'submit',
          title: 'Upload file'
        }, _.span({
          class: 'fa fa-upload'
        }), 'Upload'))).on('submit', function (e) {
          e.preventDefault();
          var input = e.currentTarget.querySelector('.widget--input__file-input');

          if (!input || !input.files || input.files.length < 1) {
            return;
          }

          if (typeof _this.onSubmit !== 'function') {
            return;
          }

          _this.onSubmit(new FormData(e.currentTarget), input.files);
        });

      case 'textarea':
        return _.textarea(config).on('input', function (e) {
          _this.onChangeInternal(e.currentTarget.value);
        });

      default:
        return _.input(config).on('input', function (e) {
          _this.onChangeInternal(e.currentTarget.value);
        });
    }
  };

  return Input;
}(Widget);

module.exports = Input;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @namespace HashBrown.Client.Views.Modals
 */

module.exports = {
  Modal: __webpack_require__(204),
  MediaUploader: __webpack_require__(205),
  MediaBrowser: __webpack_require__(210),
  IconModal: __webpack_require__(211),
  ConfirmModal: __webpack_require__(213),
  DateModal: __webpack_require__(214),
  PublishingSettingsModal: __webpack_require__(215),
  IframeModal: __webpack_require__(216)
};

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A generic modal
 *
 * @memberof HashBrown.Client.Views.Modals
 */

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var Modal =
/*#__PURE__*/
function (_Crisp$View) {
  _inheritsLoose(Modal, _Crisp$View);

  /**
   * Constructor
   */
  function Modal(params) {
    var _this;

    params = params || {};

    if (typeof params.actions === 'undefined') {
      params.actions = [];
    }

    _this = _Crisp$View.call(this, params) || this; // If this belongs to a group, find existing modals and append instead

    if (_this.group) {
      for (var _iterator = Crisp.View.getAll('Modal'), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var modal = _ref;

        if (modal.group !== _this.group || modal === _assertThisInitialized(_assertThisInitialized(_this))) {
          continue;
        }

        modal.append(_assertThisInitialized(_assertThisInitialized(_this)));

        _this.remove();

        break;
      }
    }

    if (_this.autoFetch !== false) {
      _this.fetch();
    }

    document.body.appendChild(_this.element);
    return _this;
  }
  /**
   * Toggles the loading state
   *
   * @param {Boolean} isActive
   */


  var _proto = Modal.prototype;

  _proto.setLoading = function setLoading(isActive) {
    var spinner = this.element.querySelector('.widget--spinner');
    spinner.classList.toggle('hidden', !isActive);
  };
  /**
   * Close this modal
   *
   */


  _proto.close = function close() {
    var _this2 = this;

    this.element.classList.toggle('in', false);
    setTimeout(function () {
      _this2.remove();
    }, 500);
  };
  /**
   * Renders the modal body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    return this.body;
  };
  /**
   * Renders the modal footer
   *
   * @returns {HTMLElement} Footer
   */


  _proto.renderFooter = function renderFooter() {
    var _this3 = this;

    if (this.actions === false) {
      return;
    }

    if (this.actions && this.actions.length > 0) {
      return _.each(this.actions, function (i, action) {
        return _.button({
          class: 'widget widget--button ' + (action.class || '')
        }, action.label).click(function () {
          if (typeof action.onClick !== 'function') {
            return _this3.close();
          }

          if (action.onClick() !== false) {
            _this3.close();
          }
        });
      });
    }

    return _.button({
      class: 'widget widget--button'
    }, 'OK').click(function () {
      _this3.close();

      _this3.trigger('ok');
    });
  };
  /**
   * Renders the modal header
   *
   * @returns {HTMLElement} Header
   */


  _proto.renderHeader = function renderHeader() {
    var _this4 = this;

    if (!this.title) {
      return;
    }

    return [_.h4({
      class: 'modal__title'
    }, this.title), _.if(!this.isBlocking, _.button({
      class: 'modal__close fa fa-close'
    }).click(function () {
      _this4.close();
    }))];
  };
  /**
   * Renders this modal
   */


  _proto.template = function template() {
    var _this5 = this;

    var header = this.renderHeader();
    var body = this.renderBody();
    var footer = this.renderFooter();

    if (!this.hasTransitionedIn) {
      setTimeout(function () {
        _this5.hasTransitionedIn = true;

        _this5.element.classList.toggle('in', true);
      }, 50);
    }

    return _.div({
      class: 'modal' + (this.hasTransitionedIn ? ' in' : '') + (this.group ? ' ' + this.group : '') + (this.className ? ' modal--' + this.className : '')
    }, _.div({
      class: 'modal__dialog'
    }, _.div({
      class: 'widget--spinner embedded hidden'
    }, _.div({
      class: 'widget--spinner__image fa fa-refresh'
    })), _.if(header, _.div({
      class: 'modal__header'
    }, header)), _.if(body, _.div({
      class: 'modal__body'
    }, body)), _.if(footer && !this.isBlocking, _.div({
      class: 'modal__footer'
    }, footer))));
  };
  /**
   * Appends another modal to this modal
   *
   * @param {Modal} modal
   */


  _proto.append = function append(modal) {
    this.$element.find('.modal__footer').before(_.div({
      class: 'modal__body'
    }, modal.renderBody()));
  };

  return Modal;
}(Crisp.View); // Modal key events


document.addEventListener('keyup', function (e) {
  var modal = Crisp.View.getAll(Modal).pop();

  if (!modal) {
    return;
  }

  switch (e.which) {
    case 27:
      // Escape
      if (modal.element.querySelector('.modal__close')) {
        modal.close();
      }

      break;

    case 13:
      // Enter
      if ((!modal.actions || modal.actions.length === 0) && modal.renderFooter === Modal.renderFooter) {
        modal.close();
        modal.trigger('ok');
      } else if (modal.actions.length === 1) {
        modal.close();
        modal.actions[0].onClick();
      }

      break;
  }
});
module.exports = Modal;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Media = __webpack_require__(8);

var Modal = __webpack_require__(204);

var MediaHelper = __webpack_require__(206);

var RequestHelper = __webpack_require__(3);

var ProjectHelper = __webpack_require__(7);

var SettingsHelper = __webpack_require__(208);
/**
 * A modal for uploading Media objects
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var MediaUploader =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(MediaUploader, _Modal);

  /**
   * Constructor
   */
  function MediaUploader(params) {
    var _this;

    params.className = 'media-uploader';
    params.title = 'Upload a file';
    params.actions = false;
    _this = _Modal.call(this, params) || this;
    MediaHelper.checkMediaProvider().catch(function (e) {
      UI.errorModal(e);

      _this.close();
    });
    return _this;
  }
  /**
   * Event: Change file
   */


  var _proto = MediaUploader.prototype;

  _proto.onChangeFile = function onChangeFile(files) {
    var _this2 = this;

    var numFiles = files ? files.length : 1; // In the case of a single file selected 

    if (numFiles == 1) {
      var file = files[0];
      var isImage = file.type == 'image/png' || file.type == 'image/jpeg' || file.type == 'image/gif';
      var isVideo = file.type == 'video/mpeg' || file.type == 'video/mp4' || file.type == 'video/quicktime' || file.type == 'video/x-matroska';

      if (isImage) {
        var reader = new FileReader();
        this.setLoading(true);

        reader.onload = function (e) {
          _this2.$element.find('.modal--media-uploader__preview').html(_.img({
            src: e.target.result
          }));

          _this2.setLoading(false);
        };

        reader.readAsDataURL(file);
      }

      if (isVideo) {
        this.$element.find('.modal--media-uploader__preview').html(_.video({
          src: window.URL.createObjectURL(file),
          controls: 'controls'
        }));
      }

      debug.log('Previewing data of file type ' + file.type + '...', this); // Multiple files selected
    } else if (numFiles > 1) {
      this.$element.find('.media-preview').html('(Multiple files selected)'); // No files selected
    } else if (numFiles == 0) {
      this.$element.find('.media-preview').html('(No files selected)');
    }
  };
  /**
   * Event: Submit
   *
   * @param {FormData} content
   * @param {Array} files
   */


  _proto.onSubmit = function onSubmit(content, files) {
    var _this3 = this;

    if (!content || !files || files.length < 1) {
      return;
    }

    this.setLoading(true);
    var type = files[0].type;
    var apiPath = 'media/' + (this.replaceId ? 'replace/' + this.replaceId : 'new');
    var uploadedIds = []; // First upload the Media files

    return RequestHelper.uploadFile(apiPath, type, content) // Then update the Media tree
    .then(function (ids) {
      uploadedIds = ids;

      if (!uploadedIds || uploadedIds.length < 1) {
        return Promise.reject(new Error('File upload failed'));
      }

      if (!_this3.folder || _this3.folder === '/') {
        return Promise.resolve();
      }

      var queue = uploadedIds.slice(0);

      var putNextMediaIntoTree = function putNextMediaIntoTree() {
        var id = queue.pop();

        if (!id) {
          return Promise.resolve();
        }

        return RequestHelper.request('post', 'media/tree/' + id, {
          id: id,
          folder: _this3.folder
        }).then(function () {
          return putNextMediaIntoTree();
        });
      };

      return putNextMediaIntoTree();
    }) // Then reload the Media resource
    .then(function () {
      return RequestHelper.reloadResource('media');
    }) // Then update the UI and trigger the success callback
    .then(function () {
      _this3.setLoading(false);

      HashBrown.Views.Navigation.NavbarMain.reload();

      if (typeof _this3.onSuccess === 'function') {
        _this3.onSuccess(uploadedIds);
      }

      _this3.close();
    }).catch(function (e) {
      UI.errorModal(e);

      _this3.setLoading(false);
    });
  };
  /**
   * Render body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    var _this4 = this;

    return [_.div({
      class: 'modal--media-uploader__preview'
    }), new HashBrown.Views.Widgets.Input({
      type: 'file',
      name: 'media',
      useMultiple: !this.replaceId,
      onChange: function onChange(newValue) {
        _this4.onChangeFile(newValue);
      },
      onSubmit: function onSubmit(newValue, newFiles) {
        _this4.onSubmit(newValue, newFiles);
      }
    }).$element];
  };

  return MediaUploader;
}(Modal);

module.exports = MediaUploader;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var MediaHelperCommon = __webpack_require__(207);

var RequestHelper = __webpack_require__(3);
/**
 * The client side media helper
 *
 * @memberof HashBrown.Client.Helpers
 */


var MediaHelper =
/*#__PURE__*/
function (_MediaHelperCommon) {
  _inheritsLoose(MediaHelper, _MediaHelperCommon);

  function MediaHelper() {
    return _MediaHelperCommon.apply(this, arguments) || this;
  }

  /**
   * Gets the Media tree
   *
   * @returns {Promise(Object)} tree
   */
  MediaHelper.getTree = function getTree() {
    return RequestHelper.request('get', 'media/tree');
  };
  /**
   * Gets whether the Media provider exists
   *
   * @returns {Promise} Promise
   */


  MediaHelper.checkMediaProvider = function checkMediaProvider() {
    return HashBrown.Helpers.SettingsHelper.getSettings(HashBrown.Helpers.ProjectHelper.currentProject, HashBrown.Helpers.ProjectHelper.currentEnvironment, 'providers').then(function (result) {
      if (!result || !result.media) {
        return Promise.reject(new Error('No Media provider has been set for this project. Please make sure one of your <a href="#/connections/">Connections</a> has the "is Media provider" setting switched on.'));
      }

      return Promise.resolve();
    });
  };
  /**
   * Gets Media object by id synchronously
   *
   * @param {String} id
   *
   * @return {Media} Media object
   */


  MediaHelper.getMediaByIdSync = function getMediaByIdSync(id) {
    for (var i = 0; i < resources.media.length; i++) {
      var media = resources.media[i];

      if (media.id == id) {
        return media;
      }
    }

    return null;
  };
  /**
   * Gets the Media Url
   */


  MediaHelper.getMediaUrl = function getMediaUrl(id) {
    return '/media/' + ProjectHelper.currentProject + '/' + ProjectHelper.currentEnvironment + '/' + id;
  };
  /**
   * Gets Media object by id
   *
   * @param {String} id
   *
   * @return {Promise} Media object
   */


  MediaHelper.getMediaById = function getMediaById(id) {
    return new Promise(function (resolve, reject) {
      for (var i = 0; i < resources.media.length; i++) {
        var media = resources.media[i];

        if (media.id == id) {
          resolve(media);
          return;
        }
      }

      reject(new Error('Media with id "' + id + '" not found'));
    });
  };
  /**
   * Sets a Media tree item
   *
   * @param {String} id
   * @param {Object} item
   *
   * @returns {Promise} promise
   */


  MediaHelper.setTreeItem = function setTreeItem(id, item) {
    return RequestHelper.request('post', 'media/tree/' + id, item);
  };
  /**
   * Initialises the media picker mode
   *
   * @param {Function} onPickMedia
   * @param {Function} onChangeResource
   * @param {Object} allResources
   */


  MediaHelper.initMediaPickerMode = function initMediaPickerMode(onPickMedia, onChangeResource, onError, allResources) {
    // Claim debug messages
    UI.errorModal = onError; // Use the provided resources instead of reloading them

    HashBrown.Helpers.RequestHelper.reloadAllResources = function () {
      resources = allResources;
      return Promise.resolve();
    }; // Listen for picked Media


    window.addEventListener('hashchange', function () {
      var mediaMatch = location.hash.match(/#\/media\/([0-9a-z]{40})/);

      if (mediaMatch && mediaMatch.length > 1) {
        onPickMedia(mediaMatch[1]);
      }
    }); // Listen for resource change

    HashBrown.Views.Navigation.NavbarMain.reload = function () {
      Crisp.View.get('NavbarMain').reload();
      onChangeResource();
    }; // Set visual fixes for media picker mode


    $('.page--environment').addClass('media-picker');
  };

  return MediaHelper;
}(MediaHelperCommon);

module.exports = MediaHelper;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Models

var Media = __webpack_require__(8);
/**
 * A helper for Media objects
 *
 * @memberof HashBrown.Common.Helpers
 */


var MediaHelper =
/*#__PURE__*/
function () {
  function MediaHelper() {}

  /**
   * Gets the media root path
   *
   * @returns {Promise} Path
   */
  MediaHelper.getRootPath = function getRootPath() {
    return ConnectionHelper.getMediaProvider().then(function (connection) {
      resolve(connection.getMediaPath());
    }).catch(function () {
      resolve('');
    });
  };
  /**
   * Gets the Media tree
   *
   * @returns {Promise(Object)} tree
   */


  MediaHelper.getTree = function getTree() {
    return Promise.resolve({});
  };
  /**
   * Sets a Media tree item
   *
   * @param {String} id
   * @param {Object} item
   *
   * @returns {Promise} promise
   */


  MediaHelper.setTreeItem = function setTreeItem(id, item) {
    return Promise.resolve();
  };
  /**
   * Gets the media temp path
   *
   * @param {String} project
   *
   * @returns {String} Path
   */


  MediaHelper.getTempPath = function getTempPath(project) {
    checkParam(project, 'project', String);
    var path = '/storage/' + ProjectHelper.currentProject + '/temp';
    return path;
  };

  return MediaHelper;
}();

module.exports = MediaHelper;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestHelper = __webpack_require__(3);

var SettingsHelperCommon = __webpack_require__(209);
/**
 * The client side settings helper
 *
 * @memberof HashBrown.Client.Helpers
 */


var SettingsHelper =
/*#__PURE__*/
function (_SettingsHelperCommon) {
  _inheritsLoose(SettingsHelper, _SettingsHelperCommon);

  function SettingsHelper() {
    return _SettingsHelperCommon.apply(this, arguments) || this;
  }

  /**
   * Gets all settings
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} section
   *
   * @return {Promise(Object)}  settings
   */
  SettingsHelper.getSettings = function getSettings(project, environment, section) {
    var _this = this;

    if (environment === void 0) {
      environment = null;
    }

    if (section === void 0) {
      section = null;
    }

    checkParam(project, 'project', String);

    if (environment === '*') {
      environment = null;
    }

    var apiUrl = '/api/' + project + '/';

    if (environment) {
      apiUrl += environment + '/';
    }

    apiUrl += 'settings';

    if (section) {
      apiUrl += '/' + section;
    }

    return RequestHelper.customRequest('get', apiUrl) // Cache settings client-side
    .then(function (settings) {
      _this.updateCache(project, environment, section, settings);

      return Promise.resolve(settings || {});
    });
  };
  /**
   * Cache update
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} section
   */


  SettingsHelper.cacheSanityCheck = function cacheSanityCheck(project, environment, section) {
    if (environment === void 0) {
      environment = null;
    }

    if (section === void 0) {
      section = null;
    }

    checkParam(project, 'project', String);

    if (environment === '*') {
      environment = null;
    }

    this.cache = this.cache || {};
    this.cache[project] = this.cache[project] || {};

    if (environment) {
      this.cache[project][environment] = this.cache[project][environment] || {};

      if (section) {
        this.cache[project][environment][section] = this.cache[project][environment][section] || {};
      }
    } else if (section) {
      this.cache[project][section] = this.cache[project][section] || {};
    }
  };
  /**
   * Cache update
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} section
   * @param {Object} settings
   */


  SettingsHelper.updateCache = function updateCache(project, environment, section, settings) {
    if (environment === void 0) {
      environment = null;
    }

    if (section === void 0) {
      section = null;
    }

    checkParam(project, 'project', String);
    checkParam(settings, 'settings', Object);

    if (environment === '*') {
      environment = null;
    }

    this.cacheSanityCheck(project, environment, section);

    if (environment && !section) {
      return this.cache[project][environment] = settings;
    }

    if (!environment && section) {
      return this.cache[project][section] = settings;
    }

    if (environment && section) {
      return this.cache[project][environment][section] = settings;
    }

    return this.cache[project] = settings;
  };
  /**
   * Gets cached settings
   *
   * @param {String} section
   *
   * @returns {Object} Settings
   */


  SettingsHelper.getCachedSettings = function getCachedSettings(project, environment, section) {
    if (environment === void 0) {
      environment = null;
    }

    if (section === void 0) {
      section = null;
    }

    checkParam(project, 'project', String);

    if (environment === '*') {
      environment = null;
    }

    this.cacheSanityCheck(project, environment, section);

    if (environment) {
      if (section) {
        return this.cache[project][environment][section];
      }

      return this.cache[project][environment];
    }

    if (section) {
      return this.cache[project][section];
    }

    return this.cache[project];
  };
  /**
   * Sets all settings
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} section
   * @param {Object} settings
   *
   * @return {Promise} promise
   */


  SettingsHelper.setSettings = function setSettings(project, environment, section, settings) {
    var _this2 = this;

    if (environment === void 0) {
      environment = null;
    }

    if (section === void 0) {
      section = null;
    }

    checkParam(project, 'project', String);
    checkParam(settings, 'settings', Object);

    if (environment === '*') {
      environment = null;
    }

    var apiUrl = '/api/' + project + '/';
    settings.usedBy = 'project';

    if (environment) {
      apiUrl += environment + '/';
      settings.usedBy = environment;
    }

    apiUrl += 'settings';

    if (section) {
      apiUrl += '/' + section;
    }

    return RequestHelper.customRequest('post', apiUrl, settings) // Cache new settings
    .then(function () {
      _this2.updateCache(project, environment, section, settings);

      return Promise.resolve();
    });
  };

  return SettingsHelper;
}(SettingsHelperCommon);

module.exports = SettingsHelper;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper for settings
 *
 * @memberof HashBrown.Common.Helpers
 */

var SettingsHelper = function SettingsHelper() {};

module.exports = SettingsHelper;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Media = __webpack_require__(8);

var Modal = __webpack_require__(204);

var MediaHelper = __webpack_require__(206);

var RequestHelper = __webpack_require__(3);

var ProjectHelper = __webpack_require__(7);

var SettingsHelper = __webpack_require__(208);
/**
 * A browser modal for Media objects
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var MediaBrowser =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(MediaBrowser, _Modal);

  function MediaBrowser(params) {
    var _this;

    params = params || {};
    params.className = 'media-browser';
    params.title = 'Pick media';
    params.actions = [{
      label: 'OK',
      onClick: function onClick() {
        _this.onClickOK();
      }
    }];
    _this = _Modal.call(this, params) || this; // Init the media picker mode inside the iframe

    var iframe = _this.$element.find('iframe')[0];

    iframe.onload = function () {
      iframe.contentWindow.HashBrown.Helpers.MediaHelper.initMediaPickerMode(function (id) {
        _this.onPickMedia(id);
      }, function () {
        _this.onChangeResource();
      }, function (e) {
        UI.errorModal(e);
      }, resources);
    };

    return _this;
  }
  /**
   * Event: Pick Media
   *
   * @param {string} id
   */


  var _proto = MediaBrowser.prototype;

  _proto.onPickMedia = function onPickMedia(id) {
    this.value = id;
  };
  /** 
   * Event: Click OK
   */


  _proto.onClickOK = function onClickOK() {
    if (this.value) {
      this.trigger('select', this.value);
    }

    this.close();
  };
  /** 
   * Event: Click cancel
   */


  _proto.onClickCancel = function onClickCancel() {
    this.close();
  };
  /**
   * Event: Change resource
   */


  _proto.onChangeResource = function onChangeResource() {
    RequestHelper.reloadResource('media').then(function () {
      HashBrown.Views.Navigation.NavbarMain.reload();
    });
  };
  /**
   * Render body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    return _.iframe({
      src: '//' + location.host + '/' + HashBrown.Helpers.ProjectHelper.currentProject + '/' + HashBrown.Helpers.ProjectHelper.currentEnvironment + '/#/media/' + (this.value || '')
    });
  };

  return MediaBrowser;
}(Modal);

module.exports = MediaBrowser;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var icons = __webpack_require__(212).icons;

var Modal = __webpack_require__(204);
/**
 * A modal for picking icons
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var IconModal =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(IconModal, _Modal);

  /**
   * Constructor
   */
  function IconModal(params) {
    params = params || {};
    params.title = params.title || 'Pick an icon';
    params.actions = false;
    return _Modal.call(this, params) || this;
  }
  /**
   * Post render
   */


  var _proto = IconModal.prototype;

  _proto.postrender = function postrender() {
    this.element.classList.toggle('modal--icon', true);
  };
  /**
   * Event: Search
   *
   * @param {String} query
   */


  _proto.onSearch = function onSearch(query) {
    var icons = this.element.querySelectorAll('.modal--icon__icon');

    if (!icons) {
      return;
    }

    for (var i = 0; i < icons.length; i++) {
      if (query.length < 3 || icons[i].title.indexOf(query) > -1) {
        icons[i].style.display = 'block';
      } else {
        icons[i].style.display = 'none';
      }
    }
  };
  /**
   * Renders the modal body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    var _this = this;

    return [_.input({
      type: 'text',
      class: 'widget widget--input text modal--icon__search',
      placeholder: 'Search for icons'
    }).on('input', function (e) {
      _this.onSearch(e.currentTarget.value);
    }), _.div({
      class: 'modal--icon__icons'
    }, _.each(icons, function (i, icon) {
      return _.button({
        class: 'modal--icon__icon widget widget--button fa fa-' + icon,
        title: icon
      }).click(function () {
        _this.trigger('change', icon);

        _this.close();
      });
    }))];
  };

  return IconModal;
}(Modal);

module.exports = IconModal;

/***/ }),
/* 212 */
/***/ (function(module) {

module.exports = {"icons":["500px","adjust","adn","align-center","align-justify","align-left","align-right","amazon","ambulance","anchor","android","angellist","angle-double-down","angle-double-left","angle-double-right","angle-double-up","angle-down","angle-left","angle-right","angle-up","apple","archive","area-chart","arrow-circle-down","arrow-circle-left","arrow-circle-o-down","arrow-circle-o-left","arrow-circle-o-right","arrow-circle-o-up","arrow-circle-right","arrow-circle-up","arrow-down","arrow-left","arrow-right","arrow-up","arrows","arrows-alt","arrows-h","arrows-v","asterisk","at","automobile","backward","balance-scale","ban","bank","bar-chart","bar-chart-o","barcode","bars","battery-0","battery-1","battery-2","battery-3","battery-4","battery-empty","battery-full","battery-half","battery-quarter","battery-three-quarters","bed","beer","behance","behance-square","bell","bell-o","bell-slash","bell-slash-o","bicycle","binoculars","birthday-cake","bitbucket","bitbucket-square","bitcoin","black-tie","bluetooth","bluetooth-b","bold","bolt","bomb","book","bookmark","bookmark-o","briefcase","btc","bug","building","building-o","bullhorn","bullseye","bus","buysellads","cab","calculator","calendar","calendar-check-o","calendar-minus-o","calendar-o","calendar-plus-o","calendar-times-o","camera","camera-retro","car","caret-down","caret-left","caret-right","caret-square-o-down","caret-square-o-left","caret-square-o-right","caret-square-o-up","caret-up","cart-arrow-down","cart-plus","cc","cc-amex","cc-diners-club","cc-discover","cc-jcb","cc-mastercard","cc-paypal","cc-stripe","cc-visa","certificate","chain","chain-broken","check","check-circle","check-circle-o","check-square","check-square-o","chevron-circle-down","chevron-circle-left","chevron-circle-right","chevron-circle-up","chevron-down","chevron-left","chevron-right","chevron-up","child","chrome","circle","circle-o","circle-o-notch","circle-thin","clipboard","clock-o","clone","close","cloud","cloud-download","cloud-upload","cny","code","code-fork","codepen","codiepie","coffee","cog","cogs","columns","comment","comment-o","commenting","commenting-o","comments","comments-o","compass","compress","connectdevelop","contao","copy","copyright","creative-commons","credit-card","credit-card-alt","crop","crosshairs","css3","cube","cubes","cut","cutlery","dashboard","dashcube","database","dedent","delicious","desktop","deviantart","diamond","digg","dollar","dot-circle-o","download","dribbble","dropbox","drupal","edge","edit","eject","ellipsis-h","ellipsis-v","empire","envelope","envelope-o","envelope-square","eraser","eur","euro","exchange","exclamation","exclamation-circle","exclamation-triangle","expand","expeditedssl","external-link","external-link-square","eye","eye-slash","eyedropper","facebook","facebook-f","facebook-official","facebook-square","fast-backward","fast-forward","fax","feed","female","fighter-jet","file","file-archive-o","file-audio-o","file-code-o","file-excel-o","file-image-o","file-movie-o","file-o","file-pdf-o","file-photo-o","file-picture-o","file-powerpoint-o","file-sound-o","file-text","file-text-o","file-video-o","file-word-o","file-zip-o","files-o","film","filter","fire","fire-extinguisher","firefox","flag","flag-checkered","flag-o","flash","flask","flickr","floppy-o","folder","folder-o","folder-open","folder-open-o","font","fonticons","fort-awesome","forumbee","forward","foursquare","frown-o","futbol-o","gamepad","gavel","gbp","ge","gear","gears","genderless","get-pocket","gg","gg-circle","gift","git","git-square","github","github-alt","github-square","gittip","glass","globe","google","google-plus","google-plus-square","google-wallet","graduation-cap","gratipay","group","h-square","hacker-news","hand-grab-o","hand-lizard-o","hand-o-down","hand-o-left","hand-o-right","hand-o-up","hand-paper-o","hand-peace-o","hand-pointer-o","hand-rock-o","hand-scissors-o","hand-spock-o","hand-stop-o","hashtag","hdd-o","header","headphones","heart","heart-o","heartbeat","history","home","hospital-o","hotel","hourglass","hourglass-1","hourglass-2","hourglass-3","hourglass-end","hourglass-half","hourglass-o","hourglass-start","houzz","html5","i-cursor","ils","image","inbox","indent","industry","info","info-circle","inr","instagram","institution","internet-explorer","intersex","ioxhost","italic","joomla","jpy","jsfiddle","key","keyboard-o","krw","language","laptop","lastfm","lastfm-square","leaf","leanpub","legal","lemon-o","level-down","level-up","life-bouy","life-buoy","life-ring","life-saver","lightbulb-o","line-chart","link","linkedin","linkedin-square","linux","list","list-alt","list-ol","list-ul","location-arrow","lock","long-arrow-down","long-arrow-left","long-arrow-right","long-arrow-up","magic","magnet","mail-forward","mail-reply","mail-reply-all","male","map","map-marker","map-o","map-pin","map-signs","mars","mars-double","mars-stroke","mars-stroke-h","mars-stroke-v","maxcdn","meanpath","medium","medkit","meh-o","mercury","microphone","microphone-slash","minus","minus-circle","minus-square","minus-square-o","mixcloud","mobile","mobile-phone","modx","money","moon-o","mortar-board","motorcycle","mouse-pointer","music","navicon","neuter","newspaper-o","object-group","object-ungroup","odnoklassniki","odnoklassniki-square","opencart","openid","opera","optin-monster","outdent","pagelines","paint-brush","paper-plane","paper-plane-o","paperclip","paragraph","paste","pause","pause-circle","pause-circle-o","paw","paypal","pencil","pencil-square","pencil-square-o","percent","phone","phone-square","photo","picture-o","pie-chart","pied-piper","pied-piper-alt","pinterest","pinterest-p","pinterest-square","plane","play","play-circle","play-circle-o","plug","plus","plus-circle","plus-square","plus-square-o","power-off","print","product-hunt","puzzle-piece","qq","qrcode","question","question-circle","quote-left","quote-right","ra","random","rebel","recycle","reddit","reddit-alien","reddit-square","refresh","registered","remove","renren","reorder","repeat","reply","reply-all","retweet","rmb","road","rocket","rotate-left","rotate-right","rouble","rss","rss-square","rub","ruble","rupee","safari","save","scissors","scribd","search","search-minus","search-plus","sellsy","send","send-o","server","share","share-alt","share-alt-square","share-square","share-square-o","shekel","sheqel","shield","ship","shirtsinbulk","shopping-bag","shopping-basket","shopping-cart","sign-in","sign-out","signal","simplybuilt","sitemap","skyatlas","skype","slack","sliders","slideshare","smile-o","soccer-ball-o","sort","sort-alpha-asc","sort-alpha-desc","sort-amount-asc","sort-amount-desc","sort-asc","sort-desc","sort-down","sort-numeric-asc","sort-numeric-desc","sort-up","soundcloud","space-shuttle","spinner","spoon","spotify","square","square-o","stack-exchange","stack-overflow","star","star-half","star-half-empty","star-half-full","star-half-o","star-o","steam","steam-square","step-backward","step-forward","stethoscope","sticky-note","sticky-note-o","stop","stop-circle","stop-circle-o","street-view","strikethrough","stumbleupon","stumbleupon-circle","subscript","subway","suitcase","sun-o","superscript","support","table","tablet","tachometer","tag","tags","tasks","taxi","television","tencent-weibo","terminal","text-height","text-width","th","th-large","th-list","thumb-tack","thumbs-down","thumbs-o-down","thumbs-o-up","thumbs-up","ticket","times","times-circle","times-circle-o","tint","toggle-down","toggle-left","toggle-off","toggle-on","toggle-right","toggle-up","trademark","train","transgender","transgender-alt","trash","trash-o","tree","trello","tripadvisor","trophy","truck","try","tty","tumblr","tumblr-square","turkish-lira","tv","twitch","twitter","twitter-square","umbrella","underline","undo","university","unlink","unlock","unlock-alt","unsorted","upload","usb","usd","user","user-md","user-plus","user-secret","user-times","users","venus","venus-double","venus-mars","viacoin","video-camera","vimeo","vimeo-square","vine","vk","volume-down","volume-off","volume-up","warning","wechat","weibo","weixin","whatsapp","wheelchair","wifi","wikipedia-w","windows","won","wordpress","wrench","xing","xing-square","y-combinator","y-combinator-square","yahoo","yc","yc-square","yelp","yen","youtube","youtube-play","youtube-square"]};

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Modal = __webpack_require__(204);
/**
 * A modal for confirming actions
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var ConfirmModal =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(ConfirmModal, _Modal);

  function ConfirmModal() {
    return _Modal.apply(this, arguments) || this;
  }

  var _proto = ConfirmModal.prototype;

  /**
   * Post render
   */
  _proto.postrender = function postrender() {
    this.element.classList.toggle('modal--confirm', true);
  };
  /**
   * Render header
   */


  _proto.renderHeader = function renderHeader() {
    return _.h4({
      class: 'modal--date__header__title'
    }, this.title);
  };
  /**
   * Renders the modal footer
   *
   * @returns {HTMLElement} Footer
   */


  _proto.renderFooter = function renderFooter() {
    var _this = this;

    return [_.button({
      class: 'widget widget--button standard'
    }, 'Cancel').click(function () {
      _this.trigger('cancel');

      _this.close();
    }), _.button({
      class: 'widget widget--button warning'
    }, this.type || 'OK').click(function () {
      _this.trigger('ok');

      _this.close();
    })];
  };
  /**
   * Render body
   */


  _proto.renderBody = function renderBody() {
    return this.body;
  };

  return ConfirmModal;
}(Modal);

module.exports = ConfirmModal;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Modal = __webpack_require__(204);
/**
 * A modal for picking dates
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var DateModal =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(DateModal, _Modal);

  /**
   * Constructor
   */
  function DateModal(params) {
    params.className = 'date';
    return _Modal.call(this, params) || this;
  }
  /**
   * Pre render
   */


  var _proto = DateModal.prototype;

  _proto.prerender = function prerender() {
    this.days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    this.months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    this.hours = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23'];
    this.minutes = ['00', '05', '10', '15', '20', '25', '30', '35', '40', '45', '50', '55']; // Sanity check

    this.value = this.value ? new Date(this.value) : new Date();

    if (isNaN(this.value.getDate())) {
      this.value = new Date();
    }
  };
  /**
   * Gets days in current month and year
   *
   * @param {Number} year
   * @param {Number} month
   *
   * @returns {Array} Days
   */


  _proto.getDays = function getDays(year, month) {
    var max = new Date(year, month, 0).getDate();
    var days = [];

    while (days.length < max) {
      days[days.length] = days.length + 1;
    }

    return days;
  };
  /**
   * Render header
   */


  _proto.renderHeader = function renderHeader() {
    var _this = this;

    return [_.div({
      class: 'modal--date__header__year'
    }, this.value.getFullYear().toString()), _.div({
      class: 'modal--date__header__day'
    }, this.days[this.value.getDay()] + ', ' + this.months[this.value.getMonth()] + ' ' + this.value.getDate()), _.button({
      class: 'modal__close fa fa-close'
    }).click(function () {
      _this.close();
    })];
  };
  /**
   * Renders the modal footer
   *
   * @returns {HTMLElement} Footer
   */


  _proto.renderFooter = function renderFooter() {
    var _this2 = this;

    return _.button({
      class: 'widget widget--button'
    }, 'OK').click(function () {
      _this2.trigger('change', _this2.value);

      _this2.close();
    });
  };
  /**
   * Render body
   */


  _proto.renderBody = function renderBody() {
    var _this3 = this;

    return [_.div({
      class: 'modal--date__body__nav'
    }, _.button({
      class: 'modal--date__body__nav__left fa fa-arrow-left'
    }).click(function () {
      _this3.value.setMonth(_this3.value.getMonth() - 1);

      _this3.fetch();
    }), _.div({
      class: 'modal--date__body__nav__month-year'
    }, this.months[this.value.getMonth()] + ' ' + this.value.getFullYear()), _.button({
      class: 'modal--date__body__nav__left fa fa-arrow-right'
    }).click(function () {
      _this3.value.setMonth(_this3.value.getMonth() + 1);

      _this3.fetch();
    })), _.div({
      class: 'modal--date__body__weekdays'
    }, _.span({
      class: 'modal--date__body__weekday'
    }, 'M'), _.span({
      class: 'modal--date__body__weekday'
    }, 'T'), _.span({
      class: 'modal--date__body__weekday'
    }, 'W'), _.span({
      class: 'modal--date__body__weekday'
    }, 'T'), _.span({
      class: 'modal--date__body__weekday'
    }, 'F'), _.span({
      class: 'modal--date__body__weekday'
    }, 'S'), _.span({
      class: 'modal--date__body__weekday'
    }, 'S')), _.div({
      class: 'modal--date__body__days'
    }, _.each(this.getDays(this.value.getFullYear(), this.value.getMonth() + 1), function (i, day) {
      var thisDate = new Date(_this3.value.getTime());
      var now = new Date();
      var isCurrent = now.getFullYear() == _this3.value.getFullYear() && now.getMonth() == _this3.value.getMonth() && now.getDate() == day;
      var isActive = _this3.value.getDate() == day;
      thisDate.setDate(day);
      return _.button({
        class: 'modal--date__body__day' + (isCurrent ? ' current' : '') + (isActive ? ' active' : '')
      }, day).click(function () {
        _this3.value.setDate(day);

        _this3.fetch();
      });
    })), _.div({
      class: 'modal--date__body__time'
    }, _.input({
      class: 'modal--date__body__time__number',
      type: 'number',
      min: 0,
      max: 23,
      value: this.value.getHours()
    }).on('change', function (e) {
      _this3.value.setHours(e.currentTarget.value);
    }), _.div({
      class: 'modal--date__body__time__separator'
    }, ':'), _.input({
      class: 'modal--date__body__time__number',
      type: 'number',
      min: 0,
      max: 59,
      value: this.value.getMinutes()
    }).on('change', function (e) {
      _this3.value.setMinutes(e.currentTarget.value);
    }))];
  };

  return DateModal;
}(Modal);

module.exports = DateModal;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Modal = __webpack_require__(204);
/**
 * A dialog for editing publishing settings for Content nodes
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var PublishingSettingsModal =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(PublishingSettingsModal, _Modal);

  /**
   * Constructor
   */
  function PublishingSettingsModal(params) {
    var _this;

    params.title = 'Publishing settings for "' + params.model.prop('title', window.language) + '"';
    params.actions = [{
      label: 'OK',
      onClick: function onClick() {
        _this.trigger('change', _this.value);
      }
    }];
    params.value = JSON.parse(JSON.stringify(params.model.getSettings('publishing'))) || {};
    return _this = _Modal.call(this, params) || this;
  }
  /**
   * Renders the body
   *
   * @returns {HTMLElement} Body
   */


  var _proto = PublishingSettingsModal.prototype;

  _proto.renderBody = function renderBody() {
    var _this2 = this;

    if (this.value.governedBy) {
      var governor = HashBrown.Helpers.ContentHelper.getContentByIdSync(this.value.governedBy);
      return _.div({
        class: 'widget widget--label'
      }, '(Settings inherited from <a href="#/content/' + governor.id + '">' + governor.prop('title', window.language) + '</a>)');
    } else {
      return _.div({
        class: 'settings-publishing'
      }, // Apply to children switch
      _.div({
        class: 'widget-group'
      }, _.label({
        class: 'widget widget--label'
      }, 'Apply to children'), new HashBrown.Views.Widgets.Input({
        type: 'checkbox',
        value: this.value.applyToChildren === true,
        onChange: function onChange(newValue) {
          _this2.value.applyToChildren = newValue;
        }
      }).$element), // Connection picker
      _.div({
        class: 'widget-group'
      }, _.label({
        class: 'widget widget--label'
      }, 'Connection'), new HashBrown.Views.Widgets.Dropdown({
        options: resources.connections,
        value: this.value.connectionId,
        valueKey: 'id',
        labelKey: 'title',
        useClearButton: true,
        onChange: function onChange(newValue) {
          _this2.value.connectionId = newValue;
        }
      }).$element));
    }
  };

  return PublishingSettingsModal;
}(Modal);

module.exports = PublishingSettingsModal;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Modal = __webpack_require__(204);
/**
 * A modal for showng iframes
 *
 * @memberof HashBrown.Client.Views.Modals
 */


var IframeModal =
/*#__PURE__*/
function (_Modal) {
  _inheritsLoose(IframeModal, _Modal);

  function IframeModal() {
    return _Modal.apply(this, arguments) || this;
  }

  var _proto = IframeModal.prototype;

  /**
   * Post render
   */
  _proto.postrender = function postrender() {
    this.element.classList.toggle('modal--iframe', true);
  };
  /**
   * Render body
   */


  _proto.renderBody = function renderBody() {
    return _.iframe({
      class: 'modal--iframe__iframe',
      src: this.url
    });
  };

  return IframeModal;
}(Modal);

module.exports = IframeModal;

/***/ }),
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestHelper = __webpack_require__(3);

var ContentHelperCommon = __webpack_require__(224);

var Content = __webpack_require__(188);
/**
 * The client side content helper
 *
 * @memberof HashBrown.Client.Helpers
 */


var ContentHelper =
/*#__PURE__*/
function (_ContentHelperCommon) {
  _inheritsLoose(ContentHelper, _ContentHelperCommon);

  function ContentHelper() {
    return _ContentHelperCommon.apply(this, arguments) || this;
  }

  /**
   * Gets Content by id
   *
   * @param {String} id
   *
   * @returns {Content} Content node
   */
  ContentHelper.getContentByIdSync = function getContentByIdSync(id) {
    if (!id) {
      return null;
    }

    for (var _iterator = resources.content, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var content = _ref;

      if (content.id === id) {
        return content;
      }
    }
  };
  /**
   * Gets Content by id
   *
   * @param {String} id
   *
   * @returns {Promise} Content node
   */


  ContentHelper.getContentById = function getContentById(id) {
    if (!id) {
      return Promise.resolve(null);
    }

    return RequestHelper.request('get', 'content/' + id).then(function (content) {
      return Promise.resolve(new Content(content));
    });
  };
  /**
   * Sets Content by id
   *
   * @param {String} id
   * @param {Content} content
   *
   * @returns {Promise} Content node
   */


  ContentHelper.setContentById = function setContentById(id, content) {
    checkParam(id, 'id', String);
    checkParam(content, 'content', HashBrown.Models.Content);
    return RequestHelper.request('post', 'content/' + id, content.getObject()).then(function (content) {
      return Promise.resolve(content);
    });
  };
  /**
   * A sanity check for fields
   *
   * @param {Object} value
   * @param {Schema} schema
   */


  ContentHelper.fieldSanityCheck = function fieldSanityCheck(value, schema) {
    // If the schema value is set to multilingual, but the value isn't an object, convert it
    if (schema.multilingual && (!value || typeof value !== 'object')) {
      var oldValue = value;
      value = {};
      value[window.language] = oldValue;
    } // If the schema value is not set to multilingual, but the value is an object
    // containing the _multilingual flag, convert it


    if (!schema.multilingual && value && typeof value === 'object' && value._multilingual) {
      value = value[window.language];
    } // Update the _multilingual flag


    if (schema.multilingual && value && !value._multilingual) {
      value._multilingual = true;
    } else if (!schema.multilingual && value && value._multilingual) {
      delete value._multilingual;
    }

    return value;
  };
  /**
   * Get new sort index
   *
   * @param {String} parentId
   * @param {String} aboveId
   * @param {String} belowId
   */


  ContentHelper.getNewSortIndex = function getNewSortIndex(parentId, aboveId, belowId) {
    if (aboveId) {
      return this.getContentByIdSync(aboveId).sort + 1;
    }

    if (belowId) {
      return this.getContentByIdSync(belowId).sort - 1;
    } // Filter out content that doesn't have the same parent


    var nodes = resources.content.filter(function (x) {
      return x.parentId == parentId || !x.parentId && !parentId;
    }); // Find new index
    // NOTE: The index should be the highest sort number + 10000 to give a bit of leg room for sorting later

    var newIndex = 10000;

    for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var content = _ref2;

      if (newIndex - 10000 <= content.sort) {
        newIndex = content.sort + 10000;
      }
    }

    return newIndex;
  };
  /**
   * Starts a tour of the Content section
   */


  ContentHelper.startTour = function startTour() {
    if (location.hash.indexOf('content/') < 0) {
      location.hash = '/content/';
    }

    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve();
      }, 500);
    }).then(function () {
      return UI.highlight('.navbar-main__tab[data-route="/content/"]', 'This the Content section, where you will do all of your authoring.', 'right', 'next');
    }).then(function () {
      return UI.highlight('.navbar-main__pane[data-route="/content/"]', 'Here you will find all of your authored Content, like webpages. You can right click here to create a Content node.', 'right', 'next');
    }).then(function () {
      var editor = document.querySelector('.editor--content');

      if (!editor) {
        return UI.highlight('.page--environment__space--editor', 'This is where the Content editor will be when you click a Content node.', 'left', 'next');
      }

      return UI.highlight('.editor--content', 'This is the Content editor, where you edit Content nodes.', 'left', 'next');
    });
  };

  return ContentHelper;
}(ContentHelperCommon);

module.exports = ContentHelper;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper class for Content
 *
 * @memberof HashBrown.Common.Helpers
 */

var ContentHelper =
/*#__PURE__*/
function () {
  function ContentHelper() {}

  /**
   * Gets all Content objects
   *
   * @param {String} project
   * @param {String} environment
   *
   * @return {Promise} promise
   */
  ContentHelper.getAllContents = function getAllContents(project, environment) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    return Promise.resolve();
  };
  /**
   * Gets a URL-friendly version of a string
   *
   * @param {String} string
   *
   * @param {String} slug
   */


  ContentHelper.getSlug = function getSlug(string) {
    return (string || '').toLowerCase().replace(/[æ|ä]/g, 'ae').replace(/[ø|ö]/g, 'oe').replace(/å/g, 'aa').replace(/ü/g, 'ue').replace(/ß/g, 'ss').replace(/[^\w ]+/g, '').replace(/ +/g, '-');
  };
  /**
   * Gets a Content object by id
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} id
   *
   * @return {Promise} promise
   */


  ContentHelper.getContentById = function getContentById(project, environment, id) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    checkParam(id, 'id', String);
    return Promise.resolve();
  };
  /**
   * Sets a Content object by id
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} id
   * @param {Content} content
   *
   * @return {Promise} promise
   */


  ContentHelper.setContentById = function setContentById(project, environment, id, content) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    checkParam(id, 'id', String);
    checkParam(content, 'content', HashBrown.Models.Content);
    return new Promise(function (resolve, reject) {
      resolve();
    });
  };
  /**
   * Checks if a Schema type is allowed as a child of a Content object
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} parentId
   * @param {String} childSchemaId
   *
   * @returns {Promise} Is the Content node allowed as a child
   */


  ContentHelper.isSchemaAllowedAsChild = function isSchemaAllowedAsChild(project, environment, parentId, childSchemaId) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    checkParam(parentId, 'parentId', String);
    checkParam(childSchemaId, 'childSchemaId', String); // No parent ID means root, and all Schemas are allowed there

    if (!parentId) {
      return Promise.resolve();
    } else {
      return this.getContentById(project, environment, parentId).then(function (parentContent) {
        return HashBrown.Helpers.SchemaHelper.getSchemaById(project, environment, parentContent.schemaId);
      }).then(function (parentSchema) {
        // The Schema was not an allowed child
        if (parentSchema.allowedChildSchemas.indexOf(childSchemaId) < 0) {
          return HashBrown.Helpers.SchemaHelper.getSchemaById(project, environment, childSchemaId).then(function (childSchema) {
            return Promise.reject(new Error('Content with Schema "' + childSchema.name + '" is not an allowed child of Content with Schema "' + parentSchema.name + '"'));
          }); // The Schema was an allowed child, resolve
        } else {
          return Promise.resolve();
        }
      });
    }
  };
  /**
   * Creates a new content object
   *
   * @return {Promise} promise
   */


  ContentHelper.createContent = function createContent() {
    return new Promise(function (resolve, reject) {
      resolve();
    });
  };
  /**
   * Removes a content object
   *
   * @param {Number} id
   *
   * @return {Promise} promise
   */


  ContentHelper.removeContentById = function removeContentById(id) {
    return new Promise(function (resolve, reject) {
      resolve();
    });
  };

  return ContentHelper;
}();

module.exports = ContentHelper;

/***/ }),
/* 225 */,
/* 226 */,
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestHelper = __webpack_require__(3);
/**
 * An editor for Users
 *
 * @memberof HashBrown.Client.Views.Editors
 */


var UserEditor =
/*#__PURE__*/
function (_HashBrown$Views$Moda) {
  _inheritsLoose(UserEditor, _HashBrown$Views$Moda);

  /**
   * Constructor
   */
  function UserEditor(params) {
    var _this;

    params.title = 'Settings for "' + (params.model.fullName || params.model.username || params.model.email || params.model.id) + '"';
    params.actions = [{
      label: 'Save',
      onClick: function onClick() {
        _this.onClickSave();
      }
    }];
    params.autoFetch = false;
    _this = _HashBrown$Views$Moda.call(this, params) || this;
    RequestHelper.customRequest('get', '/api/server/projects').then(function (projects) {
      _this.projects = projects;

      _this.fetch();
    });
    return _this;
  }
  /**
   * Event: Click save.
   */


  var _proto = UserEditor.prototype;

  _proto.onClickSave = function onClickSave() {
    var _this2 = this;

    var newUserObject = this.model.getObject();

    if (this.newPassword) {
      newUserObject.password = this.newPassword;
    }

    RequestHelper.request('post', 'user/' + this.model.id, newUserObject).then(function () {
      _this2.close();

      _this2.trigger('save', _this2.model);
    }).catch(UI.errorModal);
  };
  /**
   * Renders the username editor
   *
   * @returns {HTMLElement} Element
   */


  _proto.renderUserNameEditor = function renderUserNameEditor() {
    var _this3 = this;

    return new HashBrown.Views.Widgets.Input({
      value: this.model.username,
      placeholder: 'Input the username here',
      onChange: function onChange(newValue) {
        _this3.model.username = newValue;
      }
    }).$element;
  };
  /**
   * Renders the scopes editor
   *
   * @param {String} project
   *
   * @returns {HTMLElement} Element
   */


  _proto.renderScopesEditor = function renderScopesEditor(project) {
    var _this4 = this;

    return new HashBrown.Views.Widgets.Dropdown({
      value: this.model.getScopes(project),
      useMultiple: true,
      placeholder: '(no scopes)',
      options: ['connections', 'schemas', 'templates'],
      onChange: function onChange(newValue) {
        _this4.model.scopes[project] = newValue;

        _this4.fetch();
      }
    }).$element;
  };
  /**
   * Renders the full name editor
   *
   * @return {HTMLElement} Element
   */


  _proto.renderFullNameEditor = function renderFullNameEditor() {
    var _this5 = this;

    return new HashBrown.Views.Widgets.Input({
      value: this.model.fullName,
      onChange: function onChange(newValue) {
        _this5.model.fullName = newValue;
      }
    }).$element;
  };
  /**
   * Renders the email editor
   *
   * @return {HTMLElement} Element
   */


  _proto.renderEmailEditor = function renderEmailEditor() {
    var _this6 = this;

    return new HashBrown.Views.Widgets.Input({
      value: this.model.email,
      onChange: function onChange(newValue) {
        _this6.model.email = newValue;
      }
    }).$element;
  };
  /**
   * Renders the password
   *
   * @return {HTMLElement} Element
   */


  _proto.renderPasswordEditor = function renderPasswordEditor() {
    var _this7 = this;

    var password1;
    var password2;

    var _onChange = function onChange() {
      var isMatch = password1 == password2;
      var isLongEnough = password1 && password1.length > 3;
      var isValid = isMatch && isLongEnough;

      _this7.$element.find('.modal__footer .widget--button').toggleClass('disabled', !isValid);

      var $passwordWarning = _this7.$element.find('.editor--user__password-warning');

      if (isValid) {
        _this7.newPassword = password1;
        $passwordWarning.hide();
      } else {
        $passwordWarning.show();
        _this7.newPassword = null;

        if (!isMatch) {
          $passwordWarning.html('Passwords do not match');
        } else if (!isLongEnough) {
          $passwordWarning.html('Passwords are too short');
        }
      }
    };

    return _.div({
      class: 'widget-group'
    }, new HashBrown.Views.Widgets.Input({
      placeholder: 'Type new password',
      type: 'password',
      onChange: function onChange(newValue) {
        password1 = newValue;

        _onChange();
      }
    }).$element, new HashBrown.Views.Widgets.Input({
      placeholder: 'Confirm new password',
      type: 'password',
      onChange: function onChange(newValue) {
        password2 = newValue;

        _onChange();
      }
    }).$element);
  };
  /**
   * Renders the admin editor
   *
   * @return {HTMLElement} Element
   */


  _proto.renderAdminEditor = function renderAdminEditor() {
    var _this8 = this;

    return new HashBrown.Views.Widgets.Input({
      type: 'checkbox',
      value: this.model.isAdmin == true,
      onChange: function onChange(newValue) {
        _this8.model.isAdmin = newValue;
        setTimeout(function () {
          _this8.fetch();
        }, 300);
      }
    }).$element;
  };
  /**
   * Renders a single field
   *
   * @return {HTMLElement} Element
   */


  _proto.renderField = function renderField(label, $content) {
    return _.div({
      class: 'widget-group'
    }, _.div({
      class: 'widget widget--label'
    }, label), $content);
  };
  /**
   * Renders this editor
   */


  _proto.renderBody = function renderBody() {
    var _this9 = this;

    return [this.renderField('Username', this.renderUserNameEditor()), this.renderField('Full name', this.renderFullNameEditor()), this.renderField('Email', this.renderEmailEditor()), this.renderField('Password', this.renderPasswordEditor()), _.div({
      class: 'widget widget--label warning hidden editor--user__password-warning'
    }), _.if(currentUserIsAdmin() && !this.hidePermissions, this.renderField('Is admin', this.renderAdminEditor()), _.if(!this.model.isAdmin, _.div({
      class: 'widget widget--separator'
    }, 'Projects'), _.each(this.projects, function (i, project) {
      return _.div({
        class: 'widget-group'
      }, new HashBrown.Views.Widgets.Input({
        type: 'checkbox',
        value: _this9.model.hasScope(project.id),
        onChange: function onChange(newValue) {
          if (newValue) {
            _this9.model.giveScope(project.id);
          } else {
            _this9.model.removeScope(project.id);
          }
        }
      }).$element, _.div({
        class: 'widget widget--label'
      }, project.settings.info.name), _this9.renderScopesEditor(project.id));
    })))];
  };

  return UserEditor;
}(HashBrown.Views.Modals.Modal);

module.exports = UserEditor;

/***/ }),
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var ConnectionHelperCommon = __webpack_require__(234);

var Connection = __webpack_require__(190);

var ProjectHelper = __webpack_require__(7);

var RequestHelper = __webpack_require__(3);
/**
 * The client side connection helper
 *
 * @memberof HashBrown.Client.Helpers
 */


var ConnectionHelper =
/*#__PURE__*/
function (_ConnectionHelperComm) {
  _inheritsLoose(ConnectionHelper, _ConnectionHelperComm);

  function ConnectionHelper() {
    return _ConnectionHelperComm.apply(this, arguments) || this;
  }

  /**
   * Gets all connections
   *
   * @return {Promise} Array of Connections
   */
  ConnectionHelper.getAllConnections = function getAllConnections() {
    return Promise.resolve(resources.connections);
  };
  /**
   * Gets a Connection by id (sync)
   *
   * @param {string} id
   *
   * @return {Promise} Connection
   */


  ConnectionHelper.getConnectionByIdSync = function getConnectionByIdSync(id) {
    checkParam(id, 'id', String);

    for (var i in resources.connections) {
      var connection = resources.connections[i];

      if (connection.id == id) {
        return connection;
      }
    }
  };
  /**
   * Gets a Connection by id
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} id
   *
   * @return {Promise(Connection)} promise
   */


  ConnectionHelper.getConnectionById = function getConnectionById(project, environment, id) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    checkParam(id, 'id', String);

    for (var i in resources.connections) {
      var connection = resources.connections[i];

      if (connection.id == id) {
        return Promise.resolve(connection);
      }
    }

    return Promise.reject(new Error('No Connection by id "' + id + '" was found'));
  };
  /**
   * Sets the Media provider
   *
   * @param {String} id
   *
   * @returns {Promise}
   */


  ConnectionHelper.setMediaProvider = function setMediaProvider(id) {
    return _ConnectionHelperComm.setMediaProvider.call(this, ProjectHelper.currentProject, ProjectHelper.currentEnvironment, id).then(function () {
      return RequestHelper.reloadResource('media');
    }).then(function () {
      HashBrown.Views.Navigation.NavbarMain.reload();
    });
  };
  /**
   * Gets the Media provider
   *
   * @returns {Promise} Connection
   */


  ConnectionHelper.getMediaProvider = function getMediaProvider() {
    return _ConnectionHelperComm.getMediaProvider.call(this, ProjectHelper.currentProject, ProjectHelper.currentEnvironment);
  };
  /**
   * Sets the Template provider
   *
   * @param {String} id
   *
   * @returns {Promise}
   */


  ConnectionHelper.setTemplateProvider = function setTemplateProvider(id) {
    return _ConnectionHelperComm.setTemplateProvider.call(this, ProjectHelper.currentProject, ProjectHelper.currentEnvironment, id).then(function () {
      return RequestHelper.reloadResource('templates');
    }).then(function () {
      HashBrown.Views.Navigation.NavbarMain.reload();
    });
  };
  /**
   * Gets the Template provider
   *
   * @returns {Promise} Connection
   */


  ConnectionHelper.getTemplateProvider = function getTemplateProvider() {
    return _ConnectionHelperComm.getTemplateProvider.call(this, ProjectHelper.currentProject, ProjectHelper.currentEnvironment);
  };

  return ConnectionHelper;
}(ConnectionHelperCommon);

module.exports = ConnectionHelper;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Connection = __webpack_require__(191);
/**
 * The helper class for Connections
 *
 * @memberof HashBrown.Common.Helpers
 */


var ConnectionHelper =
/*#__PURE__*/
function () {
  function ConnectionHelper() {}

  /**
   * Gets all connections
   *
   * @param {String} project
   * @param {String} environment
   *
   * @returns {Promise(Array)} connections
   */
  ConnectionHelper.getAllConnections = function getAllConnections(project, environment) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    return Promise.resolve();
  };
  /**
   * Sets the Template provider
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} id
   *
   * @return {Promise} Promise
   */


  ConnectionHelper.setTemplateProvider = function setTemplateProvider(project, environment, id) {
    if (id === void 0) {
      id = null;
    }

    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    return HashBrown.Helpers.SettingsHelper.getSettings(project, environment, 'providers').then(function (providers) {
      providers = providers || {};
      providers.template = id;
      return HashBrown.Helpers.SettingsHelper.setSettings(project, environment, 'providers', providers);
    });
  };
  /**
   * Gets the Template provider
   *
   * @param {String} project
   * @param {String} environment
   *
   * @return {Promise} Connection object
   */


  ConnectionHelper.getTemplateProvider = function getTemplateProvider(project, environment) {
    var _this = this;

    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    return HashBrown.Helpers.SettingsHelper.getSettings(project, environment, 'providers') // Previously, providers were set project-wide, so retrieve automatically if needed
    .then(function (providers) {
      if (!providers) {
        return HashBrown.Helpers.SettingsHelper.getSettings(project, null, 'providers');
      } else {
        return Promise.resolve(providers);
      }
    }) // Return requested provider
    .then(function (providers) {
      providers = providers || {};

      if (providers.template) {
        return _this.getConnectionById(project, environment, providers.template);
      } else {
        return Promise.resolve(null);
      }
    });
  };
  /**
   * Sets the Media provider
   *
   * @param {String} project
   * @param {String} environment
   * @param {String} id
   *
   * @return {Promise} Promise
   */


  ConnectionHelper.setMediaProvider = function setMediaProvider(project, environment, id) {
    if (id === void 0) {
      id = null;
    }

    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    return HashBrown.Helpers.SettingsHelper.getSettings(project, environment, 'providers').then(function (providers) {
      providers = providers || {};
      providers.media = id;
      return HashBrown.Helpers.SettingsHelper.setSettings(project, environment, 'providers', providers);
    });
  };
  /**
   * Gets the Media provider
   *
   * @param {String} project
   * @param {String} environment
   *
   * @return {Promise} Connection object
   */


  ConnectionHelper.getMediaProvider = function getMediaProvider(project, environment) {
    var _this2 = this;

    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    return HashBrown.Helpers.SettingsHelper.getSettings(project, environment, 'providers') // Previously, providers were set project-wide, so retrieve automatically if needed
    .then(function (providers) {
      if (!providers) {
        return HashBrown.Helpers.SettingsHelper.getSettings(project, null, 'providers');
      } else {
        return Promise.resolve(providers);
      }
    }) // Return requested provider
    .then(function (providers) {
      providers = providers || {};

      if (providers.media) {
        return _this2.getConnectionById(project, environment, providers.media);
      } else {
        return Promise.resolve(null);
      }
    });
  };

  return ConnectionHelper;
}();

module.exports = ConnectionHelper;

/***/ }),
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var SettingsHelper = __webpack_require__(208);

var ProjectHelper = __webpack_require__(7);

var LanguageHelperCommon = __webpack_require__(249);

var selectedLanguages = {};
/**
 * The client side language helper
 *
 * @memberof HashBrown.Client.Helpers
 */

var LanguageHelper =
/*#__PURE__*/
function (_LanguageHelperCommon) {
  _inheritsLoose(LanguageHelper, _LanguageHelperCommon);

  function LanguageHelper() {
    return _LanguageHelperCommon.apply(this, arguments) || this;
  }

  /**
   * Gets all selected languages
   *
   * @param {String} project
   *
   * @returns {Array} List of language names
   */
  LanguageHelper.getLanguages = function getLanguages(project) {
    project = project || ProjectHelper.currentProject;
    return SettingsHelper.getSettings(project, null, 'languages').then(function (selected) {
      if (!selected || !Array.isArray(selected)) {
        selected = ['en'];
      }

      selected.sort();
      selectedLanguages[project] = selected;
      return Promise.resolve(selected);
    });
  };
  /**
   * Gets all selected languages (sync)
   *
   * @param {String} project
   *
   * @returns {Array} List of language names
   */


  LanguageHelper.getLanguagesSync = function getLanguagesSync(project) {
    project = project || ProjectHelper.currentProject;
    return selectedLanguages[project] || ['en'];
  };
  /**
   * Sets all languages
   *
   * @param {String} project
   * @param {Array} languages
   *
   * @returns {Promise} promise
   */


  LanguageHelper.setLanguages = function setLanguages(project, languages) {
    checkParam(project, 'project', String);
    checkParam(languages, 'languages', Array);

    if (!Array.isArray(languages)) {
      return Promise.reject(new Error('Language array cannot be of type "' + typeof languages + '"'));
    }

    return SettingsHelper.setSettings(project, null, 'languages', languages);
  };

  return LanguageHelper;
}(LanguageHelperCommon);

module.exports = LanguageHelper;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper for language
 *
 * @memberof HashBrown.Common.Helpers
 */

var LanguageHelper =
/*#__PURE__*/
function () {
  function LanguageHelper() {}

  /**
   * Gets all selected languages
   *
   * @param {String} project
   *
   * @returns {Array} List of language names
   */
  LanguageHelper.getLanguages = function getLanguages(project) {
    checkParam(project, 'project', String);
    return Promise.resolve([]);
  };
  /**
   * Sets all languages
   *
   * @param {String} project
   * @param {Array} languages
   *
   * @returns {Promise} Promise
   */


  LanguageHelper.setLanguages = function setLanguages(project, languages) {
    checkParam(project, 'project', String);
    checkParam(languages, 'languages', Array);
    return Promise.resolve();
  };
  /**
   * Gets localised sets of properties for a Content object
   *
   * @param {String} project
   * @param {String} environment
   * @param {Content} content
   *
   * @return {Promise} Properties
   */


  LanguageHelper.getAllLocalizedPropertySets = function getAllLocalizedPropertySets(project, environment, content) {
    checkParam(project, 'project', String);
    checkParam(environment, 'environment', String);
    checkParam(content, 'content', HashBrown.Models.Content);
    return this.getLanguages(project).then(function (languages) {
      var sets = {};

      for (var _iterator = languages, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var language = _ref;
        var properties = content.getLocalizedProperties(language);
        sets[language] = properties;
      }

      return Promise.resolve(sets);
    });
  };
  /**
   * Gets all languages
   *
   * @returns {Array} List of language names
   */


  LanguageHelper.getLanguageOptions = function getLanguageOptions() {
    return ["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rc", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"];
  };

  return LanguageHelper;
}();

module.exports = LanguageHelper;

/***/ }),
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @namespace HashBrown.Client.Helpers
 */

module.exports = {
  ConnectionHelper: __webpack_require__(233),
  ContentHelper: __webpack_require__(223),
  DebugHelper: __webpack_require__(260),
  LanguageHelper: __webpack_require__(248),
  MarkdownHelper: __webpack_require__(262),
  MediaHelper: __webpack_require__(206),
  ProjectHelper: __webpack_require__(7),
  RequestHelper: __webpack_require__(3),
  SchemaHelper: __webpack_require__(172),
  SettingsHelper: __webpack_require__(208),
  TemplateHelper: __webpack_require__(263),
  UIHelper: __webpack_require__(264)
};

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var DebugHelperCommon = __webpack_require__(261);
/**
 * The client side debug helper
 *
 * @memberof HashBrown.Client.Helpers
 */


var DebugHelper =
/*#__PURE__*/
function (_DebugHelperCommon) {
  _inheritsLoose(DebugHelper, _DebugHelperCommon);

  function DebugHelper() {
    return _DebugHelperCommon.apply(this, arguments) || this;
  }

  /**
   * Start the debug socket
   */
  DebugHelper.startSocket = function startSocket() {
    var _this = this;

    var debugSocket = new WebSocket(location.protocol.replace('http', 'ws') + '//' + location.host + '/api/debug');

    debugSocket.onopen = function (ev) {
      debug.log('Debug socket open', 'HashBrown');
    };

    debugSocket.onmessage = function (ev) {
      _this.onSocketMessage(ev);
    };
  };
  /**
   * Event: On debug socket message
   */


  DebugHelper.onSocketMessage = function onSocketMessage(ev) {
    try {
      var data = JSON.parse(ev.data);

      switch (data.type) {
        case 'error':
          UI.errorModal(new Error(data.sender + ': ' + data.message));
          break;

        case 'warning':
          UI.errorModal(new Error(data.sender + ': ' + data.message));
          break;
      }
    } catch (e) {
      UI.errorModal(ev);
    }
  };

  return DebugHelper;
}(DebugHelperCommon);

module.exports = DebugHelper;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var VERBOSITY = 2;
/**
 * A helper for debugging
 *
 * @memberof HashBrown.Common.Helpers
 */

var DebugHelper =
/*#__PURE__*/
function () {
  function DebugHelper() {}

  /**
   * Event: Log
   *
   * @param {String} dateString
   * @param {String} senderString
   * @param {String} message
   * @param {String} type
   */
  DebugHelper.onLog = function onLog(dateString, senderString, message, type) {
    if (type) {
      message = '[' + type.toUpperCase() + '] ' + message;
    }

    console.log(dateString + ' | ' + senderString + ' | ' + message);
  };
  /**
   * Gets the date string
   *
   * @returns {String} date
   */


  DebugHelper.getDateString = function getDateString() {
    var date = new Date();
    var monthString = date.getMonth() + 1;

    if (monthString < 10) {
      monthString = '0' + monthString;
    }

    var dateString = date.getDate();

    if (dateString < 10) {
      dateString = '0' + dateString;
    }

    var hoursString = date.getHours();

    if (hoursString < 10) {
      hoursString = '0' + hoursString;
    }

    var minutesString = date.getMinutes();

    if (minutesString < 10) {
      minutesString = '0' + minutesString;
    }

    var secondsString = date.getSeconds();

    if (secondsString < 10) {
      secondsString = '0' + secondsString;
    }

    var output = date.getFullYear() + '.' + monthString + '.' + dateString + ' ' + hoursString + ':' + minutesString + ':' + secondsString;
    return output;
  };
  /**
   * Parse sender
   *
   * @param {Object} sender
   *
   * @returns {String} name
   */


  DebugHelper.parseSender = function parseSender(sender, ignoreLast) {
    var senderName = '';

    if (sender) {
      if (typeof sender === 'string') {
        senderName = sender;
      } else if (typeof sender === 'function') {
        senderName = sender.name;
      } else if (sender.constructor) {
        senderName = sender.constructor.name;
      } else {
        senderName = sender.toString();
      }
    }

    return senderName;
  };
  /**
   * Logs a message
   *
   * @param {String} message
   * @param {Object} sender
   * @param {Number} verbosity
   */


  DebugHelper.log = function log(message, sender, verbosity) {
    if (verbosity === void 0) {
      verbosity = 1;
    }

    if (verbosity == 0) {
      this.error('Verbosity cannot be set to 0', this);
    } else if (!verbosity) {
      verbosity = 1;
    }

    if (VERBOSITY >= verbosity) {
      this.onLog(this.getDateString(), this.parseSender(sender), message);
    }
  };
  /**
   * Shows an error
   *
   * @param {String} message
   * @param {Object} sender
   */


  DebugHelper.error = function error(message, sender) {
    if (message instanceof Error) {
      message = message.message || message.trace;
    }

    this.onLog(this.getDateString(), this.parseSender(sender), message, 'error');
  };
  /**
   * Shows a warning
   */


  DebugHelper.warning = function warning(message, sender) {
    this.onLog(this.getDateString(), this.parseSender(sender), message, 'warning');
  };

  return DebugHelper;
}();

module.exports = DebugHelper;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper class for handling markdown
 *
 * @memberof HashBrown.Client.Helpers
 */

var MarkdownHelper =
/*#__PURE__*/
function () {
  function MarkdownHelper() {}

  /**
   * Converts a string from HTML to markdown (based on "turndown")
   *
   * NOTE: This terrible approach had to be implemented since "to-markdown"
   * became "turndown" and employed an ugly implementation that we're
   * encapsulating here to prevent polluting the global namespace with libraries
   *
   * In the future, we should fork the project and integrate it more neatly
   *
   * @return {String} Markdown
   */
  MarkdownHelper.fromHtml = function fromHtml(html) {
    var TurndownService = function () {
      'use strict';

      function extend(destination) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (source.hasOwnProperty(key)) destination[key] = source[key];
          }
        }

        return destination;
      }

      function repeat(character, count) {
        return Array(count + 1).join(character);
      }

      var blockElements = ['address', 'article', 'aside', 'audio', 'blockquote', 'body', 'canvas', 'center', 'dd', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'html', 'isindex', 'li', 'main', 'menu', 'nav', 'noframes', 'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'];

      function isBlock(node) {
        return blockElements.indexOf(node.nodeName.toLowerCase()) !== -1;
      }

      var voidElements = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

      function isVoid(node) {
        return voidElements.indexOf(node.nodeName.toLowerCase()) !== -1;
      }

      var voidSelector = voidElements.join();

      function hasVoid(node) {
        return node.querySelector && node.querySelector(voidSelector);
      }

      var rules = {};
      rules.paragraph = {
        filter: 'p',
        replacement: function replacement(content) {
          return '\n\n' + content + '\n\n';
        }
      };
      rules.lineBreak = {
        filter: 'br',
        replacement: function replacement(content, node, options) {
          return options.br + '\n';
        }
      };
      rules.heading = {
        filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
        replacement: function replacement(content, node, options) {
          var hLevel = Number(node.nodeName.charAt(1));

          if (options.headingStyle === 'setext' && hLevel < 3) {
            var underline = repeat(hLevel === 1 ? '=' : '-', content.length);
            return '\n\n' + content + '\n' + underline + '\n\n';
          } else {
            return '\n\n' + repeat('#', hLevel) + ' ' + content + '\n\n';
          }
        }
      };
      rules.blockquote = {
        filter: 'blockquote',
        replacement: function replacement(content) {
          content = content.replace(/^\n+|\n+$/g, '');
          content = content.replace(/^/gm, '> ');
          return '\n\n' + content + '\n\n';
        }
      };
      rules.list = {
        filter: ['ul', 'ol'],
        replacement: function replacement(content, node) {
          var parent = node.parentNode;

          if (parent.nodeName === 'LI' && parent.lastElementChild === node) {
            return '\n' + content;
          } else {
            return '\n\n' + content + '\n\n';
          }
        }
      };
      rules.listItem = {
        filter: 'li',
        replacement: function replacement(content, node, options) {
          content = content.replace(/^\n+/, '') // remove leading newlines
          .replace(/\n+$/, '\n') // replace trailing newlines with just a single one
          .replace(/\n/gm, '\n    '); // indent

          var prefix = options.bulletListMarker + '   ';
          var parent = node.parentNode;

          if (parent.nodeName === 'OL') {
            var start = parent.getAttribute('start');
            var index = Array.prototype.indexOf.call(parent.children, node);
            prefix = (start ? Number(start) + index : index + 1) + '.  ';
          }

          return prefix + content + (node.nextSibling && !/\n$/.test(content) ? '\n' : '');
        }
      };
      rules.indentedCodeBlock = {
        filter: function filter(node, options) {
          return options.codeBlockStyle === 'indented' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
        },
        replacement: function replacement(content, node, options) {
          return '\n\n    ' + node.firstChild.textContent.replace(/\n/g, '\n    ') + '\n\n';
        }
      };
      rules.fencedCodeBlock = {
        filter: function filter(node, options) {
          return options.codeBlockStyle === 'fenced' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
        },
        replacement: function replacement(content, node, options) {
          var className = node.firstChild.className || '';
          var language = (className.match(/language-(\S+)/) || [null, ''])[1];
          return '\n\n' + options.fence + language + '\n' + node.firstChild.textContent + '\n' + options.fence + '\n\n';
        }
      };
      rules.horizontalRule = {
        filter: 'hr',
        replacement: function replacement(content, node, options) {
          return '\n\n' + options.hr + '\n\n';
        }
      };
      rules.inlineLink = {
        filter: function filter(node, options) {
          return options.linkStyle === 'inlined' && node.nodeName === 'A' && node.getAttribute('href');
        },
        replacement: function replacement(content, node) {
          var href = node.getAttribute('href');
          var title = node.title ? ' "' + node.title + '"' : '';
          return '[' + content + '](' + href + title + ')';
        }
      };
      rules.referenceLink = {
        filter: function filter(node, options) {
          return options.linkStyle === 'referenced' && node.nodeName === 'A' && node.getAttribute('href');
        },
        replacement: function replacement(content, node, options) {
          var href = node.getAttribute('href');
          var title = node.title ? ' "' + node.title + '"' : '';
          var replacement;
          var reference;

          switch (options.linkReferenceStyle) {
            case 'collapsed':
              replacement = '[' + content + '][]';
              reference = '[' + content + ']: ' + href + title;
              break;

            case 'shortcut':
              replacement = '[' + content + ']';
              reference = '[' + content + ']: ' + href + title;
              break;

            default:
              var id = this.references.length + 1;
              replacement = '[' + content + '][' + id + ']';
              reference = '[' + id + ']: ' + href + title;
          }

          this.references.push(reference);
          return replacement;
        },
        references: [],
        append: function append(options) {
          var references = '';

          if (this.references.length) {
            references = '\n\n' + this.references.join('\n') + '\n\n';
            this.references = []; // Reset references
          }

          return references;
        }
      };
      rules.emphasis = {
        filter: ['em', 'i'],
        replacement: function replacement(content, node, options) {
          if (!content.trim()) return '';
          return options.emDelimiter + content + options.emDelimiter;
        }
      };
      rules.strong = {
        filter: ['strong', 'b'],
        replacement: function replacement(content, node, options) {
          if (!content.trim()) return '';
          return options.strongDelimiter + content + options.strongDelimiter;
        }
      };
      rules.code = {
        filter: function filter(node) {
          var hasSiblings = node.previousSibling || node.nextSibling;
          var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;
          return node.nodeName === 'CODE' && !isCodeBlock;
        },
        replacement: function replacement(content) {
          if (!content.trim()) return '';
          var delimiter = '`';
          var leadingSpace = '';
          var trailingSpace = '';
          var matches = content.match(/`+/gm);

          if (matches) {
            if (/^`/.test(content)) leadingSpace = ' ';
            if (/`$/.test(content)) trailingSpace = ' ';

            while (matches.indexOf(delimiter) !== -1) {
              delimiter = delimiter + '`';
            }
          }

          return delimiter + leadingSpace + content + trailingSpace + delimiter;
        }
      };
      rules.image = {
        filter: 'img',
        replacement: function replacement(content, node) {
          var alt = node.alt || '';
          var src = node.getAttribute('src') || '';
          var title = node.title || '';
          var titlePart = title ? ' "' + title + '"' : '';
          return src ? '![' + alt + '](' + src + titlePart + ')' : '';
        }
      };
      /**
      * Manages a collection of rules used to convert HTML to Markdown
      */

      function Rules(options) {
        this.options = options;
        this._keep = [];
        this._remove = [];
        this.blankRule = {
          replacement: options.blankReplacement
        };
        this.keepReplacement = options.keepReplacement;
        this.defaultRule = {
          replacement: options.defaultReplacement
        };
        this.array = [];

        for (var key in options.rules) {
          this.array.push(options.rules[key]);
        }
      }

      Rules.prototype = {
        add: function add(key, rule) {
          this.array.unshift(rule);
        },
        keep: function keep(filter) {
          this._keep.unshift({
            filter: filter,
            replacement: this.keepReplacement
          });
        },
        remove: function remove(filter) {
          this._remove.unshift({
            filter: filter,
            replacement: function replacement() {
              return '';
            }
          });
        },
        forNode: function forNode(node) {
          if (node.isBlank) return this.blankRule;
          var rule;
          if (rule = findRule(this.array, node, this.options)) return rule;
          if (rule = findRule(this._keep, node, this.options)) return rule;
          if (rule = findRule(this._remove, node, this.options)) return rule;
          return this.defaultRule;
        },
        forEach: function forEach(fn) {
          for (var i = 0; i < this.array.length; i++) {
            fn(this.array[i], i);
          }
        }
      };

      function findRule(rules, node, options) {
        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i];
          if (filterValue(rule, node, options)) return rule;
        }

        return void 0;
      }

      function filterValue(rule, node, options) {
        var filter = rule.filter;

        if (typeof filter === 'string') {
          if (filter === node.nodeName.toLowerCase()) return true;
        } else if (Array.isArray(filter)) {
          if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
        } else if (typeof filter === 'function') {
          if (filter.call(rule, node, options)) return true;
        } else {
          throw new TypeError('`filter` needs to be a string, array, or function');
        }
      }
      /**
      * The collapseWhitespace function is adapted from collapse-whitespace
      * by Luc Thevenard.
      *
      * The MIT License (MIT)
      *
      * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>
      *
      * Permission is hereby granted, free of charge, to any person obtaining a copy
      * of this software and associated documentation files (the "Software"), to deal
      * in the Software without restriction, including without limitation the rights
      * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      * copies of the Software, and to permit persons to whom the Software is
      * furnished to do so, subject to the following conditions:
      *
      * The above copyright notice and this permission notice shall be included in
      * all copies or substantial portions of the Software.
      *
      * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      * THE SOFTWARE.
      */

      /**
      * collapseWhitespace(options) removes extraneous whitespace from an the given element.
      *
      * @param {Object} options
      */


      function collapseWhitespace(options) {
        var element = options.element;
        var isBlock = options.isBlock;
        var isVoid = options.isVoid;

        var isPre = options.isPre || function (node) {
          return node.nodeName === 'PRE';
        };

        if (!element.firstChild || isPre(element)) return;
        var prevText = null;
        var prevVoid = false;
        var prev = null;
        var node = next(prev, element, isPre);

        while (node !== element) {
          if (node.nodeType === 3 || node.nodeType === 4) {
            // Node.TEXT_NODE or Node.CDATA_SECTION_NODE
            var text = node.data.replace(/[ \r\n\t]+/g, ' ');

            if ((!prevText || / $/.test(prevText.data)) && !prevVoid && text[0] === ' ') {
              text = text.substr(1);
            } // `text` might be empty at this point.


            if (!text) {
              node = remove(node);
              continue;
            }

            node.data = text;
            prevText = node;
          } else if (node.nodeType === 1) {
            // Node.ELEMENT_NODE
            if (isBlock(node) || node.nodeName === 'BR') {
              if (prevText) {
                prevText.data = prevText.data.replace(/ $/, '');
              }

              prevText = null;
              prevVoid = false;
            } else if (isVoid(node)) {
              // Avoid trimming space around non-block, non-BR void elements.
              prevText = null;
              prevVoid = true;
            }
          } else {
            node = remove(node);
            continue;
          }

          var nextNode = next(prev, node, isPre);
          prev = node;
          node = nextNode;
        }

        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, '');

          if (!prevText.data) {
            remove(prevText);
          }
        }
      }
      /**
      * remove(node) removes the given node from the DOM and returns the
      * next node in the sequence.
      *
      * @param {Node} node
      * @return {Node} node
      */


      function remove(node) {
        var next = node.nextSibling || node.parentNode;
        node.parentNode.removeChild(node);
        return next;
      }
      /**
      * next(prev, current, isPre) returns the next node in the sequence, given the
      * current and previous nodes.
      *
      * @param {Node} prev
      * @param {Node} current
      * @param {Function} isPre
      * @return {Node}
      */


      function next(prev, current, isPre) {
        if (prev && prev.parentNode === current || isPre(current)) {
          return current.nextSibling || current.parentNode;
        }

        return current.firstChild || current.nextSibling || current.parentNode;
      }
      /*
      * Set up window for Node.js
      */


      var root = typeof window !== 'undefined' ? window : {};
      /*
      * Parsing HTML strings
      */

      function canParseHTMLNatively() {
        var Parser = root.DOMParser;
        var canParse = false; // Adapted from https://gist.github.com/1129031 Firefox/Opera/IE throw errors on
        // unsupported types

        try {
          // WebKit returns null on unsupported types
          if (new Parser().parseFromString('', 'text/html')) {
            canParse = true;
          }
        } catch (e) {}

        return canParse;
      }

      function createHTMLParser() {
        var Parser = function Parser() {};

        {
          if (shouldUseActiveX()) {
            Parser.prototype.parseFromString = function (string) {
              var doc = new window.ActiveXObject('htmlfile');
              doc.designMode = 'on'; // disable on-page scripts

              doc.open();
              doc.write(string);
              doc.close();
              return doc;
            };
          } else {
            Parser.prototype.parseFromString = function (string) {
              var doc = document.implementation.createHTMLDocument('');
              doc.open();
              doc.write(string);
              doc.close();
              return doc;
            };
          }
        }
        return Parser;
      }

      function shouldUseActiveX() {
        var useActiveX = false;

        try {
          document.implementation.createHTMLDocument('').open();
        } catch (e) {
          if (window.ActiveXObject) useActiveX = true;
        }

        return useActiveX;
      }

      var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();

      function RootNode(input) {
        var root;

        if (typeof input === 'string') {
          var doc = htmlParser().parseFromString( // DOM parsers arrange elements in the <head> and <body>. Wrapping in a custom
          // element ensures elements are reliably arranged in a single element.
          '<x-turndown id="turndown-root">' + input + '</x-turndown>', 'text/html');
          root = doc.getElementById('turndown-root');
        } else {
          root = input.cloneNode(true);
        }

        collapseWhitespace({
          element: root,
          isBlock: isBlock,
          isVoid: isVoid
        });
        return root;
      }

      var _htmlParser;

      function htmlParser() {
        _htmlParser = _htmlParser || new HTMLParser();
        return _htmlParser;
      }

      function Node(node) {
        node.isBlock = isBlock(node);
        node.isCode = node.nodeName.toLowerCase() === 'code' || node.parentNode.isCode;
        node.isBlank = isBlank(node);
        node.flankingWhitespace = flankingWhitespace(node);
        return node;
      }

      function isBlank(node) {
        return ['A', 'TH', 'TD', 'IFRAME', 'SCRIPT', 'AUDIO', 'VIDEO'].indexOf(node.nodeName) === -1 && /^\s*$/i.test(node.textContent) && !isVoid(node) && !hasVoid(node);
      }

      function flankingWhitespace(node) {
        var leading = '';
        var trailing = '';

        if (!node.isBlock) {
          var hasLeading = /^[ \r\n\t]/.test(node.textContent);
          var hasTrailing = /[ \r\n\t]$/.test(node.textContent);

          if (hasLeading && !isFlankedByWhitespace('left', node)) {
            leading = ' ';
          }

          if (hasTrailing && !isFlankedByWhitespace('right', node)) {
            trailing = ' ';
          }
        }

        return {
          leading: leading,
          trailing: trailing
        };
      }

      function isFlankedByWhitespace(side, node) {
        var sibling;
        var regExp;
        var isFlanked;

        if (side === 'left') {
          sibling = node.previousSibling;
          regExp = / $/;
        } else {
          sibling = node.nextSibling;
          regExp = /^ /;
        }

        if (sibling) {
          if (sibling.nodeType === 3) {
            isFlanked = regExp.test(sibling.nodeValue);
          } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
            isFlanked = regExp.test(sibling.textContent);
          }
        }

        return isFlanked;
      }

      var reduce = Array.prototype.reduce;
      var leadingNewLinesRegExp = /^\n*/;
      var trailingNewLinesRegExp = /\n*$/;
      var escapes = [[/\\/g, '\\\\'], [/\*/g, '\\*'], [/^-/g, '\\-'], [/^\+ /g, '\\+ '], [/^(=+)/g, '\\$1'], [/^(#{1,6}) /g, '\\$1 '], [/`/g, '\\`'], [/^~~~/g, '\\~~~'], [/\[/g, '\\['], [/\]/g, '\\]'], [/^>/g, '\\>'], [/_/g, '\\_'], [/^(\d+)\. /g, '$1\\. ']];

      function TurndownService(options) {
        if (!(this instanceof TurndownService)) return new TurndownService(options);
        var defaults = {
          rules: rules,
          headingStyle: 'setext',
          hr: '* * *',
          bulletListMarker: '*',
          codeBlockStyle: 'indented',
          fence: '```',
          emDelimiter: '_',
          strongDelimiter: '**',
          linkStyle: 'inlined',
          linkReferenceStyle: 'full',
          br: '  ',
          blankReplacement: function blankReplacement(content, node) {
            return node.isBlock ? '\n\n' : '';
          },
          keepReplacement: function keepReplacement(content, node) {
            return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
          },
          defaultReplacement: function defaultReplacement(content, node) {
            return node.isBlock ? '\n\n' + content + '\n\n' : content;
          }
        };
        this.options = extend({}, defaults, options);
        this.rules = new Rules(this.options);
      }

      TurndownService.prototype = {
        /**
        * The entry point for converting a string or DOM node to Markdown
        * @public
        * @param {String|HTMLElement} input The string or DOM node to convert
        * @returns A Markdown representation of the input
        * @type String
        */
        turndown: function turndown(input) {
          if (!canConvert(input)) {
            throw new TypeError(input + ' is not a string, or an element/document/fragment node.');
          }

          if (input === '') return '';
          var output = process.call(this, new RootNode(input));
          return postProcess.call(this, output);
        },

        /**
        * Add one or more plugins
        * @public
        * @param {Function|Array} plugin The plugin or array of plugins to add
        * @returns The Turndown instance for chaining
        * @type Object
        */
        use: function use(plugin) {
          if (Array.isArray(plugin)) {
            for (var i = 0; i < plugin.length; i++) {
              this.use(plugin[i]);
            }
          } else if (typeof plugin === 'function') {
            plugin(this);
          } else {
            throw new TypeError('plugin must be a Function or an Array of Functions');
          }

          return this;
        },

        /**
        * Adds a rule
        * @public
        * @param {String} key The unique key of the rule
        * @param {Object} rule The rule
        * @returns The Turndown instance for chaining
        * @type Object
        */
        addRule: function addRule(key, rule) {
          this.rules.add(key, rule);
          return this;
        },

        /**
        * Keep a node (as HTML) that matches the filter
        * @public
        * @param {String|Array|Function} filter The unique key of the rule
        * @returns The Turndown instance for chaining
        * @type Object
        */
        keep: function keep(filter) {
          this.rules.keep(filter);
          return this;
        },

        /**
        * Remove a node that matches the filter
        * @public
        * @param {String|Array|Function} filter The unique key of the rule
        * @returns The Turndown instance for chaining
        * @type Object
        */
        remove: function remove(filter) {
          this.rules.remove(filter);
          return this;
        },

        /**
        * Escapes Markdown syntax
        * @public
        * @param {String} string The string to escape
        * @returns A string with Markdown syntax escaped
        * @type String
        */
        escape: function escape(string) {
          return escapes.reduce(function (accumulator, escape) {
            return accumulator.replace(escape[0], escape[1]);
          }, string);
        }
      };
      /**
      * Reduces a DOM node down to its Markdown string equivalent
      * @private
      * @param {HTMLElement} parentNode The node to convert
      * @returns A Markdown representation of the node
      * @type String
      */

      function process(parentNode) {
        var self = this;
        return reduce.call(parentNode.childNodes, function (output, node) {
          node = new Node(node);
          var replacement = '';

          if (node.nodeType === 3) {
            replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
          } else if (node.nodeType === 1) {
            replacement = replacementForNode.call(self, node);
          }

          return join(output, replacement);
        }, '');
      }
      /**
      * Appends strings as each rule requires and trims the output
      * @private
      * @param {String} output The conversion output
      * @returns A trimmed version of the ouput
      * @type String
      */


      function postProcess(output) {
        var self = this;
        this.rules.forEach(function (rule) {
          if (typeof rule.append === 'function') {
            output = join(output, rule.append(self.options));
          }
        });
        return output.replace(/^[\t\r\n]+/, '').replace(/[\t\r\n\s]+$/, '');
      }
      /**
      * Converts an element node to its Markdown equivalent
      * @private
      * @param {HTMLElement} node The node to convert
      * @returns A Markdown representation of the node
      * @type String
      */


      function replacementForNode(node) {
        var rule = this.rules.forNode(node);
        var content = process.call(this, node);
        var whitespace = node.flankingWhitespace;
        if (whitespace.leading || whitespace.trailing) content = content.trim();
        return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
      }
      /**
      * Determines the new lines between the current output and the replacement
      * @private
      * @param {String} output The current conversion output
      * @param {String} replacement The string to append to the output
      * @returns The whitespace to separate the current output and the replacement
      * @type String
      */


      function separatingNewlines(output, replacement) {
        var newlines = [output.match(trailingNewLinesRegExp)[0], replacement.match(leadingNewLinesRegExp)[0]].sort();
        var maxNewlines = newlines[newlines.length - 1];
        return maxNewlines.length < 2 ? maxNewlines : '\n\n';
      }

      function join(string1, string2) {
        var separator = separatingNewlines(string1, string2); // Remove trailing/leading newlines and replace with separator

        string1 = string1.replace(trailingNewLinesRegExp, '');
        string2 = string2.replace(leadingNewLinesRegExp, '');
        return string1 + separator + string2;
      }
      /**
      * Determines whether an input can be converted
      * @private
      * @param {String|HTMLElement} input Describe this parameter
      * @returns Describe what it returns
      * @type String|Object|Array|Boolean|Number
      */


      function canConvert(input) {
        return input != null && (typeof input === 'string' || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
      }

      return TurndownService;
    }();

    return new TurndownService().turndown(html);
  };

  return MarkdownHelper;
}();

module.exports = MarkdownHelper;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A helper class for Template resources
 *
 * @memberof HashBrown.Client.Helpers
 */

var TemplateHelper =
/*#__PURE__*/
function () {
  function TemplateHelper() {}

  /**
   * Gets all templates
   *
   * @param {String} type
   *
   * @returns {Array} Templates
   */
  TemplateHelper.getAllTemplates = function getAllTemplates(type) {
    if (!type) {
      return resources.templates;
    }

    var templates = [];

    for (var _iterator = resources.templates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var template = _ref;

      if (template.type !== type) {
        continue;
      }

      templates.push(template);
    }

    return templates;
  };
  /**
   * Gets a template by id
   *
   * @param {String} type
   * @param {String} id
   *
   * @returns {Template} Template
   */


  TemplateHelper.getTemplate = function getTemplate(type, id) {
    for (var _iterator2 = resources.templates, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var template = _ref2;

      if (template.type !== type || template.id !== id) {
        continue;
      }

      return template;
    }

    return null;
  };

  return TemplateHelper;
}();

module.exports = TemplateHelper;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A UI helper for creating and handling common interface behaviours
 *
 * @memberof HashBrown.Client.Helpers
 */

var UIHelper =
/*#__PURE__*/
function () {
  function UIHelper() {}

  /**
   * Highlights an element with an optional label
   *
   * @param {Boolean|HTMLElement} element
   * @param {String} label
   * @param {String} direction
   * @param {String} buttonLabel
   *
   * @return {Promise} Callback on dismiss
   */
  UIHelper.highlight = function highlight(element, label, direction, buttonLabel) {
    if (direction === void 0) {
      direction = 'right';
    }

    if (element === false) {
      $('.widget--highlight').remove();
      return Promise.resolve();
    }

    if (typeof element === 'string') {
      element = document.querySelector(element);
    }

    if (!element) {
      return Promise.resolve();
    }

    this.highlight(false);
    return new Promise(function (resolve) {
      var dismiss = function dismiss() {
        $highlight.remove();
        resolve(element);
      };

      var $highlight = _.div({
        class: 'widget--highlight' + (label ? ' ' + direction : ''),
        style: 'top: ' + element.offsetTop + 'px; left: ' + element.offsetLeft + 'px;'
      }, _.div({
        class: 'widget--highlight__backdrop'
      }), _.div({
        class: 'widget--highlight__frame',
        style: 'width: ' + element.offsetWidth + 'px; height: ' + element.offsetHeight + 'px;'
      }), _.if(label, _.div({
        class: 'widget--highlight__label'
      }, _.div({
        class: 'widget--highlight__label__text'
      }, label), _.if(buttonLabel, _.button({
        class: 'widget widget--button widget--highlight__button condensed'
      }, buttonLabel).click(function () {
        dismiss();
      }))))).click(function () {
        if (buttonLabel) {
          return;
        }

        dismiss();
      });

      _.append(element.parentElement, $highlight);
    });
  };
  /**
   * Sets the content of the editor space
   *
   * @param {Array|HTMLElement} content
   * @param {String} className
   */


  UIHelper.setEditorSpaceContent = function setEditorSpaceContent(content, className) {
    var $space = $('.page--environment__space--editor');

    if (className) {
      content = _.div({
        class: 'page--environment__space--editor__' + className
      }, content);
    }

    _.append($space.empty(), content);
  };
  /**
   * Creates a sortable context specific to arrays using editor fields
   *
   * @param {Array} array
   * @param {HTMLElement} field
   * @param {Function} onChange
   */


  UIHelper.fieldSortableArray = function fieldSortableArray(array, field, onChange) {
    array = array || []; // Set indices on all elements

    var items = field.querySelector('.editor__field__value').children;

    for (var i = 0; i < items.length; i++) {
      if (items[i] instanceof HTMLElement === false || !items[i].classList.contains('editor__field')) {
        continue;
      }

      items[i].dataset.index = i;
    } // Init the sortable context


    this.fieldSortable(field, function (element) {
      if (!element) {
        return;
      }

      var oldIndex = element.dataset.index;
      var newIndex = 0; // Discover new index

      var items = field.querySelector('.editor__field__value').children;

      for (var _i = 0; _i < items.length; _i++) {
        if (items[_i] === element) {
          newIndex = _i;
          break;
        }
      } // Swap indices


      array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
      onChange(array);
    });
  };
  /**
   * Creates a sortable context specific to objects using editor fields
   *
   * @param {Object} object
   * @param {HTMLElement} field
   * @param {Function} onChange
   */


  UIHelper.fieldSortableObject = function fieldSortableObject(object, field, onChange) {
    object = object || {};
    this.fieldSortable(field, function (element) {
      if (!element) {
        return;
      }

      var itemSortKeyElement = element.querySelector('.editor__field__sort-key');
      var itemKey = itemSortKeyElement.value || itemSortKeyElement.innerHTML;
      var itemValue = object[itemKey]; // Try to get the next key

      var nextKey = '';
      var nextSortKeyElement = element.nextElementSibling ? element.nextElementSibling.querySelector('.editor__field__sort-key') : null;

      if (nextSortKeyElement) {
        nextKey = nextSortKeyElement.value || nextSortKeyElement.innerHTML;
      } // Construct a new object based on the old one


      var newObject = {};

      for (var fieldKey in object) {
        // Omit existing key
        if (fieldKey === itemKey) {
          continue;
        }

        var fieldValue = object[fieldKey]; // If there is a next key, and it's the same as this field key,
        // the sorted item should be inserted just before it

        if (nextKey === fieldKey) {
          newObject[itemKey] = itemValue;
        }

        newObject[fieldKey] = fieldValue;
      } // If the item wasn't reinserted, insert it now


      if (!newObject[itemKey]) {
        newObject[itemKey] = itemValue;
      } // Assign the new object to the old one


      object = newObject; // Fire the change event

      onChange(newObject);
    });
  };
  /**
   * Creates a sortable context specific to fields
   *
   * @param {HTMLElement} field
   * @param {Function} onChange
   */


  UIHelper.fieldSortable = function fieldSortable(field, onChange) {
    var btnSort = field.querySelector('.editor__field__key__action--sort');
    var divValue = field.querySelector('.editor__field__value');
    var isSorting = !divValue.classList.contains('sorting');

    if (this.sortable(divValue, 'editor__field', isSorting, onChange)) {
      btnSort.classList.toggle('sorting', isSorting);
      divValue.classList.toggle('sorting', isSorting);
    }
  };
  /**
   * Creates a sortable context
   *
   * @param {HTMLElement} parentElement
   * @param {String} sortableClassName
   * @param {Boolean} isActive
   * @param {Function} onChange
   *
   * @returns {Boolean} Whether or not sorting was initialised
   */


  UIHelper.sortable = function sortable(parentElement, sortableClassName, isActive, onChange) {
    var children = Array.prototype.slice.call(parentElement.children || []);
    var canSort = true;
    var currentDraggedChild;
    children = children.filter(function (child) {
      return child instanceof HTMLElement && child.classList.contains(sortableClassName);
    });

    if (!children || children.length < 1) {
      return false;
    }

    if (typeof isActive === 'undefined') {
      isActive = !parentElement.classList.contains('sorting');
    }

    if (isActive) {
      parentElement.ondragover = function (e) {
        if (!canSort || !currentDraggedChild) {
          return;
        }

        var bodyRect = document.body.getBoundingClientRect();

        _.each(children, function (i, sibling) {
          if (sibling === currentDraggedChild || !canSort || e.pageY < 1) {
            return;
          }

          var cursorY = e.pageY;
          var childY = currentDraggedChild.getBoundingClientRect().y - bodyRect.y;
          var siblingY = sibling.getBoundingClientRect().y - bodyRect.y;
          var hasMoved = false; // Dragging above a sibling

          if (cursorY < siblingY && childY > siblingY) {
            sibling.parentElement.insertBefore(currentDraggedChild, sibling);
            hasMoved = true;
          } // Dragging below a sibling


          if (cursorY > siblingY && childY < siblingY) {
            sibling.parentElement.insertBefore(currentDraggedChild, sibling.nextElementSibling);
            hasMoved = true;
          } // Init transition


          if (hasMoved) {
            canSort = false;
            var newChildY = currentDraggedChild.getBoundingClientRect().y - document.body.getBoundingClientRect().y;
            var newSiblingY = sibling.getBoundingClientRect().y - document.body.getBoundingClientRect().y;
            currentDraggedChild.style.transform = 'translateY(' + (childY - newChildY) + 'px)';
            sibling.style.transform = 'translateY(' + (siblingY - newSiblingY) + 'px)';
            setTimeout(function () {
              currentDraggedChild.removeAttribute('style');
              sibling.removeAttribute('style');
              canSort = true;
            }, 100);
          }
        });
      };
    } else {
      parentElement.ondragover = null;
    }

    _.each(children, function (i, child) {
      child.draggable = isActive;

      if (isActive) {
        child.ondragstart = function (e) {
          e.dataTransfer.setData('text/plain', '');
          child.classList.toggle('dragging', true);
          currentDraggedChild = child;
        };

        child.ondragend = function (e) {
          onChange(child);
          currentDraggedChild = null;
          child.classList.toggle('dragging', false);
        };

        child.ondragcancel = function (e) {
          onChange(child);
          currentDraggedChild = null;
          child.classList.toggle('dragging', false);
        };
      } else {
        child.classList.toggle('dragging', false);
        child.ondragstart = null;
        child.ondrag = null;
        child.ondragstop = null;
        child.ondragcancel = null;
        currentDraggedChild = null;
      }
    });

    parentElement.classList.toggle('sorting', isActive);
    return true;
  };
  /**
   * Creates a switch
   *
   * @param {Boolean} initialValue
   * @param {Function} onChange
   *
   * @returns {HTMLElement} Switch element
   */


  UIHelper.inputSwitch = function inputSwitch(initialValue, onChange) {
    var id = 'switch-' + (10000 + Math.floor(Math.random() * 10000));
    var $input;

    var $element = _.div({
      class: 'switch',
      'data-checked': initialValue
    }, $input = _.input({
      id: id,
      class: 'form-control switch',
      type: 'checkbox'
    }).change(function () {
      this.parentElement.dataset.checked = this.checked;

      if (onChange) {
        onChange(this.checked);
      }
    }), _.label({
      for: id
    }));

    $element.on('set', function (e, newValue) {
      $input[0].checked = newValue;
    });

    if (initialValue) {
      $input.attr('checked', true);
    }

    return $element;
  };
  /**
   * Creates a group of chips
   *
   * @param {Array} items
   * @param {Array} dropdownItems
   * @param {Function} onChange
   * @param {Boolean} isDropdownUnique
   *
   * @returns {HtmlElement} Chip group element
   */


  UIHelper.inputChipGroup = function inputChipGroup(items, dropdownItems, onChange, isDropdownUnique) {
    var $element = _.div({
      class: 'chip-group'
    });

    if (!items) {
      items = [];
    }

    function render() {
      _.append($element.empty(), // Render individual chips
      _.each(items, function (itemIndex, item) {
        var label = item.label || item.name || item.title;

        if (!label) {
          for (var _iterator = dropdownItems, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i2 >= _iterator.length) break;
              _ref = _iterator[_i2++];
            } else {
              _i2 = _iterator.next();
              if (_i2.done) break;
              _ref = _i2.value;
            }

            var dropdownItem = _ref;
            var value = dropdownItem.id || dropdownItem.value || dropdownItem;

            if (value === item) {
              label = dropdownItem.label || dropdownItem.name || dropdownItem.title || dropdownItem;
            }
          }
        }

        if (!label) {
          label = item;
        }

        var $chip = _.div({
          class: 'chip'
        }, // Dropdown
        _.if(Array.isArray(dropdownItems), _.div({
          class: 'chip-label dropdown'
        }, _.button({
          class: 'dropdown-toggle',
          'data-toggle': 'dropdown'
        }, label), _.if(onChange, _.ul({
          class: 'dropdown-menu'
        }, _.each(dropdownItems, function (dropdownItemIndex, dropdownItem) {
          // Look for unique dropdown items
          if (isDropdownUnique) {
            for (var _iterator2 = items, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
              var _ref2;

              if (_isArray2) {
                if (_i3 >= _iterator2.length) break;
                _ref2 = _iterator2[_i3++];
              } else {
                _i3 = _iterator2.next();
                if (_i3.done) break;
                _ref2 = _i3.value;
              }

              var _item = _ref2;

              if (_item == dropdownItem) {
                return;
              }
            }
          }

          return _.li(_.a({
            href: '#'
          }, dropdownItem.label || dropdownItem.name || dropdownItem.title || dropdownItem).click(function (e) {
            e.preventDefault();
            items[itemIndex] = dropdownItem.value || dropdownItem.id || dropdownItem;
            render();

            if (typeof onChange === 'function') {
              onChange(items);
            }
          }));
        }))))), // Regular string
        _.if(!Array.isArray(dropdownItems), _.if(!onChange, _.p({
          class: 'chip-label'
        }, item)), _.if(onChange, _.input({
          type: 'text',
          class: 'chip-label',
          value: item
        }).change(function (e) {
          items[itemIndex] = e.target.value;
        }))), // Remove button
        _.if(onChange, _.button({
          class: 'btn chip-remove'
        }, _.span({
          class: 'fa fa-remove'
        })).click(function () {
          items.splice(itemIndex, 1);
          render();

          if (typeof onChange === 'function') {
            onChange(items);
          }
        })));

        return $chip;
      }), // Add button
      _.if(onChange, _.button({
        class: 'btn chip-add'
      }, _.span({
        class: 'fa fa-plus'
      })).click(function () {
        if (Array.isArray(dropdownItems)) {
          if (isDropdownUnique) {
            for (var _iterator3 = dropdownItems, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
              var _ref3;

              if (_isArray3) {
                if (_i4 >= _iterator3.length) break;
                _ref3 = _iterator3[_i4++];
              } else {
                _i4 = _iterator3.next();
                if (_i4.done) break;
                _ref3 = _i4.value;
              }

              var dropdownItem = _ref3;
              var isSelected = false;

              for (var _iterator4 = items, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray4) {
                  if (_i5 >= _iterator4.length) break;
                  _ref4 = _iterator4[_i5++];
                } else {
                  _i5 = _iterator4.next();
                  if (_i5.done) break;
                  _ref4 = _i5.value;
                }

                var item = _ref4;

                if (item == dropdownItem) {
                  isSelected = true;
                  break;
                }
              }

              if (!isSelected) {
                items.push(dropdownItem.value || dropdownItem);
                break;
              }
            }
          } else {
            items.push(dropdownItems[0].value || dropdownItems[0]);
          }
        } else if (typeof dropdownItems === 'string') {
          items.push(dropdownItems);
        } else {
          items.push('New item');
        }

        render();

        if (typeof onChange === 'function') {
          onChange(items);
        }
      })));
    }

    ;
    render();
    return $element;
  };
  /**
   * Renders a carousel
   *
   * @param {Array} items
   * @param {Boolean} useIndicators
   * @param {Boolean} useControls
   * @param {String} height
   *
   * @returns {HtmlElement} Carousel element
   */


  UIHelper.carousel = function carousel(items, useIndicators, useControls, height) {
    var id = 'carousel-' + (10000 + Math.floor(Math.random() * 10000));
    return _.div({
      class: 'carousel slide',
      id: id,
      'data-ride': 'carousel',
      'data-interval': 0
    }, _.if(useIndicators, _.ol({
      class: 'carousel-indicators'
    }, _.each(items, function (i, item) {
      return _.li({
        'data-target': '#' + id,
        'data-slide-to': i,
        class: i == 0 ? 'active' : ''
      });
    }))), _.div({
      class: 'carousel-inner',
      role: 'listbox'
    }, _.each(items, function (i, item) {
      return _.div({
        class: 'item' + (i == 0 ? ' active' : ''),
        style: 'height:' + (height || '500px')
      }, item);
    })), _.if(useControls, _.a({
      href: '#' + id,
      role: 'button',
      class: 'left carousel-control',
      'data-slide': 'prev'
    }, _.span({
      class: 'fa fa-arrow-left'
    })), _.a({
      href: '#' + id,
      role: 'button',
      class: 'right carousel-control',
      'data-slide': 'next'
    }, _.span({
      class: 'fa fa-arrow-right'
    }))));
  };
  /**
   * Brings up an error modal
   *
   * @param {String|Error} error
   * @param {Function} onClickOK
   */


  UIHelper.errorModal = function errorModal(error, onClickOK) {
    if (!error) {
      return;
    }

    if (error instanceof String) {
      error = new Error(error);
    } else if (error instanceof Object) {
      if (error.responseText) {
        error = new Error(error.responseText);
      }
    } else if (error instanceof Error == false) {
      error = new Error(error.toString());
    }

    console.log(error.stack);
    return UIHelper.messageModal('<span class="fa fa-warning"></span> Error', error.message, onClickOK, 'error');
  };
  /**
   * Brings up a warning modal
   *
   * @param {String} warning
   * @param {Function} onClickOK
   */


  UIHelper.warningModal = function warningModal(warning, onClickOK) {
    if (!warning) {
      return;
    }

    return UIHelper.messageModal('<span class="fa fa-warning"></span> Warning', warning, onClickOK, 'warning');
  };
  /**
   * Brings up a message modal
   *
   * @param {String} title
   * @param {String} body
   * @param {Function} onClickOK
   * @param {String} group
   */


  UIHelper.messageModal = function messageModal(title, body, onClickOK, group) {
    var modal = new HashBrown.Views.Modals.Modal({
      isBlocking: onClickOK === false,
      title: title,
      group: group,
      body: body
    });

    if (onClickOK) {
      modal.on('ok', onClickOK);
    }

    return modal;
  };
  /**
   * Brings up an iframe modal
   *
   * @param {String} title
   * @param {String} url
   * @param {Function} onSubmit
   * @param {Function} onCancel
   */


  UIHelper.iframeModal = function iframeModal(title, url, onSubmit, onCancel) {
    var modal = new HashBrown.Views.Modals.IframeModal({
      title: title,
      url: url
    });

    if (typeof onSubmit === 'function') {
      modal.on('ok', onSubmit);
    }

    if (typeof onCancel === 'function') {
      modal.on('cancel', onCancel);
    }

    return modal;
  };
  /**
   * Brings up a confirm modal
   *
   * @param {String} type
   * @param {String} title
   * @param {String} body
   * @param {Function} onSubmit
   */


  UIHelper.confirmModal = function confirmModal(type, title, body, onSubmit, onCancel) {
    var modal = new HashBrown.Views.Modals.ConfirmModal({
      type: type ? type.toLowerCase() : null,
      title: title,
      body: body
    });
    modal.on('cancel', onCancel);
    modal.on('ok', onSubmit);
    return modal;
  };
  /**
   * Creates a context menu
   */


  UIHelper.context = function context(element, items) {
    var openContextMenu = function openContextMenu(e) {
      // Find any existing context menu targets and remove their classes
      var clearTargets = function clearTargets() {
        var targets = document.querySelectorAll('.context-menu-target');

        if (targets) {
          for (var i = 0; i < targets.length; i++) {
            targets[i].classList.remove('context-menu-target');
          }
        }
      };

      clearTargets(); // Set new target

      element.classList.toggle('context-menu-target', true); // Remove existing dropdowns

      var existingMenu = _.find('.widget--dropdown.context-menu');

      if (existingMenu) {
        existingMenu.remove();
      } // Init new dropdown


      var dropdown = new HashBrown.Views.Widgets.Dropdown({
        options: items,
        reverseKeys: true,
        onChange: function onChange(pickedItem) {
          if (typeof pickedItem !== 'function') {
            return;
          }

          pickedItem();
        }
      }); // Prevent the toggle button from blocking new context menu events

      var toggle = dropdown.element.querySelector('.widget--dropdown__toggle');
      toggle.addEventListener('contextmenu', function (e) {
        e.preventDefault();
        dropdown.toggle(false);
      }); // Set cancel event

      dropdown.on('cancel', function () {
        dropdown.remove(); // Wait a bit before removing the classes, as they are often used as references in the functions executed by the context menu

        setTimeout(function () {
          clearTargets();
        }, 100);
      }); // Set styles

      dropdown.element.classList.toggle('context-menu', true);
      dropdown.element.style.top = e.touches ? e.touches[0].pageY : e.pageY;
      dropdown.element.style.left = e.touches ? e.touches[0].pageX : e.pageX; // Open it

      dropdown.toggle(true); // Append to body

      document.body.appendChild(dropdown.element);
    };

    element.addEventListener('contextmenu', function (e) {
      e.preventDefault();
      e.stopPropagation();
      openContextMenu(e);
    });
    element.addEventListener('click', function (e) {
      if (e.which === 3 || e.ctrlKey) {
        e.preventDefault();
        e.stopPropagation();
        openContextMenu(e);
      }
    });
    element.addEventListener('touchstart', function (e) {
      if (e.touchTargets && e.touchTargets.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        openContextMenu(e);
      }
    });
  };

  return UIHelper;
}();

module.exports = UIHelper;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

window.Promise = __webpack_require__(266);
window.marked = __webpack_require__(267);

var ProjectHelper = __webpack_require__(7);

var User = __webpack_require__(197);
/**
 * Converts a string from HTML to markdown
 *
 * @return {String} Markdown
 */


window.toMarkdown = function toMarkdown(html) {
  return HashBrown.Helpers.MarkdownHelper.fromHtml(html);
};
/**
 * Checks if the currently logged in user is admin
 *
 * @returns {Boolean} Is admin
 */


window.currentUserIsAdmin = function isCurrentUserAdmin() {
  return User.current.isAdmin;
};
/**
 * Checks if the currently logged in user has a certain scope
 *
 * @param {String} scope
 *
 * @returns {Boolean} Has scope
 */


window.currentUserHasScope = function currentUsr(scope) {
  return User.current.hasScope(ProjectHelper.currentProject, scope);
};
/**
 * Gets a cookie by name
 *
 * @param {String} name
 *
 * @returns {String} value
 */


window.getCookie = function getCookie(name) {
  var value = "; " + document.cookie;
  var parts = value.split("; " + name + "=");

  if (parts.length == 2) {
    return parts.pop().split(";").shift();
  }
};
/**
 * Copies string to the clipboard
 *
 * @param {String} string
 */


window.copyToClipboard = function copyToClipboard(string) {
  var text = document.createElement('TEXTAREA');
  text.innerHTML = string;
  document.body.appendChild(text);
  text.select();

  try {
    var success = document.execCommand('copy');

    if (!success) {
      UI.errorModal('Your browser does not yet support copying to clipboard');
    }
  } catch (e) {
    UI.errorModal(e.toString());
  }

  document.body.removeChild(text);
};
/**
 * Clears the workspace
 */


window.clearWorkspace = function clearWorkspace() {
  $('.workspace').empty();
};
/**
 * Sets workspace content
 */


window.populateWorkspace = function populateWorkspace($html, classes) {
  var $workspace = $('.page--environment__space--editor');
  $workspace.empty();
  $workspace.attr('class', 'page--environment__space--editor');

  _.append($workspace, $html);

  if (classes) {
    $workspace.addClass(classes);
  }
}; // Get package file


window.app = __webpack_require__(268); // Language

window.language = localStorage.getItem('language') || 'en';

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */

/**
 * bluebird build version 3.5.0
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function (e) {
  if (true) module.exports = e();else { var f; }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof _dereq_ == "function" && _dereq_;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }

        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }

      return n[o].exports;
    }

    var i = typeof _dereq_ == "function" && _dereq_;

    for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }

    return s;
  }({
    1: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise) {
        var SomePromiseArray = Promise._SomePromiseArray;

        function any(promises) {
          var ret = new SomePromiseArray(promises);
          var promise = ret.promise();
          ret.setHowMany(1);
          ret.setUnwrap();
          ret.init();
          return promise;
        }

        Promise.any = function (promises) {
          return any(promises);
        };

        Promise.prototype.any = function () {
          return any(this);
        };
      };
    }, {}],
    2: [function (_dereq_, module, exports) {
      "use strict";

      var firstLineError;

      try {
        throw new Error();
      } catch (e) {
        firstLineError = e;
      }

      var schedule = _dereq_("./schedule");

      var Queue = _dereq_("./queue");

      var util = _dereq_("./util");

      function Async() {
        this._customScheduler = false;
        this._isTickUsed = false;
        this._lateQueue = new Queue(16);
        this._normalQueue = new Queue(16);
        this._haveDrainedQueues = false;
        this._trampolineEnabled = true;
        var self = this;

        this.drainQueues = function () {
          self._drainQueues();
        };

        this._schedule = schedule;
      }

      Async.prototype.setScheduler = function (fn) {
        var prev = this._schedule;
        this._schedule = fn;
        this._customScheduler = true;
        return prev;
      };

      Async.prototype.hasCustomScheduler = function () {
        return this._customScheduler;
      };

      Async.prototype.enableTrampoline = function () {
        this._trampolineEnabled = true;
      };

      Async.prototype.disableTrampolineIfNecessary = function () {
        if (util.hasDevTools) {
          this._trampolineEnabled = false;
        }
      };

      Async.prototype.haveItemsQueued = function () {
        return this._isTickUsed || this._haveDrainedQueues;
      };

      Async.prototype.fatalError = function (e, isNode) {
        if (isNode) {
          process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
          process.exit(2);
        } else {
          this.throwLater(e);
        }
      };

      Async.prototype.throwLater = function (fn, arg) {
        if (arguments.length === 1) {
          arg = fn;

          fn = function fn() {
            throw arg;
          };
        }

        if (typeof setTimeout !== "undefined") {
          setTimeout(function () {
            fn(arg);
          }, 0);
        } else try {
          this._schedule(function () {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
      };

      function AsyncInvokeLater(fn, receiver, arg) {
        this._lateQueue.push(fn, receiver, arg);

        this._queueTick();
      }

      function AsyncInvoke(fn, receiver, arg) {
        this._normalQueue.push(fn, receiver, arg);

        this._queueTick();
      }

      function AsyncSettlePromises(promise) {
        this._normalQueue._pushOne(promise);

        this._queueTick();
      }

      if (!util.hasDevTools) {
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
      } else {
        Async.prototype.invokeLater = function (fn, receiver, arg) {
          if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
          } else {
            this._schedule(function () {
              setTimeout(function () {
                fn.call(receiver, arg);
              }, 100);
            });
          }
        };

        Async.prototype.invoke = function (fn, receiver, arg) {
          if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
          } else {
            this._schedule(function () {
              fn.call(receiver, arg);
            });
          }
        };

        Async.prototype.settlePromises = function (promise) {
          if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
          } else {
            this._schedule(function () {
              promise._settlePromises();
            });
          }
        };
      }

      Async.prototype._drainQueue = function (queue) {
        while (queue.length() > 0) {
          var fn = queue.shift();

          if (typeof fn !== "function") {
            fn._settlePromises();

            continue;
          }

          var receiver = queue.shift();
          var arg = queue.shift();
          fn.call(receiver, arg);
        }
      };

      Async.prototype._drainQueues = function () {
        this._drainQueue(this._normalQueue);

        this._reset();

        this._haveDrainedQueues = true;

        this._drainQueue(this._lateQueue);
      };

      Async.prototype._queueTick = function () {
        if (!this._isTickUsed) {
          this._isTickUsed = true;

          this._schedule(this.drainQueues);
        }
      };

      Async.prototype._reset = function () {
        this._isTickUsed = false;
      };

      module.exports = Async;
      module.exports.firstLineError = firstLineError;
    }, {
      "./queue": 26,
      "./schedule": 29,
      "./util": 36
    }],
    3: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {
        var calledBind = false;

        var rejectThis = function rejectThis(_, e) {
          this._reject(e);
        };

        var targetRejected = function targetRejected(e, context) {
          context.promiseRejectionQueued = true;

          context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
        };

        var bindingResolved = function bindingResolved(thisArg, context) {
          if ((this._bitField & 50397184) === 0) {
            this._resolveCallback(context.target);
          }
        };

        var bindingRejected = function bindingRejected(e, context) {
          if (!context.promiseRejectionQueued) this._reject(e);
        };

        Promise.prototype.bind = function (thisArg) {
          if (!calledBind) {
            calledBind = true;
            Promise.prototype._propagateFrom = debug.propagateFromFunction();
            Promise.prototype._boundValue = debug.boundValueFunction();
          }

          var maybePromise = tryConvertToPromise(thisArg);
          var ret = new Promise(INTERNAL);

          ret._propagateFrom(this, 1);

          var target = this._target();

          ret._setBoundTo(maybePromise);

          if (maybePromise instanceof Promise) {
            var context = {
              promiseRejectionQueued: false,
              promise: ret,
              target: target,
              bindingPromise: maybePromise
            };

            target._then(INTERNAL, targetRejected, undefined, ret, context);

            maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);

            ret._setOnCancel(maybePromise);
          } else {
            ret._resolveCallback(target);
          }

          return ret;
        };

        Promise.prototype._setBoundTo = function (obj) {
          if (obj !== undefined) {
            this._bitField = this._bitField | 2097152;
            this._boundTo = obj;
          } else {
            this._bitField = this._bitField & ~2097152;
          }
        };

        Promise.prototype._isBound = function () {
          return (this._bitField & 2097152) === 2097152;
        };

        Promise.bind = function (thisArg, value) {
          return Promise.resolve(value).bind(thisArg);
        };
      };
    }, {}],
    4: [function (_dereq_, module, exports) {
      "use strict";

      var old;
      if (typeof Promise !== "undefined") old = Promise;

      function noConflict() {
        try {
          if (Promise === bluebird) Promise = old;
        } catch (e) {}

        return bluebird;
      }

      var bluebird = _dereq_("./promise")();

      bluebird.noConflict = noConflict;
      module.exports = bluebird;
    }, {
      "./promise": 22
    }],
    5: [function (_dereq_, module, exports) {
      "use strict";

      var cr = Object.create;

      if (cr) {
        var callerCache = cr(null);
        var getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
      }

      module.exports = function (Promise) {
        var util = _dereq_("./util");

        var canEvaluate = util.canEvaluate;
        var isIdentifier = util.isIdentifier;
        var getMethodCaller;
        var getGetter;

        if (false) { var getCompiled, makeGetter, makeMethodCaller; }

        function ensureMethod(obj, methodName) {
          var fn;
          if (obj != null) fn = obj[methodName];

          if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
          }

          return fn;
        }

        function caller(obj) {
          var methodName = this.pop();
          var fn = ensureMethod(obj, methodName);
          return fn.apply(obj, this);
        }

        Promise.prototype.call = function (methodName) {
          var args = [].slice.call(arguments, 1);
          ;

          if (false) { var maybeCaller; }

          args.push(methodName);
          return this._then(caller, undefined, undefined, args, undefined);
        };

        function namedGetter(obj) {
          return obj[this];
        }

        function indexedGetter(obj) {
          var index = +this;
          if (index < 0) index = Math.max(0, index + obj.length);
          return obj[index];
        }

        Promise.prototype.get = function (propertyName) {
          var isIndex = typeof propertyName === "number";
          var getter;

          if (!isIndex) {
            if (canEvaluate) {
              var maybeGetter = getGetter(propertyName);
              getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
              getter = namedGetter;
            }
          } else {
            getter = indexedGetter;
          }

          return this._then(getter, undefined, undefined, propertyName, undefined);
        };
      };
    }, {
      "./util": 36
    }],
    6: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, apiRejection, debug) {
        var util = _dereq_("./util");

        var tryCatch = util.tryCatch;
        var errorObj = util.errorObj;
        var async = Promise._async;

        Promise.prototype["break"] = Promise.prototype.cancel = function () {
          if (!debug.cancellation()) return this._warn("cancellation is disabled");
          var promise = this;
          var child = promise;

          while (promise._isCancellable()) {
            if (!promise._cancelBy(child)) {
              if (child._isFollowing()) {
                child._followee().cancel();
              } else {
                child._cancelBranched();
              }

              break;
            }

            var parent = promise._cancellationParent;

            if (parent == null || !parent._isCancellable()) {
              if (promise._isFollowing()) {
                promise._followee().cancel();
              } else {
                promise._cancelBranched();
              }

              break;
            } else {
              if (promise._isFollowing()) promise._followee().cancel();

              promise._setWillBeCancelled();

              child = promise;
              promise = parent;
            }
          }
        };

        Promise.prototype._branchHasCancelled = function () {
          this._branchesRemainingToCancel--;
        };

        Promise.prototype._enoughBranchesHaveCancelled = function () {
          return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
        };

        Promise.prototype._cancelBy = function (canceller) {
          if (canceller === this) {
            this._branchesRemainingToCancel = 0;

            this._invokeOnCancel();

            return true;
          } else {
            this._branchHasCancelled();

            if (this._enoughBranchesHaveCancelled()) {
              this._invokeOnCancel();

              return true;
            }
          }

          return false;
        };

        Promise.prototype._cancelBranched = function () {
          if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
          }
        };

        Promise.prototype._cancel = function () {
          if (!this._isCancellable()) return;

          this._setCancelled();

          async.invoke(this._cancelPromises, this, undefined);
        };

        Promise.prototype._cancelPromises = function () {
          if (this._length() > 0) this._settlePromises();
        };

        Promise.prototype._unsetOnCancel = function () {
          this._onCancelField = undefined;
        };

        Promise.prototype._isCancellable = function () {
          return this.isPending() && !this._isCancelled();
        };

        Promise.prototype.isCancellable = function () {
          return this.isPending() && !this.isCancelled();
        };

        Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
          if (util.isArray(onCancelCallback)) {
            for (var i = 0; i < onCancelCallback.length; ++i) {
              this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
          } else if (onCancelCallback !== undefined) {
            if (typeof onCancelCallback === "function") {
              if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());

                if (e === errorObj) {
                  this._attachExtraTrace(e.e);

                  async.throwLater(e.e);
                }
              }
            } else {
              onCancelCallback._resultCancelled(this);
            }
          }
        };

        Promise.prototype._invokeOnCancel = function () {
          var onCancelCallback = this._onCancel();

          this._unsetOnCancel();

          async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
        };

        Promise.prototype._invokeInternalOnCancel = function () {
          if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);

            this._unsetOnCancel();
          }
        };

        Promise.prototype._resultCancelled = function () {
          this.cancel();
        };
      };
    }, {
      "./util": 36
    }],
    7: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (NEXT_FILTER) {
        var util = _dereq_("./util");

        var getKeys = _dereq_("./es5").keys;

        var tryCatch = util.tryCatch;
        var errorObj = util.errorObj;

        function catchFilter(instances, cb, promise) {
          return function (e) {
            var boundTo = promise._boundValue();

            predicateLoop: for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];

              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);

                if (matchesPredicate === errorObj) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch(cb).call(boundTo, e);
                }
              } else if (util.isObject(e)) {
                var keys = getKeys(item);

                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];

                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }

                return tryCatch(cb).call(boundTo, e);
              }
            }

            return NEXT_FILTER;
          };
        }

        return catchFilter;
      };
    }, {
      "./es5": 13,
      "./util": 36
    }],
    8: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise) {
        var longStackTraces = false;
        var contextStack = [];

        Promise.prototype._promiseCreated = function () {};

        Promise.prototype._pushContext = function () {};

        Promise.prototype._popContext = function () {
          return null;
        };

        Promise._peekContext = Promise.prototype._peekContext = function () {};

        function Context() {
          this._trace = new Context.CapturedTrace(peekContext());
        }

        Context.prototype._pushContext = function () {
          if (this._trace !== undefined) {
            this._trace._promiseCreated = null;
            contextStack.push(this._trace);
          }
        };

        Context.prototype._popContext = function () {
          if (this._trace !== undefined) {
            var trace = contextStack.pop();
            var ret = trace._promiseCreated;
            trace._promiseCreated = null;
            return ret;
          }

          return null;
        };

        function createContext() {
          if (longStackTraces) return new Context();
        }

        function peekContext() {
          var lastIndex = contextStack.length - 1;

          if (lastIndex >= 0) {
            return contextStack[lastIndex];
          }

          return undefined;
        }

        Context.CapturedTrace = null;
        Context.create = createContext;

        Context.deactivateLongStackTraces = function () {};

        Context.activateLongStackTraces = function () {
          var Promise_pushContext = Promise.prototype._pushContext;
          var Promise_popContext = Promise.prototype._popContext;
          var Promise_PeekContext = Promise._peekContext;
          var Promise_peekContext = Promise.prototype._peekContext;
          var Promise_promiseCreated = Promise.prototype._promiseCreated;

          Context.deactivateLongStackTraces = function () {
            Promise.prototype._pushContext = Promise_pushContext;
            Promise.prototype._popContext = Promise_popContext;
            Promise._peekContext = Promise_PeekContext;
            Promise.prototype._peekContext = Promise_peekContext;
            Promise.prototype._promiseCreated = Promise_promiseCreated;
            longStackTraces = false;
          };

          longStackTraces = true;
          Promise.prototype._pushContext = Context.prototype._pushContext;
          Promise.prototype._popContext = Context.prototype._popContext;
          Promise._peekContext = Promise.prototype._peekContext = peekContext;

          Promise.prototype._promiseCreated = function () {
            var ctx = this._peekContext();

            if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
          };
        };

        return Context;
      };
    }, {}],
    9: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, Context) {
        var getDomain = Promise._getDomain;
        var async = Promise._async;

        var Warning = _dereq_("./errors").Warning;

        var util = _dereq_("./util");

        var canAttachTrace = util.canAttachTrace;
        var unhandledRejectionHandled;
        var possiblyUnhandledRejection;
        var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
        var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
        var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
        var stackFramePattern = null;
        var formatStack = null;
        var indentStackFrames = false;
        var printWarning;
        var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && ( true || false));
        var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
        var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
        var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

        Promise.prototype.suppressUnhandledRejections = function () {
          var target = this._target();

          target._bitField = target._bitField & ~1048576 | 524288;
        };

        Promise.prototype._ensurePossibleRejectionHandled = function () {
          if ((this._bitField & 524288) !== 0) return;

          this._setRejectionIsUnhandled();

          async.invokeLater(this._notifyUnhandledRejection, this, undefined);
        };

        Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
          fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
        };

        Promise.prototype._setReturnedNonUndefined = function () {
          this._bitField = this._bitField | 268435456;
        };

        Promise.prototype._returnedNonUndefined = function () {
          return (this._bitField & 268435456) !== 0;
        };

        Promise.prototype._notifyUnhandledRejection = function () {
          if (this._isRejectionUnhandled()) {
            var reason = this._settledValue();

            this._setUnhandledRejectionIsNotified();

            fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
          }
        };

        Promise.prototype._setUnhandledRejectionIsNotified = function () {
          this._bitField = this._bitField | 262144;
        };

        Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
          this._bitField = this._bitField & ~262144;
        };

        Promise.prototype._isUnhandledRejectionNotified = function () {
          return (this._bitField & 262144) > 0;
        };

        Promise.prototype._setRejectionIsUnhandled = function () {
          this._bitField = this._bitField | 1048576;
        };

        Promise.prototype._unsetRejectionIsUnhandled = function () {
          this._bitField = this._bitField & ~1048576;

          if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();

            this._notifyUnhandledRejectionIsHandled();
          }
        };

        Promise.prototype._isRejectionUnhandled = function () {
          return (this._bitField & 1048576) > 0;
        };

        Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {
          return warn(message, shouldUseOwnTrace, promise || this);
        };

        Promise.onPossiblyUnhandledRejection = function (fn) {
          var domain = getDomain();
          possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
        };

        Promise.onUnhandledRejectionHandled = function (fn) {
          var domain = getDomain();
          unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
        };

        var disableLongStackTraces = function disableLongStackTraces() {};

        Promise.longStackTraces = function () {
          if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }

          if (!config.longStackTraces && longStackTracesIsSupported()) {
            var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
            var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
            config.longStackTraces = true;

            disableLongStackTraces = function disableLongStackTraces() {
              if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
              }

              Promise.prototype._captureStackTrace = Promise_captureStackTrace;
              Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
              Context.deactivateLongStackTraces();
              async.enableTrampoline();
              config.longStackTraces = false;
            };

            Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
            Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
            Context.activateLongStackTraces();
            async.disableTrampolineIfNecessary();
          }
        };

        Promise.hasLongStackTraces = function () {
          return config.longStackTraces && longStackTracesIsSupported();
        };

        var fireDomEvent = function () {
          try {
            if (typeof CustomEvent === "function") {
              var event = new CustomEvent("CustomEvent");
              util.global.dispatchEvent(event);
              return function (name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                  detail: event,
                  cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
              };
            } else if (typeof Event === "function") {
              var event = new Event("CustomEvent");
              util.global.dispatchEvent(event);
              return function (name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                  cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
              };
            } else {
              var event = document.createEvent("CustomEvent");
              event.initCustomEvent("testingtheevent", false, true, {});
              util.global.dispatchEvent(event);
              return function (name, event) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                return !util.global.dispatchEvent(domEvent);
              };
            }
          } catch (e) {}

          return function () {
            return false;
          };
        }();

        var fireGlobalEvent = function () {
          if (util.isNode) {
            return function () {
              return process.emit.apply(process, arguments);
            };
          } else {
            if (!util.global) {
              return function () {
                return false;
              };
            }

            return function (name) {
              var methodName = "on" + name.toLowerCase();
              var method = util.global[methodName];
              if (!method) return false;
              method.apply(util.global, [].slice.call(arguments, 1));
              return true;
            };
          }
        }();

        function generatePromiseLifecycleEventObject(name, promise) {
          return {
            promise: promise
          };
        }

        var eventToObjectGenerator = {
          promiseCreated: generatePromiseLifecycleEventObject,
          promiseFulfilled: generatePromiseLifecycleEventObject,
          promiseRejected: generatePromiseLifecycleEventObject,
          promiseResolved: generatePromiseLifecycleEventObject,
          promiseCancelled: generatePromiseLifecycleEventObject,
          promiseChained: function promiseChained(name, promise, child) {
            return {
              promise: promise,
              child: child
            };
          },
          warning: function warning(name, _warning) {
            return {
              warning: _warning
            };
          },
          unhandledRejection: function unhandledRejection(name, reason, promise) {
            return {
              reason: reason,
              promise: promise
            };
          },
          rejectionHandled: generatePromiseLifecycleEventObject
        };

        var activeFireEvent = function activeFireEvent(name) {
          var globalEventFired = false;

          try {
            globalEventFired = fireGlobalEvent.apply(null, arguments);
          } catch (e) {
            async.throwLater(e);
            globalEventFired = true;
          }

          var domEventFired = false;

          try {
            domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
          } catch (e) {
            async.throwLater(e);
            domEventFired = true;
          }

          return domEventFired || globalEventFired;
        };

        Promise.config = function (opts) {
          opts = Object(opts);

          if ("longStackTraces" in opts) {
            if (opts.longStackTraces) {
              Promise.longStackTraces();
            } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
              disableLongStackTraces();
            }
          }

          if ("warnings" in opts) {
            var warningsOption = opts.warnings;
            config.warnings = !!warningsOption;
            wForgottenReturn = config.warnings;

            if (util.isObject(warningsOption)) {
              if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
              }
            }
          }

          if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
            if (async.haveItemsQueued()) {
              throw new Error("cannot enable cancellation after promises are in use");
            }

            Promise.prototype._clearCancellationData = cancellationClearCancellationData;
            Promise.prototype._propagateFrom = cancellationPropagateFrom;
            Promise.prototype._onCancel = cancellationOnCancel;
            Promise.prototype._setOnCancel = cancellationSetOnCancel;
            Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
            Promise.prototype._execute = cancellationExecute;
            _propagateFromFunction = cancellationPropagateFrom;
            config.cancellation = true;
          }

          if ("monitoring" in opts) {
            if (opts.monitoring && !config.monitoring) {
              config.monitoring = true;
              Promise.prototype._fireEvent = activeFireEvent;
            } else if (!opts.monitoring && config.monitoring) {
              config.monitoring = false;
              Promise.prototype._fireEvent = defaultFireEvent;
            }
          }

          return Promise;
        };

        function defaultFireEvent() {
          return false;
        }

        Promise.prototype._fireEvent = defaultFireEvent;

        Promise.prototype._execute = function (executor, resolve, reject) {
          try {
            executor(resolve, reject);
          } catch (e) {
            return e;
          }
        };

        Promise.prototype._onCancel = function () {};

        Promise.prototype._setOnCancel = function (handler) {
          ;
        };

        Promise.prototype._attachCancellationCallback = function (onCancel) {
          ;
        };

        Promise.prototype._captureStackTrace = function () {};

        Promise.prototype._attachExtraTrace = function () {};

        Promise.prototype._clearCancellationData = function () {};

        Promise.prototype._propagateFrom = function (parent, flags) {
          ;
          ;
        };

        function cancellationExecute(executor, resolve, reject) {
          var promise = this;

          try {
            executor(resolve, reject, function (onCancel) {
              if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
              }

              promise._attachCancellationCallback(onCancel);
            });
          } catch (e) {
            return e;
          }
        }

        function cancellationAttachCancellationCallback(onCancel) {
          if (!this._isCancellable()) return this;

          var previousOnCancel = this._onCancel();

          if (previousOnCancel !== undefined) {
            if (util.isArray(previousOnCancel)) {
              previousOnCancel.push(onCancel);
            } else {
              this._setOnCancel([previousOnCancel, onCancel]);
            }
          } else {
            this._setOnCancel(onCancel);
          }
        }

        function cancellationOnCancel() {
          return this._onCancelField;
        }

        function cancellationSetOnCancel(onCancel) {
          this._onCancelField = onCancel;
        }

        function cancellationClearCancellationData() {
          this._cancellationParent = undefined;
          this._onCancelField = undefined;
        }

        function cancellationPropagateFrom(parent, flags) {
          if ((flags & 1) !== 0) {
            this._cancellationParent = parent;
            var branchesRemainingToCancel = parent._branchesRemainingToCancel;

            if (branchesRemainingToCancel === undefined) {
              branchesRemainingToCancel = 0;
            }

            parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
          }

          if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
          }
        }

        function bindingPropagateFrom(parent, flags) {
          if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
          }
        }

        var _propagateFromFunction = bindingPropagateFrom;

        function _boundValueFunction() {
          var ret = this._boundTo;

          if (ret !== undefined) {
            if (ret instanceof Promise) {
              if (ret.isFulfilled()) {
                return ret.value();
              } else {
                return undefined;
              }
            }
          }

          return ret;
        }

        function longStackTracesCaptureStackTrace() {
          this._trace = new CapturedTrace(this._peekContext());
        }

        function longStackTracesAttachExtraTrace(error, ignoreSelf) {
          if (canAttachTrace(error)) {
            var trace = this._trace;

            if (trace !== undefined) {
              if (ignoreSelf) trace = trace._parent;
            }

            if (trace !== undefined) {
              trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
              var parsed = parseStackAndMessage(error);
              util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
              util.notEnumerableProp(error, "__stackCleaned__", true);
            }
          }
        }

        function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
          if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
            if (parent !== undefined && parent._returnedNonUndefined()) return;
            if ((promise._bitField & 65535) === 0) return;
            if (name) name = name + " ";
            var handlerLine = "";
            var creatorLine = "";

            if (promiseCreated._trace) {
              var traceLines = promiseCreated._trace.stack.split("\n");

              var stack = cleanStack(traceLines);

              for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];

                if (!nodeFramePattern.test(line)) {
                  var lineMatches = line.match(parseLinePattern);

                  if (lineMatches) {
                    handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                  }

                  break;
                }
              }

              if (stack.length > 0) {
                var firstUserLine = stack[0];

                for (var i = 0; i < traceLines.length; ++i) {
                  if (traceLines[i] === firstUserLine) {
                    if (i > 0) {
                      creatorLine = "\n" + traceLines[i - 1];
                    }

                    break;
                  }
                }
              }
            }

            var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;

            promise._warn(msg, true, promiseCreated);
          }
        }

        function deprecated(name, replacement) {
          var message = name + " is deprecated and will be removed in a future version.";
          if (replacement) message += " Use " + replacement + " instead.";
          return warn(message);
        }

        function warn(message, shouldUseOwnTrace, promise) {
          if (!config.warnings) return;
          var warning = new Warning(message);
          var ctx;

          if (shouldUseOwnTrace) {
            promise._attachExtraTrace(warning);
          } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
            ctx.attachExtraTrace(warning);
          } else {
            var parsed = parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
          }

          if (!activeFireEvent("warning", warning)) {
            formatAndLogError(warning, "", true);
          }
        }

        function reconstructStack(message, stacks) {
          for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
          }

          if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
          }

          return message + "\n" + stacks.join("\n");
        }

        function removeDuplicateOrEmptyJumps(stacks) {
          for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
              stacks.splice(i, 1);
              i--;
            }
          }
        }

        function removeCommonRoots(stacks) {
          var current = stacks[0];

          for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;

            for (var j = prev.length - 1; j >= 0; --j) {
              if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
              }
            }

            for (var j = commonRootMeetPoint; j >= 0; --j) {
              var line = prev[j];

              if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
              } else {
                break;
              }
            }

            current = prev;
          }
        }

        function cleanStack(stack) {
          var ret = [];

          for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
            var isInternalFrame = isTraceLine && shouldIgnore(line);

            if (isTraceLine && !isInternalFrame) {
              if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
              }

              ret.push(line);
            }
          }

          return ret;
        }

        function stackFramesAsArray(error) {
          var stack = error.stack.replace(/\s+$/g, "").split("\n");

          for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];

            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
              break;
            }
          }

          if (i > 0 && error.name != "SyntaxError") {
            stack = stack.slice(i);
          }

          return stack;
        }

        function parseStackAndMessage(error) {
          var stack = error.stack;
          var message = error.toString();
          stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
          return {
            message: message,
            stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
          };
        }

        function formatAndLogError(error, title, isSoft) {
          if (typeof console !== "undefined") {
            var message;

            if (util.isObject(error)) {
              var stack = error.stack;
              message = title + formatStack(stack, error);
            } else {
              message = title + String(error);
            }

            if (typeof printWarning === "function") {
              printWarning(message, isSoft);
            } else if (typeof console.log === "function" || typeof console.log === "object") {
              console.log(message);
            }
          }
        }

        function fireRejectionEvent(name, localHandler, reason, promise) {
          var localEventFired = false;

          try {
            if (typeof localHandler === "function") {
              localEventFired = true;

              if (name === "rejectionHandled") {
                localHandler(promise);
              } else {
                localHandler(reason, promise);
              }
            }
          } catch (e) {
            async.throwLater(e);
          }

          if (name === "unhandledRejection") {
            if (!activeFireEvent(name, reason, promise) && !localEventFired) {
              formatAndLogError(reason, "Unhandled rejection ");
            }
          } else {
            activeFireEvent(name, promise);
          }
        }

        function formatNonError(obj) {
          var str;

          if (typeof obj === "function") {
            str = "[function " + (obj.name || "anonymous") + "]";
          } else {
            str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;

            if (ruselessToString.test(str)) {
              try {
                var newStr = JSON.stringify(obj);
                str = newStr;
              } catch (e) {}
            }

            if (str.length === 0) {
              str = "(empty array)";
            }
          }

          return "(<" + snip(str) + ">, no stack trace)";
        }

        function snip(str) {
          var maxChars = 41;

          if (str.length < maxChars) {
            return str;
          }

          return str.substr(0, maxChars - 3) + "...";
        }

        function longStackTracesIsSupported() {
          return typeof captureStackTrace === "function";
        }

        var shouldIgnore = function shouldIgnore() {
          return false;
        };

        var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;

        function parseLineInfo(line) {
          var matches = line.match(parseLineInfoRegex);

          if (matches) {
            return {
              fileName: matches[1],
              line: parseInt(matches[2], 10)
            };
          }
        }

        function setBounds(firstLineError, lastLineError) {
          if (!longStackTracesIsSupported()) return;
          var firstStackLines = firstLineError.stack.split("\n");
          var lastStackLines = lastLineError.stack.split("\n");
          var firstIndex = -1;
          var lastIndex = -1;
          var firstFileName;
          var lastFileName;

          for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);

            if (result) {
              firstFileName = result.fileName;
              firstIndex = result.line;
              break;
            }
          }

          for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);

            if (result) {
              lastFileName = result.fileName;
              lastIndex = result.line;
              break;
            }
          }

          if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
          }

          shouldIgnore = function shouldIgnore(line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);

            if (info) {
              if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                return true;
              }
            }

            return false;
          };
        }

        function CapturedTrace(parent) {
          this._parent = parent;
          this._promisesCreated = 0;
          var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
          captureStackTrace(this, CapturedTrace);
          if (length > 32) this.uncycle();
        }

        util.inherits(CapturedTrace, Error);
        Context.CapturedTrace = CapturedTrace;

        CapturedTrace.prototype.uncycle = function () {
          var length = this._length;
          if (length < 2) return;
          var nodes = [];
          var stackToIndex = {};

          for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
          }

          length = this._length = i;

          for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;

            if (stackToIndex[stack] === undefined) {
              stackToIndex[stack] = i;
            }
          }

          for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];

            if (index !== undefined && index !== i) {
              if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
              }

              nodes[i]._parent = undefined;
              nodes[i]._length = 1;
              var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

              if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];

                cycleEdgeNode._parent.uncycle();

                cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
              } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
              }

              var currentChildLength = cycleEdgeNode._length + 1;

              for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
              }

              return;
            }
          }
        };

        CapturedTrace.prototype.attachExtraTrace = function (error) {
          if (error.__stackCleaned__) return;
          this.uncycle();
          var parsed = parseStackAndMessage(error);
          var message = parsed.message;
          var stacks = [parsed.stack];
          var trace = this;

          while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
          }

          removeCommonRoots(stacks);
          removeDuplicateOrEmptyJumps(stacks);
          util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
          util.notEnumerableProp(error, "__stackCleaned__", true);
        };

        var captureStackTrace = function stackDetection() {
          var v8stackFramePattern = /^\s*at\s*/;

          var v8stackFormatter = function v8stackFormatter(stack, error) {
            if (typeof stack === "string") return stack;

            if (error.name !== undefined && error.message !== undefined) {
              return error.toString();
            }

            return formatNonError(error);
          };

          if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit += 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;

            shouldIgnore = function shouldIgnore(line) {
              return bluebirdFramePattern.test(line);
            };

            return function (receiver, ignoreUntil) {
              Error.stackTraceLimit += 6;
              captureStackTrace(receiver, ignoreUntil);
              Error.stackTraceLimit -= 6;
            };
          }

          var err = new Error();

          if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
              o.stack = new Error().stack;
            };
          }

          var hasStackAfterThrow;

          try {
            throw new Error();
          } catch (e) {
            hasStackAfterThrow = "stack" in e;
          }

          if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
              Error.stackTraceLimit += 6;

              try {
                throw new Error();
              } catch (e) {
                o.stack = e.stack;
              }

              Error.stackTraceLimit -= 6;
            };
          }

          formatStack = function formatStack(stack, error) {
            if (typeof stack === "string") return stack;

            if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
              return error.toString();
            }

            return formatNonError(error);
          };

          return null;
        }([]);

        if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
          printWarning = function printWarning(message) {
            console.warn(message);
          };

          if (util.isNode && process.stderr.isTTY) {
            printWarning = function printWarning(message, isSoft) {
              var color = isSoft ? "\x1B[33m" : "\x1B[31m";
              console.warn(color + message + "\x1B[0m\n");
            };
          } else if (!util.isNode && typeof new Error().stack === "string") {
            printWarning = function printWarning(message, isSoft) {
              console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
            };
          }
        }

        var config = {
          warnings: warnings,
          longStackTraces: false,
          cancellation: false,
          monitoring: false
        };
        if (longStackTraces) Promise.longStackTraces();
        return {
          longStackTraces: function longStackTraces() {
            return config.longStackTraces;
          },
          warnings: function warnings() {
            return config.warnings;
          },
          cancellation: function cancellation() {
            return config.cancellation;
          },
          monitoring: function monitoring() {
            return config.monitoring;
          },
          propagateFromFunction: function propagateFromFunction() {
            return _propagateFromFunction;
          },
          boundValueFunction: function boundValueFunction() {
            return _boundValueFunction;
          },
          checkForgottenReturns: checkForgottenReturns,
          setBounds: setBounds,
          warn: warn,
          deprecated: deprecated,
          CapturedTrace: CapturedTrace,
          fireDomEvent: fireDomEvent,
          fireGlobalEvent: fireGlobalEvent
        };
      };
    }, {
      "./errors": 12,
      "./util": 36
    }],
    10: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise) {
        function returner() {
          return this.value;
        }

        function thrower() {
          throw this.reason;
        }

        Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
          if (value instanceof Promise) value.suppressUnhandledRejections();
          return this._then(returner, undefined, undefined, {
            value: value
          }, undefined);
        };

        Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
          return this._then(thrower, undefined, undefined, {
            reason: reason
          }, undefined);
        };

        Promise.prototype.catchThrow = function (reason) {
          if (arguments.length <= 1) {
            return this._then(undefined, thrower, undefined, {
              reason: reason
            }, undefined);
          } else {
            var _reason = arguments[1];

            var handler = function handler() {
              throw _reason;
            };

            return this.caught(reason, handler);
          }
        };

        Promise.prototype.catchReturn = function (value) {
          if (arguments.length <= 1) {
            if (value instanceof Promise) value.suppressUnhandledRejections();
            return this._then(undefined, returner, undefined, {
              value: value
            }, undefined);
          } else {
            var _value = arguments[1];
            if (_value instanceof Promise) _value.suppressUnhandledRejections();

            var handler = function handler() {
              return _value;
            };

            return this.caught(value, handler);
          }
        };
      };
    }, {}],
    11: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL) {
        var PromiseReduce = Promise.reduce;
        var PromiseAll = Promise.all;

        function promiseAllThis() {
          return PromiseAll(this);
        }

        function PromiseMapSeries(promises, fn) {
          return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
        }

        Promise.prototype.each = function (fn) {
          return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
        };

        Promise.prototype.mapSeries = function (fn) {
          return PromiseReduce(this, fn, INTERNAL, INTERNAL);
        };

        Promise.each = function (promises, fn) {
          return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
        };

        Promise.mapSeries = PromiseMapSeries;
      };
    }, {}],
    12: [function (_dereq_, module, exports) {
      "use strict";

      var es5 = _dereq_("./es5");

      var Objectfreeze = es5.freeze;

      var util = _dereq_("./util");

      var inherits = util.inherits;
      var notEnumerableProp = util.notEnumerableProp;

      function subError(nameProperty, defaultMessage) {
        function SubError(message) {
          if (!(this instanceof SubError)) return new SubError(message);
          notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
          notEnumerableProp(this, "name", nameProperty);

          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            Error.call(this);
          }
        }

        inherits(SubError, Error);
        return SubError;
      }

      var _TypeError, _RangeError;

      var Warning = subError("Warning", "warning");
      var CancellationError = subError("CancellationError", "cancellation error");
      var TimeoutError = subError("TimeoutError", "timeout error");
      var AggregateError = subError("AggregateError", "aggregate error");

      try {
        _TypeError = TypeError;
        _RangeError = RangeError;
      } catch (e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
      }

      var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

      for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
          AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
      }

      es5.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
      });
      AggregateError.prototype["isOperational"] = true;
      var level = 0;

      AggregateError.prototype.toString = function () {
        var indent = Array(level * 4 + 1).join(" ");
        var ret = "\n" + indent + "AggregateError of:" + "\n";
        level++;
        indent = Array(level * 4 + 1).join(" ");

        for (var i = 0; i < this.length; ++i) {
          var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
          var lines = str.split("\n");

          for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
          }

          str = lines.join("\n");
          ret += str + "\n";
        }

        level--;
        return ret;
      };

      function OperationalError(message) {
        if (!(this instanceof OperationalError)) return new OperationalError(message);
        notEnumerableProp(this, "name", "OperationalError");
        notEnumerableProp(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;

        if (message instanceof Error) {
          notEnumerableProp(this, "message", message.message);
          notEnumerableProp(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }

      inherits(OperationalError, Error);
      var errorTypes = Error["__BluebirdErrorTypes__"];

      if (!errorTypes) {
        errorTypes = Objectfreeze({
          CancellationError: CancellationError,
          TimeoutError: TimeoutError,
          OperationalError: OperationalError,
          RejectionError: OperationalError,
          AggregateError: AggregateError
        });
        es5.defineProperty(Error, "__BluebirdErrorTypes__", {
          value: errorTypes,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }

      module.exports = {
        Error: Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning: Warning
      };
    }, {
      "./es5": 13,
      "./util": 36
    }],
    13: [function (_dereq_, module, exports) {
      var isES5 = function () {
        "use strict";

        return this === undefined;
      }();

      if (isES5) {
        module.exports = {
          freeze: Object.freeze,
          defineProperty: Object.defineProperty,
          getDescriptor: Object.getOwnPropertyDescriptor,
          keys: Object.keys,
          names: Object.getOwnPropertyNames,
          getPrototypeOf: Object.getPrototypeOf,
          isArray: Array.isArray,
          isES5: isES5,
          propertyIsWritable: function propertyIsWritable(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
          }
        };
      } else {
        var has = {}.hasOwnProperty;
        var str = {}.toString;
        var proto = {}.constructor.prototype;

        var ObjectKeys = function ObjectKeys(o) {
          var ret = [];

          for (var key in o) {
            if (has.call(o, key)) {
              ret.push(key);
            }
          }

          return ret;
        };

        var ObjectGetDescriptor = function ObjectGetDescriptor(o, key) {
          return {
            value: o[key]
          };
        };

        var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {
          o[key] = desc.value;
          return o;
        };

        var ObjectFreeze = function ObjectFreeze(obj) {
          return obj;
        };

        var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {
          try {
            return Object(obj).constructor.prototype;
          } catch (e) {
            return proto;
          }
        };

        var ArrayIsArray = function ArrayIsArray(obj) {
          try {
            return str.call(obj) === "[object Array]";
          } catch (e) {
            return false;
          }
        };

        module.exports = {
          isArray: ArrayIsArray,
          keys: ObjectKeys,
          names: ObjectKeys,
          defineProperty: ObjectDefineProperty,
          getDescriptor: ObjectGetDescriptor,
          freeze: ObjectFreeze,
          getPrototypeOf: ObjectGetPrototypeOf,
          isES5: isES5,
          propertyIsWritable: function propertyIsWritable() {
            return true;
          }
        };
      }
    }, {}],
    14: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL) {
        var PromiseMap = Promise.map;

        Promise.prototype.filter = function (fn, options) {
          return PromiseMap(this, fn, options, INTERNAL);
        };

        Promise.filter = function (promises, fn, options) {
          return PromiseMap(promises, fn, options, INTERNAL);
        };
      };
    }, {}],
    15: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {
        var util = _dereq_("./util");

        var CancellationError = Promise.CancellationError;
        var errorObj = util.errorObj;

        var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

        function PassThroughHandlerContext(promise, type, handler) {
          this.promise = promise;
          this.type = type;
          this.handler = handler;
          this.called = false;
          this.cancelPromise = null;
        }

        PassThroughHandlerContext.prototype.isFinallyHandler = function () {
          return this.type === 0;
        };

        function FinallyHandlerCancelReaction(finallyHandler) {
          this.finallyHandler = finallyHandler;
        }

        FinallyHandlerCancelReaction.prototype._resultCancelled = function () {
          checkCancel(this.finallyHandler);
        };

        function checkCancel(ctx, reason) {
          if (ctx.cancelPromise != null) {
            if (arguments.length > 1) {
              ctx.cancelPromise._reject(reason);
            } else {
              ctx.cancelPromise._cancel();
            }

            ctx.cancelPromise = null;
            return true;
          }

          return false;
        }

        function succeed() {
          return finallyHandler.call(this, this.promise._target()._settledValue());
        }

        function fail(reason) {
          if (checkCancel(this, reason)) return;
          errorObj.e = reason;
          return errorObj;
        }

        function finallyHandler(reasonOrValue) {
          var promise = this.promise;
          var handler = this.handler;

          if (!this.called) {
            this.called = true;
            var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);

            if (ret === NEXT_FILTER) {
              return ret;
            } else if (ret !== undefined) {
              promise._setReturnedNonUndefined();

              var maybePromise = tryConvertToPromise(ret, promise);

              if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                  if (maybePromise._isCancelled()) {
                    var reason = new CancellationError("late cancellation observer");

                    promise._attachExtraTrace(reason);

                    errorObj.e = reason;
                    return errorObj;
                  } else if (maybePromise.isPending()) {
                    maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                  }
                }

                return maybePromise._then(succeed, fail, undefined, this, undefined);
              }
            }
          }

          if (promise.isRejected()) {
            checkCancel(this);
            errorObj.e = reasonOrValue;
            return errorObj;
          } else {
            checkCancel(this);
            return reasonOrValue;
          }
        }

        Promise.prototype._passThrough = function (handler, type, success, fail) {
          if (typeof handler !== "function") return this.then();
          return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
        };

        Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
          return this._passThrough(handler, 0, finallyHandler, finallyHandler);
        };

        Promise.prototype.tap = function (handler) {
          return this._passThrough(handler, 1, finallyHandler);
        };

        Promise.prototype.tapCatch = function (handlerOrPredicate) {
          var len = arguments.length;

          if (len === 1) {
            return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
          } else {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;

            for (i = 0; i < len - 1; ++i) {
              var item = arguments[i];

              if (util.isObject(item)) {
                catchInstances[j++] = item;
              } else {
                return Promise.reject(new TypeError("tapCatch statement predicate: " + "expecting an object but got " + util.classString(item)));
              }
            }

            catchInstances.length = j;
            var handler = arguments[i];
            return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
          }
        };

        return PassThroughHandlerContext;
      };
    }, {
      "./catch_filter": 7,
      "./util": 36
    }],
    16: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
        var errors = _dereq_("./errors");

        var TypeError = errors.TypeError;

        var util = _dereq_("./util");

        var errorObj = util.errorObj;
        var tryCatch = util.tryCatch;
        var yieldHandlers = [];

        function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
          for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();

            var result = tryCatch(yieldHandlers[i])(value);

            traceParent._popContext();

            if (result === errorObj) {
              traceParent._pushContext();

              var ret = Promise.reject(errorObj.e);

              traceParent._popContext();

              return ret;
            }

            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
          }

          return null;
        }

        function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
          if (debug.cancellation()) {
            var internal = new Promise(INTERNAL);

            var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);

            this._promise = internal.lastly(function () {
              return _finallyPromise;
            });

            internal._captureStackTrace();

            internal._setOnCancel(this);
          } else {
            var promise = this._promise = new Promise(INTERNAL);

            promise._captureStackTrace();
          }

          this._stack = stack;
          this._generatorFunction = generatorFunction;
          this._receiver = receiver;
          this._generator = undefined;
          this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
          this._yieldedPromise = null;
          this._cancellationPhase = false;
        }

        util.inherits(PromiseSpawn, Proxyable);

        PromiseSpawn.prototype._isResolved = function () {
          return this._promise === null;
        };

        PromiseSpawn.prototype._cleanup = function () {
          this._promise = this._generator = null;

          if (debug.cancellation() && this._finallyPromise !== null) {
            this._finallyPromise._fulfill();

            this._finallyPromise = null;
          }
        };

        PromiseSpawn.prototype._promiseCancelled = function () {
          if (this._isResolved()) return;
          var implementsReturn = typeof this._generator["return"] !== "undefined";
          var result;

          if (!implementsReturn) {
            var reason = new Promise.CancellationError("generator .return() sentinel");
            Promise.coroutine.returnSentinel = reason;

            this._promise._attachExtraTrace(reason);

            this._promise._pushContext();

            result = tryCatch(this._generator["throw"]).call(this._generator, reason);

            this._promise._popContext();
          } else {
            this._promise._pushContext();

            result = tryCatch(this._generator["return"]).call(this._generator, undefined);

            this._promise._popContext();
          }

          this._cancellationPhase = true;
          this._yieldedPromise = null;

          this._continue(result);
        };

        PromiseSpawn.prototype._promiseFulfilled = function (value) {
          this._yieldedPromise = null;

          this._promise._pushContext();

          var result = tryCatch(this._generator.next).call(this._generator, value);

          this._promise._popContext();

          this._continue(result);
        };

        PromiseSpawn.prototype._promiseRejected = function (reason) {
          this._yieldedPromise = null;

          this._promise._attachExtraTrace(reason);

          this._promise._pushContext();

          var result = tryCatch(this._generator["throw"]).call(this._generator, reason);

          this._promise._popContext();

          this._continue(result);
        };

        PromiseSpawn.prototype._resultCancelled = function () {
          if (this._yieldedPromise instanceof Promise) {
            var promise = this._yieldedPromise;
            this._yieldedPromise = null;
            promise.cancel();
          }
        };

        PromiseSpawn.prototype.promise = function () {
          return this._promise;
        };

        PromiseSpawn.prototype._run = function () {
          this._generator = this._generatorFunction.call(this._receiver);
          this._receiver = this._generatorFunction = undefined;

          this._promiseFulfilled(undefined);
        };

        PromiseSpawn.prototype._continue = function (result) {
          var promise = this._promise;

          if (result === errorObj) {
            this._cleanup();

            if (this._cancellationPhase) {
              return promise.cancel();
            } else {
              return promise._rejectCallback(result.e, false);
            }
          }

          var value = result.value;

          if (result.done === true) {
            this._cleanup();

            if (this._cancellationPhase) {
              return promise.cancel();
            } else {
              return promise._resolveCallback(value);
            }
          } else {
            var maybePromise = tryConvertToPromise(value, this._promise);

            if (!(maybePromise instanceof Promise)) {
              maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);

              if (maybePromise === null) {
                this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));

                return;
              }
            }

            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;

            if ((bitField & 50397184) === 0) {
              this._yieldedPromise = maybePromise;

              maybePromise._proxy(this, null);
            } else if ((bitField & 33554432) !== 0) {
              Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
            } else if ((bitField & 16777216) !== 0) {
              Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
            } else {
              this._promiseCancelled();
            }
          }
        };

        Promise.coroutine = function (generatorFunction, options) {
          if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
          }

          var yieldHandler = Object(options).yieldHandler;
          var PromiseSpawn$ = PromiseSpawn;
          var stack = new Error().stack;
          return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
            var ret = spawn.promise();
            spawn._generator = generator;

            spawn._promiseFulfilled(undefined);

            return ret;
          };
        };

        Promise.coroutine.addYieldHandler = function (fn) {
          if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
          }

          yieldHandlers.push(fn);
        };

        Promise.spawn = function (generatorFunction) {
          debug.deprecated("Promise.spawn()", "Promise.coroutine()");

          if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
          }

          var spawn = new PromiseSpawn(generatorFunction, this);
          var ret = spawn.promise();

          spawn._run(Promise.spawn);

          return ret;
        };
      };
    }, {
      "./errors": 12,
      "./util": 36
    }],
    17: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
        var util = _dereq_("./util");

        var canEvaluate = util.canEvaluate;
        var tryCatch = util.tryCatch;
        var errorObj = util.errorObj;
        var reject;

        if (false) { var i, promiseSetters, thenCallbacks, holderClasses, generateHolderClass, promiseSetter, thenCallback; }

        Promise.join = function () {
          var last = arguments.length - 1;
          var fn;

          if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];

            if (false) { var domain, bitField, maybePromise, i, callbacks, holder, HolderClass, ret; }
          }

          var args = [].slice.call(arguments);
          ;
          if (fn) args.pop();
          var ret = new PromiseArray(args).promise();
          return fn !== undefined ? ret.spread(fn) : ret;
        };
      };
    }, {
      "./util": 36
    }],
    18: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
        var getDomain = Promise._getDomain;

        var util = _dereq_("./util");

        var tryCatch = util.tryCatch;
        var errorObj = util.errorObj;
        var async = Promise._async;

        function MappingPromiseArray(promises, fn, limit, _filter) {
          this.constructor$(promises);

          this._promise._captureStackTrace();

          var domain = getDomain();
          this._callback = domain === null ? fn : util.domainBind(domain, fn);
          this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
          this._limit = limit;
          this._inFlight = 0;
          this._queue = [];
          async.invoke(this._asyncInit, this, undefined);
        }

        util.inherits(MappingPromiseArray, PromiseArray);

        MappingPromiseArray.prototype._asyncInit = function () {
          this._init$(undefined, -2);
        };

        MappingPromiseArray.prototype._init = function () {};

        MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
          var values = this._values;
          var length = this.length();
          var preservedValues = this._preservedValues;
          var limit = this._limit;

          if (index < 0) {
            index = index * -1 - 1;
            values[index] = value;

            if (limit >= 1) {
              this._inFlight--;

              this._drainQueue();

              if (this._isResolved()) return true;
            }
          } else {
            if (limit >= 1 && this._inFlight >= limit) {
              values[index] = value;

              this._queue.push(index);

              return false;
            }

            if (preservedValues !== null) preservedValues[index] = value;
            var promise = this._promise;
            var callback = this._callback;

            var receiver = promise._boundValue();

            promise._pushContext();

            var ret = tryCatch(callback).call(receiver, value, index, length);

            var promiseCreated = promise._popContext();

            debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);

            if (ret === errorObj) {
              this._reject(ret.e);

              return true;
            }

            var maybePromise = tryConvertToPromise(ret, this._promise);

            if (maybePromise instanceof Promise) {
              maybePromise = maybePromise._target();
              var bitField = maybePromise._bitField;
              ;

              if ((bitField & 50397184) === 0) {
                if (limit >= 1) this._inFlight++;
                values[index] = maybePromise;

                maybePromise._proxy(this, (index + 1) * -1);

                return false;
              } else if ((bitField & 33554432) !== 0) {
                ret = maybePromise._value();
              } else if ((bitField & 16777216) !== 0) {
                this._reject(maybePromise._reason());

                return true;
              } else {
                this._cancel();

                return true;
              }
            }

            values[index] = ret;
          }

          var totalResolved = ++this._totalResolved;

          if (totalResolved >= length) {
            if (preservedValues !== null) {
              this._filter(values, preservedValues);
            } else {
              this._resolve(values);
            }

            return true;
          }

          return false;
        };

        MappingPromiseArray.prototype._drainQueue = function () {
          var queue = this._queue;
          var limit = this._limit;
          var values = this._values;

          while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();

            this._promiseFulfilled(values[index], index);
          }
        };

        MappingPromiseArray.prototype._filter = function (booleans, values) {
          var len = values.length;
          var ret = new Array(len);
          var j = 0;

          for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
          }

          ret.length = j;

          this._resolve(ret);
        };

        MappingPromiseArray.prototype.preservedValues = function () {
          return this._preservedValues;
        };

        function map(promises, fn, options, _filter) {
          if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
          }

          var limit = 0;

          if (options !== undefined) {
            if (typeof options === "object" && options !== null) {
              if (typeof options.concurrency !== "number") {
                return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
              }

              limit = options.concurrency;
            } else {
              return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
            }
          }

          limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
          return new MappingPromiseArray(promises, fn, limit, _filter).promise();
        }

        Promise.prototype.map = function (fn, options) {
          return map(this, fn, options, null);
        };

        Promise.map = function (promises, fn, options, _filter) {
          return map(promises, fn, options, _filter);
        };
      };
    }, {
      "./util": 36
    }],
    19: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
        var util = _dereq_("./util");

        var tryCatch = util.tryCatch;

        Promise.method = function (fn) {
          if (typeof fn !== "function") {
            throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
          }

          return function () {
            var ret = new Promise(INTERNAL);

            ret._captureStackTrace();

            ret._pushContext();

            var value = tryCatch(fn).apply(this, arguments);

            var promiseCreated = ret._popContext();

            debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);

            ret._resolveFromSyncValue(value);

            return ret;
          };
        };

        Promise.attempt = Promise["try"] = function (fn) {
          if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
          }

          var ret = new Promise(INTERNAL);

          ret._captureStackTrace();

          ret._pushContext();

          var value;

          if (arguments.length > 1) {
            debug.deprecated("calling Promise.try with more than 1 argument");
            var arg = arguments[1];
            var ctx = arguments[2];
            value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
          } else {
            value = tryCatch(fn)();
          }

          var promiseCreated = ret._popContext();

          debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);

          ret._resolveFromSyncValue(value);

          return ret;
        };

        Promise.prototype._resolveFromSyncValue = function (value) {
          if (value === util.errorObj) {
            this._rejectCallback(value.e, false);
          } else {
            this._resolveCallback(value, true);
          }
        };
      };
    }, {
      "./util": 36
    }],
    20: [function (_dereq_, module, exports) {
      "use strict";

      var util = _dereq_("./util");

      var maybeWrapAsError = util.maybeWrapAsError;

      var errors = _dereq_("./errors");

      var OperationalError = errors.OperationalError;

      var es5 = _dereq_("./es5");

      function isUntypedError(obj) {
        return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
      }

      var rErrorKey = /^(?:name|message|stack|cause)$/;

      function wrapAsOperationalError(obj) {
        var ret;

        if (isUntypedError(obj)) {
          ret = new OperationalError(obj);
          ret.name = obj.name;
          ret.message = obj.message;
          ret.stack = obj.stack;
          var keys = es5.keys(obj);

          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];

            if (!rErrorKey.test(key)) {
              ret[key] = obj[key];
            }
          }

          return ret;
        }

        util.markAsOriginatingFromRejection(obj);
        return obj;
      }

      function nodebackForPromise(promise, multiArgs) {
        return function (err, value) {
          if (promise === null) return;

          if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));

            promise._attachExtraTrace(wrapped);

            promise._reject(wrapped);
          } else if (!multiArgs) {
            promise._fulfill(value);
          } else {
            var args = [].slice.call(arguments, 1);
            ;

            promise._fulfill(args);
          }

          promise = null;
        };
      }

      module.exports = nodebackForPromise;
    }, {
      "./errors": 12,
      "./es5": 13,
      "./util": 36
    }],
    21: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise) {
        var util = _dereq_("./util");

        var async = Promise._async;
        var tryCatch = util.tryCatch;
        var errorObj = util.errorObj;

        function spreadAdapter(val, nodeback) {
          var promise = this;
          if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
          var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));

          if (ret === errorObj) {
            async.throwLater(ret.e);
          }
        }

        function successAdapter(val, nodeback) {
          var promise = this;

          var receiver = promise._boundValue();

          var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);

          if (ret === errorObj) {
            async.throwLater(ret.e);
          }
        }

        function errorAdapter(reason, nodeback) {
          var promise = this;

          if (!reason) {
            var newReason = new Error(reason + "");
            newReason.cause = reason;
            reason = newReason;
          }

          var ret = tryCatch(nodeback).call(promise._boundValue(), reason);

          if (ret === errorObj) {
            async.throwLater(ret.e);
          }
        }

        Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
          if (typeof nodeback == "function") {
            var adapter = successAdapter;

            if (options !== undefined && Object(options).spread) {
              adapter = spreadAdapter;
            }

            this._then(adapter, errorAdapter, undefined, this, nodeback);
          }

          return this;
        };
      };
    }, {
      "./util": 36
    }],
    22: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function () {
        var makeSelfResolutionError = function makeSelfResolutionError() {
          return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
        };

        var reflectHandler = function reflectHandler() {
          return new Promise.PromiseInspection(this._target());
        };

        var apiRejection = function apiRejection(msg) {
          return Promise.reject(new TypeError(msg));
        };

        function Proxyable() {}

        var UNDEFINED_BINDING = {};

        var util = _dereq_("./util");

        var getDomain;

        if (util.isNode) {
          getDomain = function getDomain() {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
          };
        } else {
          getDomain = function getDomain() {
            return null;
          };
        }

        util.notEnumerableProp(Promise, "_getDomain", getDomain);

        var es5 = _dereq_("./es5");

        var Async = _dereq_("./async");

        var async = new Async();
        es5.defineProperty(Promise, "_async", {
          value: async
        });

        var errors = _dereq_("./errors");

        var TypeError = Promise.TypeError = errors.TypeError;
        Promise.RangeError = errors.RangeError;
        var CancellationError = Promise.CancellationError = errors.CancellationError;
        Promise.TimeoutError = errors.TimeoutError;
        Promise.OperationalError = errors.OperationalError;
        Promise.RejectionError = errors.OperationalError;
        Promise.AggregateError = errors.AggregateError;

        var INTERNAL = function INTERNAL() {};

        var APPLY = {};
        var NEXT_FILTER = {};

        var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);

        var PromiseArray = _dereq_("./promise_array")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);

        var Context = _dereq_("./context")(Promise);
        /*jshint unused:false*/


        var createContext = Context.create;

        var debug = _dereq_("./debuggability")(Promise, Context);

        var CapturedTrace = debug.CapturedTrace;

        var PassThroughHandlerContext = _dereq_("./finally")(Promise, tryConvertToPromise, NEXT_FILTER);

        var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

        var nodebackForPromise = _dereq_("./nodeback");

        var errorObj = util.errorObj;
        var tryCatch = util.tryCatch;

        function check(self, executor) {
          if (self == null || self.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
          }

          if (typeof executor !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(executor));
          }
        }

        function Promise(executor) {
          if (executor !== INTERNAL) {
            check(this, executor);
          }

          this._bitField = 0;
          this._fulfillmentHandler0 = undefined;
          this._rejectionHandler0 = undefined;
          this._promise0 = undefined;
          this._receiver0 = undefined;

          this._resolveFromExecutor(executor);

          this._promiseCreated();

          this._fireEvent("promiseCreated", this);
        }

        Promise.prototype.toString = function () {
          return "[object Promise]";
        };

        Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
          var len = arguments.length;

          if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;

            for (i = 0; i < len - 1; ++i) {
              var item = arguments[i];

              if (util.isObject(item)) {
                catchInstances[j++] = item;
              } else {
                return apiRejection("Catch statement predicate: " + "expecting an object but got " + util.classString(item));
              }
            }

            catchInstances.length = j;
            fn = arguments[i];
            return this.then(undefined, catchFilter(catchInstances, fn, this));
          }

          return this.then(undefined, fn);
        };

        Promise.prototype.reflect = function () {
          return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
        };

        Promise.prototype.then = function (didFulfill, didReject) {
          if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);

            if (arguments.length > 1) {
              msg += ", " + util.classString(didReject);
            }

            this._warn(msg);
          }

          return this._then(didFulfill, didReject, undefined, undefined, undefined);
        };

        Promise.prototype.done = function (didFulfill, didReject) {
          var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);

          promise._setIsFinal();
        };

        Promise.prototype.spread = function (fn) {
          if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
          }

          return this.all()._then(fn, undefined, undefined, APPLY, undefined);
        };

        Promise.prototype.toJSON = function () {
          var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
          };

          if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
          } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
          }

          return ret;
        };

        Promise.prototype.all = function () {
          if (arguments.length > 0) {
            this._warn(".all() was passed arguments but it does not take any");
          }

          return new PromiseArray(this).promise();
        };

        Promise.prototype.error = function (fn) {
          return this.caught(util.originatesFromRejection, fn);
        };

        Promise.getNewLibraryCopy = module.exports;

        Promise.is = function (val) {
          return val instanceof Promise;
        };

        Promise.fromNode = Promise.fromCallback = function (fn) {
          var ret = new Promise(INTERNAL);

          ret._captureStackTrace();

          var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
          var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));

          if (result === errorObj) {
            ret._rejectCallback(result.e, true);
          }

          if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
          return ret;
        };

        Promise.all = function (promises) {
          return new PromiseArray(promises).promise();
        };

        Promise.cast = function (obj) {
          var ret = tryConvertToPromise(obj);

          if (!(ret instanceof Promise)) {
            ret = new Promise(INTERNAL);

            ret._captureStackTrace();

            ret._setFulfilled();

            ret._rejectionHandler0 = obj;
          }

          return ret;
        };

        Promise.resolve = Promise.fulfilled = Promise.cast;

        Promise.reject = Promise.rejected = function (reason) {
          var ret = new Promise(INTERNAL);

          ret._captureStackTrace();

          ret._rejectCallback(reason, true);

          return ret;
        };

        Promise.setScheduler = function (fn) {
          if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
          }

          return async.setScheduler(fn);
        };

        Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {
          var haveInternalData = internalData !== undefined;
          var promise = haveInternalData ? internalData : new Promise(INTERNAL);

          var target = this._target();

          var bitField = target._bitField;

          if (!haveInternalData) {
            promise._propagateFrom(this, 3);

            promise._captureStackTrace();

            if (receiver === undefined && (this._bitField & 2097152) !== 0) {
              if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
              } else {
                receiver = target === this ? undefined : this._boundTo;
              }
            }

            this._fireEvent("promiseChained", this, promise);
          }

          var domain = getDomain();

          if (!((bitField & 50397184) === 0)) {
            var handler,
                value,
                settler = target._settlePromiseCtx;

            if ((bitField & 33554432) !== 0) {
              value = target._rejectionHandler0;
              handler = didFulfill;
            } else if ((bitField & 16777216) !== 0) {
              value = target._fulfillmentHandler0;
              handler = didReject;

              target._unsetRejectionIsUnhandled();
            } else {
              settler = target._settlePromiseLateCancellationObserver;
              value = new CancellationError("late cancellation observer");

              target._attachExtraTrace(value);

              handler = didReject;
            }

            async.invoke(settler, target, {
              handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
              promise: promise,
              receiver: receiver,
              value: value
            });
          } else {
            target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
          }

          return promise;
        };

        Promise.prototype._length = function () {
          return this._bitField & 65535;
        };

        Promise.prototype._isFateSealed = function () {
          return (this._bitField & 117506048) !== 0;
        };

        Promise.prototype._isFollowing = function () {
          return (this._bitField & 67108864) === 67108864;
        };

        Promise.prototype._setLength = function (len) {
          this._bitField = this._bitField & -65536 | len & 65535;
        };

        Promise.prototype._setFulfilled = function () {
          this._bitField = this._bitField | 33554432;

          this._fireEvent("promiseFulfilled", this);
        };

        Promise.prototype._setRejected = function () {
          this._bitField = this._bitField | 16777216;

          this._fireEvent("promiseRejected", this);
        };

        Promise.prototype._setFollowing = function () {
          this._bitField = this._bitField | 67108864;

          this._fireEvent("promiseResolved", this);
        };

        Promise.prototype._setIsFinal = function () {
          this._bitField = this._bitField | 4194304;
        };

        Promise.prototype._isFinal = function () {
          return (this._bitField & 4194304) > 0;
        };

        Promise.prototype._unsetCancelled = function () {
          this._bitField = this._bitField & ~65536;
        };

        Promise.prototype._setCancelled = function () {
          this._bitField = this._bitField | 65536;

          this._fireEvent("promiseCancelled", this);
        };

        Promise.prototype._setWillBeCancelled = function () {
          this._bitField = this._bitField | 8388608;
        };

        Promise.prototype._setAsyncGuaranteed = function () {
          if (async.hasCustomScheduler()) return;
          this._bitField = this._bitField | 134217728;
        };

        Promise.prototype._receiverAt = function (index) {
          var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];

          if (ret === UNDEFINED_BINDING) {
            return undefined;
          } else if (ret === undefined && this._isBound()) {
            return this._boundValue();
          }

          return ret;
        };

        Promise.prototype._promiseAt = function (index) {
          return this[index * 4 - 4 + 2];
        };

        Promise.prototype._fulfillmentHandlerAt = function (index) {
          return this[index * 4 - 4 + 0];
        };

        Promise.prototype._rejectionHandlerAt = function (index) {
          return this[index * 4 - 4 + 1];
        };

        Promise.prototype._boundValue = function () {};

        Promise.prototype._migrateCallback0 = function (follower) {
          var bitField = follower._bitField;
          var fulfill = follower._fulfillmentHandler0;
          var reject = follower._rejectionHandler0;
          var promise = follower._promise0;

          var receiver = follower._receiverAt(0);

          if (receiver === undefined) receiver = UNDEFINED_BINDING;

          this._addCallbacks(fulfill, reject, promise, receiver, null);
        };

        Promise.prototype._migrateCallbackAt = function (follower, index) {
          var fulfill = follower._fulfillmentHandlerAt(index);

          var reject = follower._rejectionHandlerAt(index);

          var promise = follower._promiseAt(index);

          var receiver = follower._receiverAt(index);

          if (receiver === undefined) receiver = UNDEFINED_BINDING;

          this._addCallbacks(fulfill, reject, promise, receiver, null);
        };

        Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {
          var index = this._length();

          if (index >= 65535 - 4) {
            index = 0;

            this._setLength(0);
          }

          if (index === 0) {
            this._promise0 = promise;
            this._receiver0 = receiver;

            if (typeof fulfill === "function") {
              this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }

            if (typeof reject === "function") {
              this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
            }
          } else {
            var base = index * 4 - 4;
            this[base + 2] = promise;
            this[base + 3] = receiver;

            if (typeof fulfill === "function") {
              this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }

            if (typeof reject === "function") {
              this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
            }
          }

          this._setLength(index + 1);

          return index;
        };

        Promise.prototype._proxy = function (proxyable, arg) {
          this._addCallbacks(undefined, undefined, arg, proxyable, null);
        };

        Promise.prototype._resolveCallback = function (value, shouldBind) {
          if ((this._bitField & 117506048) !== 0) return;
          if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
          var maybePromise = tryConvertToPromise(value, this);
          if (!(maybePromise instanceof Promise)) return this._fulfill(value);
          if (shouldBind) this._propagateFrom(maybePromise, 2);

          var promise = maybePromise._target();

          if (promise === this) {
            this._reject(makeSelfResolutionError());

            return;
          }

          var bitField = promise._bitField;

          if ((bitField & 50397184) === 0) {
            var len = this._length();

            if (len > 0) promise._migrateCallback0(this);

            for (var i = 1; i < len; ++i) {
              promise._migrateCallbackAt(this, i);
            }

            this._setFollowing();

            this._setLength(0);

            this._setFollowee(promise);
          } else if ((bitField & 33554432) !== 0) {
            this._fulfill(promise._value());
          } else if ((bitField & 16777216) !== 0) {
            this._reject(promise._reason());
          } else {
            var reason = new CancellationError("late cancellation observer");

            promise._attachExtraTrace(reason);

            this._reject(reason);
          }
        };

        Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {
          var trace = util.ensureErrorObject(reason);
          var hasStack = trace === reason;

          if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
            var message = "a promise was rejected with a non-error: " + util.classString(reason);

            this._warn(message, true);
          }

          this._attachExtraTrace(trace, synchronous ? hasStack : false);

          this._reject(reason);
        };

        Promise.prototype._resolveFromExecutor = function (executor) {
          if (executor === INTERNAL) return;
          var promise = this;

          this._captureStackTrace();

          this._pushContext();

          var synchronous = true;

          var r = this._execute(executor, function (value) {
            promise._resolveCallback(value);
          }, function (reason) {
            promise._rejectCallback(reason, synchronous);
          });

          synchronous = false;

          this._popContext();

          if (r !== undefined) {
            promise._rejectCallback(r, true);
          }
        };

        Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
          var bitField = promise._bitField;
          if ((bitField & 65536) !== 0) return;

          promise._pushContext();

          var x;

          if (receiver === APPLY) {
            if (!value || typeof value.length !== "number") {
              x = errorObj;
              x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
            } else {
              x = tryCatch(handler).apply(this._boundValue(), value);
            }
          } else {
            x = tryCatch(handler).call(receiver, value);
          }

          var promiseCreated = promise._popContext();

          bitField = promise._bitField;
          if ((bitField & 65536) !== 0) return;

          if (x === NEXT_FILTER) {
            promise._reject(value);
          } else if (x === errorObj) {
            promise._rejectCallback(x.e, false);
          } else {
            debug.checkForgottenReturns(x, promiseCreated, "", promise, this);

            promise._resolveCallback(x);
          }
        };

        Promise.prototype._target = function () {
          var ret = this;

          while (ret._isFollowing()) {
            ret = ret._followee();
          }

          return ret;
        };

        Promise.prototype._followee = function () {
          return this._rejectionHandler0;
        };

        Promise.prototype._setFollowee = function (promise) {
          this._rejectionHandler0 = promise;
        };

        Promise.prototype._settlePromise = function (promise, handler, receiver, value) {
          var isPromise = promise instanceof Promise;
          var bitField = this._bitField;
          var asyncGuaranteed = (bitField & 134217728) !== 0;

          if ((bitField & 65536) !== 0) {
            if (isPromise) promise._invokeInternalOnCancel();

            if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
              receiver.cancelPromise = promise;

              if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
              }
            } else if (handler === reflectHandler) {
              promise._fulfill(reflectHandler.call(receiver));
            } else if (receiver instanceof Proxyable) {
              receiver._promiseCancelled(promise);
            } else if (isPromise || promise instanceof PromiseArray) {
              promise._cancel();
            } else {
              receiver.cancel();
            }
          } else if (typeof handler === "function") {
            if (!isPromise) {
              handler.call(receiver, value, promise);
            } else {
              if (asyncGuaranteed) promise._setAsyncGuaranteed();

              this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
          } else if (receiver instanceof Proxyable) {
            if (!receiver._isResolved()) {
              if ((bitField & 33554432) !== 0) {
                receiver._promiseFulfilled(value, promise);
              } else {
                receiver._promiseRejected(value, promise);
              }
            }
          } else if (isPromise) {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();

            if ((bitField & 33554432) !== 0) {
              promise._fulfill(value);
            } else {
              promise._reject(value);
            }
          }
        };

        Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {
          var handler = ctx.handler;
          var promise = ctx.promise;
          var receiver = ctx.receiver;
          var value = ctx.value;

          if (typeof handler === "function") {
            if (!(promise instanceof Promise)) {
              handler.call(receiver, value, promise);
            } else {
              this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
          } else if (promise instanceof Promise) {
            promise._reject(value);
          }
        };

        Promise.prototype._settlePromiseCtx = function (ctx) {
          this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
        };

        Promise.prototype._settlePromise0 = function (handler, value, bitField) {
          var promise = this._promise0;

          var receiver = this._receiverAt(0);

          this._promise0 = undefined;
          this._receiver0 = undefined;

          this._settlePromise(promise, handler, receiver, value);
        };

        Promise.prototype._clearCallbackDataAtIndex = function (index) {
          var base = index * 4 - 4;
          this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
        };

        Promise.prototype._fulfill = function (value) {
          var bitField = this._bitField;
          if ((bitField & 117506048) >>> 16) return;

          if (value === this) {
            var err = makeSelfResolutionError();

            this._attachExtraTrace(err);

            return this._reject(err);
          }

          this._setFulfilled();

          this._rejectionHandler0 = value;

          if ((bitField & 65535) > 0) {
            if ((bitField & 134217728) !== 0) {
              this._settlePromises();
            } else {
              async.settlePromises(this);
            }
          }
        };

        Promise.prototype._reject = function (reason) {
          var bitField = this._bitField;
          if ((bitField & 117506048) >>> 16) return;

          this._setRejected();

          this._fulfillmentHandler0 = reason;

          if (this._isFinal()) {
            return async.fatalError(reason, util.isNode);
          }

          if ((bitField & 65535) > 0) {
            async.settlePromises(this);
          } else {
            this._ensurePossibleRejectionHandled();
          }
        };

        Promise.prototype._fulfillPromises = function (len, value) {
          for (var i = 1; i < len; i++) {
            var handler = this._fulfillmentHandlerAt(i);

            var promise = this._promiseAt(i);

            var receiver = this._receiverAt(i);

            this._clearCallbackDataAtIndex(i);

            this._settlePromise(promise, handler, receiver, value);
          }
        };

        Promise.prototype._rejectPromises = function (len, reason) {
          for (var i = 1; i < len; i++) {
            var handler = this._rejectionHandlerAt(i);

            var promise = this._promiseAt(i);

            var receiver = this._receiverAt(i);

            this._clearCallbackDataAtIndex(i);

            this._settlePromise(promise, handler, receiver, reason);
          }
        };

        Promise.prototype._settlePromises = function () {
          var bitField = this._bitField;
          var len = bitField & 65535;

          if (len > 0) {
            if ((bitField & 16842752) !== 0) {
              var reason = this._fulfillmentHandler0;

              this._settlePromise0(this._rejectionHandler0, reason, bitField);

              this._rejectPromises(len, reason);
            } else {
              var value = this._rejectionHandler0;

              this._settlePromise0(this._fulfillmentHandler0, value, bitField);

              this._fulfillPromises(len, value);
            }

            this._setLength(0);
          }

          this._clearCancellationData();
        };

        Promise.prototype._settledValue = function () {
          var bitField = this._bitField;

          if ((bitField & 33554432) !== 0) {
            return this._rejectionHandler0;
          } else if ((bitField & 16777216) !== 0) {
            return this._fulfillmentHandler0;
          }
        };

        function deferResolve(v) {
          this.promise._resolveCallback(v);
        }

        function deferReject(v) {
          this.promise._rejectCallback(v, false);
        }

        Promise.defer = Promise.pending = function () {
          debug.deprecated("Promise.defer", "new Promise");
          var promise = new Promise(INTERNAL);
          return {
            promise: promise,
            resolve: deferResolve,
            reject: deferReject
          };
        };

        util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);

        _dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);

        _dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);

        _dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);

        _dereq_("./direct_resolve")(Promise);

        _dereq_("./synchronous_inspection")(Promise);

        _dereq_("./join")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);

        Promise.Promise = Promise;
        Promise.version = "3.5.0";

        _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);

        _dereq_('./call_get.js')(Promise);

        _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);

        _dereq_('./timers.js')(Promise, INTERNAL, debug);

        _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);

        _dereq_('./nodeify.js')(Promise);

        _dereq_('./promisify.js')(Promise, INTERNAL);

        _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);

        _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);

        _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);

        _dereq_('./settle.js')(Promise, PromiseArray, debug);

        _dereq_('./some.js')(Promise, PromiseArray, apiRejection);

        _dereq_('./filter.js')(Promise, INTERNAL);

        _dereq_('./each.js')(Promise, INTERNAL);

        _dereq_('./any.js')(Promise);

        util.toFastProperties(Promise);
        util.toFastProperties(Promise.prototype);

        function fillTypes(value) {
          var p = new Promise(INTERNAL);
          p._fulfillmentHandler0 = value;
          p._rejectionHandler0 = value;
          p._promise0 = value;
          p._receiver0 = value;
        } // Complete slack tracking, opt out of field-type tracking and           
        // stabilize map                                                         


        fillTypes({
          a: 1
        });
        fillTypes({
          b: 2
        });
        fillTypes({
          c: 3
        });
        fillTypes(1);
        fillTypes(function () {});
        fillTypes(undefined);
        fillTypes(false);
        fillTypes(new Promise(INTERNAL));
        debug.setBounds(Async.firstLineError, util.lastLineError);
        return Promise;
      };
    }, {
      "./any.js": 1,
      "./async": 2,
      "./bind": 3,
      "./call_get.js": 5,
      "./cancel": 6,
      "./catch_filter": 7,
      "./context": 8,
      "./debuggability": 9,
      "./direct_resolve": 10,
      "./each.js": 11,
      "./errors": 12,
      "./es5": 13,
      "./filter.js": 14,
      "./finally": 15,
      "./generators.js": 16,
      "./join": 17,
      "./map.js": 18,
      "./method": 19,
      "./nodeback": 20,
      "./nodeify.js": 21,
      "./promise_array": 23,
      "./promisify.js": 24,
      "./props.js": 25,
      "./race.js": 27,
      "./reduce.js": 28,
      "./settle.js": 30,
      "./some.js": 31,
      "./synchronous_inspection": 32,
      "./thenables": 33,
      "./timers.js": 34,
      "./using.js": 35,
      "./util": 36
    }],
    23: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
        var util = _dereq_("./util");

        var isArray = util.isArray;

        function toResolutionValue(val) {
          switch (val) {
            case -2:
              return [];

            case -3:
              return {};

            case -6:
              return new Map();
          }
        }

        function PromiseArray(values) {
          var promise = this._promise = new Promise(INTERNAL);

          if (values instanceof Promise) {
            promise._propagateFrom(values, 3);
          }

          promise._setOnCancel(this);

          this._values = values;
          this._length = 0;
          this._totalResolved = 0;

          this._init(undefined, -2);
        }

        util.inherits(PromiseArray, Proxyable);

        PromiseArray.prototype.length = function () {
          return this._length;
        };

        PromiseArray.prototype.promise = function () {
          return this._promise;
        };

        PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
          var values = tryConvertToPromise(this._values, this._promise);

          if (values instanceof Promise) {
            values = values._target();
            var bitField = values._bitField;
            ;
            this._values = values;

            if ((bitField & 50397184) === 0) {
              this._promise._setAsyncGuaranteed();

              return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
            } else if ((bitField & 33554432) !== 0) {
              values = values._value();
            } else if ((bitField & 16777216) !== 0) {
              return this._reject(values._reason());
            } else {
              return this._cancel();
            }
          }

          values = util.asArray(values);

          if (values === null) {
            var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();

            this._promise._rejectCallback(err, false);

            return;
          }

          if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
              this._resolveEmptyArray();
            } else {
              this._resolve(toResolutionValue(resolveValueIfEmpty));
            }

            return;
          }

          this._iterate(values);
        };

        PromiseArray.prototype._iterate = function (values) {
          var len = this.getActualLength(values.length);
          this._length = len;
          this._values = this.shouldCopyValues() ? new Array(len) : this._values;
          var result = this._promise;
          var isResolved = false;
          var bitField = null;

          for (var i = 0; i < len; ++i) {
            var maybePromise = tryConvertToPromise(values[i], result);

            if (maybePromise instanceof Promise) {
              maybePromise = maybePromise._target();
              bitField = maybePromise._bitField;
            } else {
              bitField = null;
            }

            if (isResolved) {
              if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
              }
            } else if (bitField !== null) {
              if ((bitField & 50397184) === 0) {
                maybePromise._proxy(this, i);

                this._values[i] = maybePromise;
              } else if ((bitField & 33554432) !== 0) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
              } else if ((bitField & 16777216) !== 0) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
              } else {
                isResolved = this._promiseCancelled(i);
              }
            } else {
              isResolved = this._promiseFulfilled(maybePromise, i);
            }
          }

          if (!isResolved) result._setAsyncGuaranteed();
        };

        PromiseArray.prototype._isResolved = function () {
          return this._values === null;
        };

        PromiseArray.prototype._resolve = function (value) {
          this._values = null;

          this._promise._fulfill(value);
        };

        PromiseArray.prototype._cancel = function () {
          if (this._isResolved() || !this._promise._isCancellable()) return;
          this._values = null;

          this._promise._cancel();
        };

        PromiseArray.prototype._reject = function (reason) {
          this._values = null;

          this._promise._rejectCallback(reason, false);
        };

        PromiseArray.prototype._promiseFulfilled = function (value, index) {
          this._values[index] = value;
          var totalResolved = ++this._totalResolved;

          if (totalResolved >= this._length) {
            this._resolve(this._values);

            return true;
          }

          return false;
        };

        PromiseArray.prototype._promiseCancelled = function () {
          this._cancel();

          return true;
        };

        PromiseArray.prototype._promiseRejected = function (reason) {
          this._totalResolved++;

          this._reject(reason);

          return true;
        };

        PromiseArray.prototype._resultCancelled = function () {
          if (this._isResolved()) return;
          var values = this._values;

          this._cancel();

          if (values instanceof Promise) {
            values.cancel();
          } else {
            for (var i = 0; i < values.length; ++i) {
              if (values[i] instanceof Promise) {
                values[i].cancel();
              }
            }
          }
        };

        PromiseArray.prototype.shouldCopyValues = function () {
          return true;
        };

        PromiseArray.prototype.getActualLength = function (len) {
          return len;
        };

        return PromiseArray;
      };
    }, {
      "./util": 36
    }],
    24: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL) {
        var THIS = {};

        var util = _dereq_("./util");

        var nodebackForPromise = _dereq_("./nodeback");

        var withAppended = util.withAppended;
        var maybeWrapAsError = util.maybeWrapAsError;
        var canEvaluate = util.canEvaluate;

        var TypeError = _dereq_("./errors").TypeError;

        var defaultSuffix = "Async";
        var defaultPromisified = {
          __isPromisified__: true
        };
        var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
        var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

        var defaultFilter = function defaultFilter(name) {
          return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
        };

        function propsFilter(key) {
          return !noCopyPropsPattern.test(key);
        }

        function isPromisified(fn) {
          try {
            return fn.__isPromisified__ === true;
          } catch (e) {
            return false;
          }
        }

        function hasPromisified(obj, key, suffix) {
          var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
          return val ? isPromisified(val) : false;
        }

        function checkValid(ret, suffix, suffixRegexp) {
          for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];

            if (suffixRegexp.test(key)) {
              var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");

              for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                  throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                }
              }
            }
          }
        }

        function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
          var keys = util.inheritedDataKeys(obj);
          var ret = [];

          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);

            if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
              ret.push(key, value);
            }
          }

          checkValid(ret, suffix, suffixRegexp);
          return ret;
        }

        var escapeIdentRegex = function escapeIdentRegex(str) {
          return str.replace(/([$])/, "\\$");
        };

        var makeNodePromisifiedEval;

        if (false) { var parameterCount, parameterDeclaration, argumentSequence, switchCaseArgumentOrder; }

        function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
          var defaultThis = function () {
            return this;
          }();

          var method = callback;

          if (typeof method === "string") {
            callback = fn;
          }

          function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);

            promise._captureStackTrace();

            var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
            var fn = nodebackForPromise(promise, multiArgs);

            try {
              cb.apply(_receiver, withAppended(arguments, fn));
            } catch (e) {
              promise._rejectCallback(maybeWrapAsError(e), true, true);
            }

            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
            return promise;
          }

          util.notEnumerableProp(promisified, "__isPromisified__", true);
          return promisified;
        }

        var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;

        function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
          var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
          var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);

          for (var i = 0, len = methods.length; i < len; i += 2) {
            var key = methods[i];
            var fn = methods[i + 1];
            var promisifiedKey = key + suffix;

            if (promisifier === makeNodePromisified) {
              obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            } else {
              var promisified = promisifier(fn, function () {
                return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
              });
              util.notEnumerableProp(promisified, "__isPromisified__", true);
              obj[promisifiedKey] = promisified;
            }
          }

          util.toFastProperties(obj);
          return obj;
        }

        function promisify(callback, receiver, multiArgs) {
          return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
        }

        Promise.promisify = function (fn, options) {
          if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
          }

          if (isPromisified(fn)) {
            return fn;
          }

          options = Object(options);
          var receiver = options.context === undefined ? THIS : options.context;
          var multiArgs = !!options.multiArgs;
          var ret = promisify(fn, receiver, multiArgs);
          util.copyDescriptors(fn, ret, propsFilter);
          return ret;
        };

        Promise.promisifyAll = function (target, options) {
          if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
          }

          options = Object(options);
          var multiArgs = !!options.multiArgs;
          var suffix = options.suffix;
          if (typeof suffix !== "string") suffix = defaultSuffix;
          var filter = options.filter;
          if (typeof filter !== "function") filter = defaultFilter;
          var promisifier = options.promisifier;
          if (typeof promisifier !== "function") promisifier = makeNodePromisified;

          if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
          }

          var keys = util.inheritedDataKeys(target);

          for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];

            if (keys[i] !== "constructor" && util.isClass(value)) {
              promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
              promisifyAll(value, suffix, filter, promisifier, multiArgs);
            }
          }

          return promisifyAll(target, suffix, filter, promisifier, multiArgs);
        };
      };
    }, {
      "./errors": 12,
      "./nodeback": 20,
      "./util": 36
    }],
    25: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
        var util = _dereq_("./util");

        var isObject = util.isObject;

        var es5 = _dereq_("./es5");

        var Es6Map;
        if (typeof Map === "function") Es6Map = Map;

        var mapToEntries = function () {
          var index = 0;
          var size = 0;

          function extractEntry(value, key) {
            this[index] = value;
            this[index + size] = key;
            index++;
          }

          return function mapToEntries(map) {
            size = map.size;
            index = 0;
            var ret = new Array(map.size * 2);
            map.forEach(extractEntry, ret);
            return ret;
          };
        }();

        var entriesToMap = function entriesToMap(entries) {
          var ret = new Es6Map();
          var length = entries.length / 2 | 0;

          for (var i = 0; i < length; ++i) {
            var key = entries[length + i];
            var value = entries[i];
            ret.set(key, value);
          }

          return ret;
        };

        function PropertiesPromiseArray(obj) {
          var isMap = false;
          var entries;

          if (Es6Map !== undefined && obj instanceof Es6Map) {
            entries = mapToEntries(obj);
            isMap = true;
          } else {
            var keys = es5.keys(obj);
            var len = keys.length;
            entries = new Array(len * 2);

            for (var i = 0; i < len; ++i) {
              var key = keys[i];
              entries[i] = obj[key];
              entries[i + len] = key;
            }
          }

          this.constructor$(entries);
          this._isMap = isMap;

          this._init$(undefined, isMap ? -6 : -3);
        }

        util.inherits(PropertiesPromiseArray, PromiseArray);

        PropertiesPromiseArray.prototype._init = function () {};

        PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
          this._values[index] = value;
          var totalResolved = ++this._totalResolved;

          if (totalResolved >= this._length) {
            var val;

            if (this._isMap) {
              val = entriesToMap(this._values);
            } else {
              val = {};
              var keyOffset = this.length();

              for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
              }
            }

            this._resolve(val);

            return true;
          }

          return false;
        };

        PropertiesPromiseArray.prototype.shouldCopyValues = function () {
          return false;
        };

        PropertiesPromiseArray.prototype.getActualLength = function (len) {
          return len >> 1;
        };

        function props(promises) {
          var ret;
          var castValue = tryConvertToPromise(promises);

          if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
          } else if (castValue instanceof Promise) {
            ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
          } else {
            ret = new PropertiesPromiseArray(castValue).promise();
          }

          if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 2);
          }

          return ret;
        }

        Promise.prototype.props = function () {
          return props(this);
        };

        Promise.props = function (promises) {
          return props(promises);
        };
      };
    }, {
      "./es5": 13,
      "./util": 36
    }],
    26: [function (_dereq_, module, exports) {
      "use strict";

      function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
          dst[j + dstIndex] = src[j + srcIndex];
          src[j + srcIndex] = void 0;
        }
      }

      function Queue(capacity) {
        this._capacity = capacity;
        this._length = 0;
        this._front = 0;
      }

      Queue.prototype._willBeOverCapacity = function (size) {
        return this._capacity < size;
      };

      Queue.prototype._pushOne = function (arg) {
        var length = this.length();

        this._checkCapacity(length + 1);

        var i = this._front + length & this._capacity - 1;
        this[i] = arg;
        this._length = length + 1;
      };

      Queue.prototype.push = function (fn, receiver, arg) {
        var length = this.length() + 3;

        if (this._willBeOverCapacity(length)) {
          this._pushOne(fn);

          this._pushOne(receiver);

          this._pushOne(arg);

          return;
        }

        var j = this._front + length - 3;

        this._checkCapacity(length);

        var wrapMask = this._capacity - 1;
        this[j + 0 & wrapMask] = fn;
        this[j + 1 & wrapMask] = receiver;
        this[j + 2 & wrapMask] = arg;
        this._length = length;
      };

      Queue.prototype.shift = function () {
        var front = this._front,
            ret = this[front];
        this[front] = undefined;
        this._front = front + 1 & this._capacity - 1;
        this._length--;
        return ret;
      };

      Queue.prototype.length = function () {
        return this._length;
      };

      Queue.prototype._checkCapacity = function (size) {
        if (this._capacity < size) {
          this._resizeTo(this._capacity << 1);
        }
      };

      Queue.prototype._resizeTo = function (capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length = this._length;
        var moveItemsCount = front + length & oldCapacity - 1;
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
      };

      module.exports = Queue;
    }, {}],
    27: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
        var util = _dereq_("./util");

        var raceLater = function raceLater(promise) {
          return promise.then(function (array) {
            return race(array, promise);
          });
        };

        function race(promises, parent) {
          var maybePromise = tryConvertToPromise(promises);

          if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
          } else {
            promises = util.asArray(promises);
            if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
          }

          var ret = new Promise(INTERNAL);

          if (parent !== undefined) {
            ret._propagateFrom(parent, 3);
          }

          var fulfill = ret._fulfill;
          var reject = ret._reject;

          for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];

            if (val === undefined && !(i in promises)) {
              continue;
            }

            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
          }

          return ret;
        }

        Promise.race = function (promises) {
          return race(promises, undefined);
        };

        Promise.prototype.race = function () {
          return race(this, undefined);
        };
      };
    }, {
      "./util": 36
    }],
    28: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
        var getDomain = Promise._getDomain;

        var util = _dereq_("./util");

        var tryCatch = util.tryCatch;

        function ReductionPromiseArray(promises, fn, initialValue, _each) {
          this.constructor$(promises);
          var domain = getDomain();
          this._fn = domain === null ? fn : util.domainBind(domain, fn);

          if (initialValue !== undefined) {
            initialValue = Promise.resolve(initialValue);

            initialValue._attachCancellationCallback(this);
          }

          this._initialValue = initialValue;
          this._currentCancellable = null;

          if (_each === INTERNAL) {
            this._eachValues = Array(this._length);
          } else if (_each === 0) {
            this._eachValues = null;
          } else {
            this._eachValues = undefined;
          }

          this._promise._captureStackTrace();

          this._init$(undefined, -5);
        }

        util.inherits(ReductionPromiseArray, PromiseArray);

        ReductionPromiseArray.prototype._gotAccum = function (accum) {
          if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
            this._eachValues.push(accum);
          }
        };

        ReductionPromiseArray.prototype._eachComplete = function (value) {
          if (this._eachValues !== null) {
            this._eachValues.push(value);
          }

          return this._eachValues;
        };

        ReductionPromiseArray.prototype._init = function () {};

        ReductionPromiseArray.prototype._resolveEmptyArray = function () {
          this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
        };

        ReductionPromiseArray.prototype.shouldCopyValues = function () {
          return false;
        };

        ReductionPromiseArray.prototype._resolve = function (value) {
          this._promise._resolveCallback(value);

          this._values = null;
        };

        ReductionPromiseArray.prototype._resultCancelled = function (sender) {
          if (sender === this._initialValue) return this._cancel();
          if (this._isResolved()) return;

          this._resultCancelled$();

          if (this._currentCancellable instanceof Promise) {
            this._currentCancellable.cancel();
          }

          if (this._initialValue instanceof Promise) {
            this._initialValue.cancel();
          }
        };

        ReductionPromiseArray.prototype._iterate = function (values) {
          this._values = values;
          var value;
          var i;
          var length = values.length;

          if (this._initialValue !== undefined) {
            value = this._initialValue;
            i = 0;
          } else {
            value = Promise.resolve(values[0]);
            i = 1;
          }

          this._currentCancellable = value;

          if (!value.isRejected()) {
            for (; i < length; ++i) {
              var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length,
                array: this
              };
              value = value._then(gotAccum, undefined, undefined, ctx, undefined);
            }
          }

          if (this._eachValues !== undefined) {
            value = value._then(this._eachComplete, undefined, undefined, this, undefined);
          }

          value._then(completed, completed, undefined, value, this);
        };

        Promise.prototype.reduce = function (fn, initialValue) {
          return reduce(this, fn, initialValue, null);
        };

        Promise.reduce = function (promises, fn, initialValue, _each) {
          return reduce(promises, fn, initialValue, _each);
        };

        function completed(valueOrReason, array) {
          if (this.isFulfilled()) {
            array._resolve(valueOrReason);
          } else {
            array._reject(valueOrReason);
          }
        }

        function reduce(promises, fn, initialValue, _each) {
          if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
          }

          var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
          return array.promise();
        }

        function gotAccum(accum) {
          this.accum = accum;

          this.array._gotAccum(accum);

          var value = tryConvertToPromise(this.value, this.array._promise);

          if (value instanceof Promise) {
            this.array._currentCancellable = value;
            return value._then(gotValue, undefined, undefined, this, undefined);
          } else {
            return gotValue.call(this, value);
          }
        }

        function gotValue(value) {
          var array = this.array;
          var promise = array._promise;
          var fn = tryCatch(array._fn);

          promise._pushContext();

          var ret;

          if (array._eachValues !== undefined) {
            ret = fn.call(promise._boundValue(), value, this.index, this.length);
          } else {
            ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
          }

          if (ret instanceof Promise) {
            array._currentCancellable = ret;
          }

          var promiseCreated = promise._popContext();

          debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
          return ret;
        }
      };
    }, {
      "./util": 36
    }],
    29: [function (_dereq_, module, exports) {
      "use strict";

      var util = _dereq_("./util");

      var schedule;

      var noAsyncScheduler = function noAsyncScheduler() {
        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
      };

      var NativePromise = util.getNativePromise();

      if (util.isNode && typeof MutationObserver === "undefined") {
        var GlobalSetImmediate = global.setImmediate;
        var ProcessNextTick = process.nextTick;
        schedule = util.isRecentNode ? function (fn) {
          GlobalSetImmediate.call(global, fn);
        } : function (fn) {
          ProcessNextTick.call(process, fn);
        };
      } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
        var nativePromise = NativePromise.resolve();

        schedule = function schedule(fn) {
          nativePromise.then(fn);
        };
      } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
        schedule = function () {
          var div = document.createElement("div");
          var opts = {
            attributes: true
          };
          var toggleScheduled = false;
          var div2 = document.createElement("div");
          var o2 = new MutationObserver(function () {
            div.classList.toggle("foo");
            toggleScheduled = false;
          });
          o2.observe(div2, opts);

          var scheduleToggle = function scheduleToggle() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
          };

          return function schedule(fn) {
            var o = new MutationObserver(function () {
              o.disconnect();
              fn();
            });
            o.observe(div, opts);
            scheduleToggle();
          };
        }();
      } else if (typeof setImmediate !== "undefined") {
        schedule = function schedule(fn) {
          setImmediate(fn);
        };
      } else if (typeof setTimeout !== "undefined") {
        schedule = function schedule(fn) {
          setTimeout(fn, 0);
        };
      } else {
        schedule = noAsyncScheduler;
      }

      module.exports = schedule;
    }, {
      "./util": 36
    }],
    30: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, debug) {
        var PromiseInspection = Promise.PromiseInspection;

        var util = _dereq_("./util");

        function SettledPromiseArray(values) {
          this.constructor$(values);
        }

        util.inherits(SettledPromiseArray, PromiseArray);

        SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
          this._values[index] = inspection;
          var totalResolved = ++this._totalResolved;

          if (totalResolved >= this._length) {
            this._resolve(this._values);

            return true;
          }

          return false;
        };

        SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
          var ret = new PromiseInspection();
          ret._bitField = 33554432;
          ret._settledValueField = value;
          return this._promiseResolved(index, ret);
        };

        SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
          var ret = new PromiseInspection();
          ret._bitField = 16777216;
          ret._settledValueField = reason;
          return this._promiseResolved(index, ret);
        };

        Promise.settle = function (promises) {
          debug.deprecated(".settle()", ".reflect()");
          return new SettledPromiseArray(promises).promise();
        };

        Promise.prototype.settle = function () {
          return Promise.settle(this);
        };
      };
    }, {
      "./util": 36
    }],
    31: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, PromiseArray, apiRejection) {
        var util = _dereq_("./util");

        var RangeError = _dereq_("./errors").RangeError;

        var AggregateError = _dereq_("./errors").AggregateError;

        var isArray = util.isArray;
        var CANCELLATION = {};

        function SomePromiseArray(values) {
          this.constructor$(values);
          this._howMany = 0;
          this._unwrap = false;
          this._initialized = false;
        }

        util.inherits(SomePromiseArray, PromiseArray);

        SomePromiseArray.prototype._init = function () {
          if (!this._initialized) {
            return;
          }

          if (this._howMany === 0) {
            this._resolve([]);

            return;
          }

          this._init$(undefined, -5);

          var isArrayResolved = isArray(this._values);

          if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
          }
        };

        SomePromiseArray.prototype.init = function () {
          this._initialized = true;

          this._init();
        };

        SomePromiseArray.prototype.setUnwrap = function () {
          this._unwrap = true;
        };

        SomePromiseArray.prototype.howMany = function () {
          return this._howMany;
        };

        SomePromiseArray.prototype.setHowMany = function (count) {
          this._howMany = count;
        };

        SomePromiseArray.prototype._promiseFulfilled = function (value) {
          this._addFulfilled(value);

          if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();

            if (this.howMany() === 1 && this._unwrap) {
              this._resolve(this._values[0]);
            } else {
              this._resolve(this._values);
            }

            return true;
          }

          return false;
        };

        SomePromiseArray.prototype._promiseRejected = function (reason) {
          this._addRejected(reason);

          return this._checkOutcome();
        };

        SomePromiseArray.prototype._promiseCancelled = function () {
          if (this._values instanceof Promise || this._values == null) {
            return this._cancel();
          }

          this._addRejected(CANCELLATION);

          return this._checkOutcome();
        };

        SomePromiseArray.prototype._checkOutcome = function () {
          if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();

            for (var i = this.length(); i < this._values.length; ++i) {
              if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
              }
            }

            if (e.length > 0) {
              this._reject(e);
            } else {
              this._cancel();
            }

            return true;
          }

          return false;
        };

        SomePromiseArray.prototype._fulfilled = function () {
          return this._totalResolved;
        };

        SomePromiseArray.prototype._rejected = function () {
          return this._values.length - this.length();
        };

        SomePromiseArray.prototype._addRejected = function (reason) {
          this._values.push(reason);
        };

        SomePromiseArray.prototype._addFulfilled = function (value) {
          this._values[this._totalResolved++] = value;
        };

        SomePromiseArray.prototype._canPossiblyFulfill = function () {
          return this.length() - this._rejected();
        };

        SomePromiseArray.prototype._getRangeError = function (count) {
          var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
          return new RangeError(message);
        };

        SomePromiseArray.prototype._resolveEmptyArray = function () {
          this._reject(this._getRangeError(0));
        };

        function some(promises, howMany) {
          if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
          }

          var ret = new SomePromiseArray(promises);
          var promise = ret.promise();
          ret.setHowMany(howMany);
          ret.init();
          return promise;
        }

        Promise.some = function (promises, howMany) {
          return some(promises, howMany);
        };

        Promise.prototype.some = function (howMany) {
          return some(this, howMany);
        };

        Promise._SomePromiseArray = SomePromiseArray;
      };
    }, {
      "./errors": 12,
      "./util": 36
    }],
    32: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise) {
        function PromiseInspection(promise) {
          if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
          } else {
            this._bitField = 0;
            this._settledValueField = undefined;
          }
        }

        PromiseInspection.prototype._settledValue = function () {
          return this._settledValueField;
        };

        var value = PromiseInspection.prototype.value = function () {
          if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
          }

          return this._settledValue();
        };

        var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
          if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
          }

          return this._settledValue();
        };

        var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {
          return (this._bitField & 33554432) !== 0;
        };

        var isRejected = PromiseInspection.prototype.isRejected = function () {
          return (this._bitField & 16777216) !== 0;
        };

        var isPending = PromiseInspection.prototype.isPending = function () {
          return (this._bitField & 50397184) === 0;
        };

        var isResolved = PromiseInspection.prototype.isResolved = function () {
          return (this._bitField & 50331648) !== 0;
        };

        PromiseInspection.prototype.isCancelled = function () {
          return (this._bitField & 8454144) !== 0;
        };

        Promise.prototype.__isCancelled = function () {
          return (this._bitField & 65536) === 65536;
        };

        Promise.prototype._isCancelled = function () {
          return this._target().__isCancelled();
        };

        Promise.prototype.isCancelled = function () {
          return (this._target()._bitField & 8454144) !== 0;
        };

        Promise.prototype.isPending = function () {
          return isPending.call(this._target());
        };

        Promise.prototype.isRejected = function () {
          return isRejected.call(this._target());
        };

        Promise.prototype.isFulfilled = function () {
          return isFulfilled.call(this._target());
        };

        Promise.prototype.isResolved = function () {
          return isResolved.call(this._target());
        };

        Promise.prototype.value = function () {
          return value.call(this._target());
        };

        Promise.prototype.reason = function () {
          var target = this._target();

          target._unsetRejectionIsUnhandled();

          return reason.call(target);
        };

        Promise.prototype._value = function () {
          return this._settledValue();
        };

        Promise.prototype._reason = function () {
          this._unsetRejectionIsUnhandled();

          return this._settledValue();
        };

        Promise.PromiseInspection = PromiseInspection;
      };
    }, {}],
    33: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL) {
        var util = _dereq_("./util");

        var errorObj = util.errorObj;
        var isObject = util.isObject;

        function tryConvertToPromise(obj, context) {
          if (isObject(obj)) {
            if (obj instanceof Promise) return obj;
            var then = getThen(obj);

            if (then === errorObj) {
              if (context) context._pushContext();
              var ret = Promise.reject(then.e);
              if (context) context._popContext();
              return ret;
            } else if (typeof then === "function") {
              if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);

                obj._then(ret._fulfill, ret._reject, undefined, ret, null);

                return ret;
              }

              return doThenable(obj, then, context);
            }
          }

          return obj;
        }

        function doGetThen(obj) {
          return obj.then;
        }

        function getThen(obj) {
          try {
            return doGetThen(obj);
          } catch (e) {
            errorObj.e = e;
            return errorObj;
          }
        }

        var hasProp = {}.hasOwnProperty;

        function isAnyBluebirdPromise(obj) {
          try {
            return hasProp.call(obj, "_promise0");
          } catch (e) {
            return false;
          }
        }

        function doThenable(x, then, context) {
          var promise = new Promise(INTERNAL);
          var ret = promise;
          if (context) context._pushContext();

          promise._captureStackTrace();

          if (context) context._popContext();
          var synchronous = true;
          var result = util.tryCatch(then).call(x, resolve, reject);
          synchronous = false;

          if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);

            promise = null;
          }

          function resolve(value) {
            if (!promise) return;

            promise._resolveCallback(value);

            promise = null;
          }

          function reject(reason) {
            if (!promise) return;

            promise._rejectCallback(reason, synchronous, true);

            promise = null;
          }

          return ret;
        }

        return tryConvertToPromise;
      };
    }, {
      "./util": 36
    }],
    34: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, INTERNAL, debug) {
        var util = _dereq_("./util");

        var TimeoutError = Promise.TimeoutError;

        function HandleWrapper(handle) {
          this.handle = handle;
        }

        HandleWrapper.prototype._resultCancelled = function () {
          clearTimeout(this.handle);
        };

        var afterValue = function afterValue(value) {
          return delay(+this).thenReturn(value);
        };

        var delay = Promise.delay = function (ms, value) {
          var ret;
          var handle;

          if (value !== undefined) {
            ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);

            if (debug.cancellation() && value instanceof Promise) {
              ret._setOnCancel(value);
            }
          } else {
            ret = new Promise(INTERNAL);
            handle = setTimeout(function () {
              ret._fulfill();
            }, +ms);

            if (debug.cancellation()) {
              ret._setOnCancel(new HandleWrapper(handle));
            }

            ret._captureStackTrace();
          }

          ret._setAsyncGuaranteed();

          return ret;
        };

        Promise.prototype.delay = function (ms) {
          return delay(ms, this);
        };

        var afterTimeout = function afterTimeout(promise, message, parent) {
          var err;

          if (typeof message !== "string") {
            if (message instanceof Error) {
              err = message;
            } else {
              err = new TimeoutError("operation timed out");
            }
          } else {
            err = new TimeoutError(message);
          }

          util.markAsOriginatingFromRejection(err);

          promise._attachExtraTrace(err);

          promise._reject(err);

          if (parent != null) {
            parent.cancel();
          }
        };

        function successClear(value) {
          clearTimeout(this.handle);
          return value;
        }

        function failureClear(reason) {
          clearTimeout(this.handle);
          throw reason;
        }

        Promise.prototype.timeout = function (ms, message) {
          ms = +ms;
          var ret, parent;
          var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
            if (ret.isPending()) {
              afterTimeout(ret, message, parent);
            }
          }, ms));

          if (debug.cancellation()) {
            parent = this.then();
            ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);

            ret._setOnCancel(handleWrapper);
          } else {
            ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
          }

          return ret;
        };
      };
    }, {
      "./util": 36
    }],
    35: [function (_dereq_, module, exports) {
      "use strict";

      module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
        var util = _dereq_("./util");

        var TypeError = _dereq_("./errors").TypeError;

        var inherits = _dereq_("./util").inherits;

        var errorObj = util.errorObj;
        var tryCatch = util.tryCatch;
        var NULL = {};

        function thrower(e) {
          setTimeout(function () {
            throw e;
          }, 0);
        }

        function castPreservingDisposable(thenable) {
          var maybePromise = tryConvertToPromise(thenable);

          if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
          }

          return maybePromise;
        }

        function dispose(resources, inspection) {
          var i = 0;
          var len = resources.length;
          var ret = new Promise(INTERNAL);

          function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);

            if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
              try {
                maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
              } catch (e) {
                return thrower(e);
              }

              if (maybePromise instanceof Promise) {
                return maybePromise._then(iterator, thrower, null, null, null);
              }
            }

            iterator();
          }

          iterator();
          return ret;
        }

        function Disposer(data, promise, context) {
          this._data = data;
          this._promise = promise;
          this._context = context;
        }

        Disposer.prototype.data = function () {
          return this._data;
        };

        Disposer.prototype.promise = function () {
          return this._promise;
        };

        Disposer.prototype.resource = function () {
          if (this.promise().isFulfilled()) {
            return this.promise().value();
          }

          return NULL;
        };

        Disposer.prototype.tryDispose = function (inspection) {
          var resource = this.resource();
          var context = this._context;
          if (context !== undefined) context._pushContext();
          var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
          if (context !== undefined) context._popContext();

          this._promise._unsetDisposable();

          this._data = null;
          return ret;
        };

        Disposer.isDisposer = function (d) {
          return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
        };

        function FunctionDisposer(fn, promise, context) {
          this.constructor$(fn, promise, context);
        }

        inherits(FunctionDisposer, Disposer);

        FunctionDisposer.prototype.doDispose = function (resource, inspection) {
          var fn = this.data();
          return fn.call(resource, resource, inspection);
        };

        function maybeUnwrapDisposer(value) {
          if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);

            return value.promise();
          }

          return value;
        }

        function ResourceList(length) {
          this.length = length;
          this.promise = null;
          this[length - 1] = null;
        }

        ResourceList.prototype._resultCancelled = function () {
          var len = this.length;

          for (var i = 0; i < len; ++i) {
            var item = this[i];

            if (item instanceof Promise) {
              item.cancel();
            }
          }
        };

        Promise.using = function () {
          var len = arguments.length;
          if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
          var fn = arguments[len - 1];

          if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
          }

          var input;
          var spreadArgs = true;

          if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
          } else {
            input = arguments;
            len--;
          }

          var resources = new ResourceList(len);

          for (var i = 0; i < len; ++i) {
            var resource = input[i];

            if (Disposer.isDisposer(resource)) {
              var disposer = resource;
              resource = resource.promise();

              resource._setDisposable(disposer);
            } else {
              var maybePromise = tryConvertToPromise(resource);

              if (maybePromise instanceof Promise) {
                resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                  resources: resources,
                  index: i
                }, undefined);
              }
            }

            resources[i] = resource;
          }

          var reflectedResources = new Array(resources.length);

          for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
          }

          var resultPromise = Promise.all(reflectedResources).then(function (inspections) {
            for (var i = 0; i < inspections.length; ++i) {
              var inspection = inspections[i];

              if (inspection.isRejected()) {
                errorObj.e = inspection.error();
                return errorObj;
              } else if (!inspection.isFulfilled()) {
                resultPromise.cancel();
                return;
              }

              inspections[i] = inspection.value();
            }

            promise._pushContext();

            fn = tryCatch(fn);
            var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);

            var promiseCreated = promise._popContext();

            debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
            return ret;
          });
          var promise = resultPromise.lastly(function () {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
          });
          resources.promise = promise;

          promise._setOnCancel(resources);

          return promise;
        };

        Promise.prototype._setDisposable = function (disposer) {
          this._bitField = this._bitField | 131072;
          this._disposer = disposer;
        };

        Promise.prototype._isDisposable = function () {
          return (this._bitField & 131072) > 0;
        };

        Promise.prototype._getDisposer = function () {
          return this._disposer;
        };

        Promise.prototype._unsetDisposable = function () {
          this._bitField = this._bitField & ~131072;
          this._disposer = undefined;
        };

        Promise.prototype.disposer = function (fn) {
          if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
          }

          throw new TypeError();
        };
      };
    }, {
      "./errors": 12,
      "./util": 36
    }],
    36: [function (_dereq_, module, exports) {
      "use strict";

      var es5 = _dereq_("./es5");

      var canEvaluate = typeof navigator == "undefined";
      var errorObj = {
        e: {}
      };
      var tryCatchTarget;
      var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this !== undefined ? this : null;

      function tryCatcher() {
        try {
          var target = tryCatchTarget;
          tryCatchTarget = null;
          return target.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }

      function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
      }

      var inherits = function inherits(Child, Parent) {
        var hasProp = {}.hasOwnProperty;

        function T() {
          this.constructor = Child;
          this.constructor$ = Parent;

          for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
              this[propertyName + "$"] = Parent.prototype[propertyName];
            }
          }
        }

        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
      };

      function isPrimitive(val) {
        return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
      }

      function isObject(value) {
        return typeof value === "function" || typeof value === "object" && value !== null;
      }

      function maybeWrapAsError(maybeError) {
        if (!isPrimitive(maybeError)) return maybeError;
        return new Error(safeToString(maybeError));
      }

      function withAppended(target, appendee) {
        var len = target.length;
        var ret = new Array(len + 1);
        var i;

        for (i = 0; i < len; ++i) {
          ret[i] = target[i];
        }

        ret[i] = appendee;
        return ret;
      }

      function getDataPropertyOrDefault(obj, key, defaultValue) {
        if (es5.isES5) {
          var desc = Object.getOwnPropertyDescriptor(obj, key);

          if (desc != null) {
            return desc.get == null && desc.set == null ? desc.value : defaultValue;
          }
        } else {
          return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
        }
      }

      function notEnumerableProp(obj, name, value) {
        if (isPrimitive(obj)) return obj;
        var descriptor = {
          value: value,
          configurable: true,
          enumerable: false,
          writable: true
        };
        es5.defineProperty(obj, name, descriptor);
        return obj;
      }

      function thrower(r) {
        throw r;
      }

      var inheritedDataKeys = function () {
        var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];

        var isExcludedProto = function isExcludedProto(val) {
          for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
              return true;
            }
          }

          return false;
        };

        if (es5.isES5) {
          var getKeys = Object.getOwnPropertyNames;
          return function (obj) {
            var ret = [];
            var visitedKeys = Object.create(null);

            while (obj != null && !isExcludedProto(obj)) {
              var keys;

              try {
                keys = getKeys(obj);
              } catch (e) {
                return ret;
              }

              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (visitedKeys[key]) continue;
                visitedKeys[key] = true;
                var desc = Object.getOwnPropertyDescriptor(obj, key);

                if (desc != null && desc.get == null && desc.set == null) {
                  ret.push(key);
                }
              }

              obj = es5.getPrototypeOf(obj);
            }

            return ret;
          };
        } else {
          var hasProp = {}.hasOwnProperty;
          return function (obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];
            /*jshint forin:false */

            enumeration: for (var key in obj) {
              if (hasProp.call(obj, key)) {
                ret.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }

                ret.push(key);
              }
            }

            return ret;
          };
        }
      }();

      var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;

      function isClass(fn) {
        try {
          if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);
            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
              return true;
            }
          }

          return false;
        } catch (e) {
          return false;
        }
      }

      function toFastProperties(obj) {
        /*jshint -W027,-W055,-W031*/
        function FakeConstructor() {}

        FakeConstructor.prototype = obj;
        var l = 8;

        while (l--) {
          new FakeConstructor();
        }

        return obj;
        eval(obj);
      }

      var rident = /^[a-z$_][a-z$_0-9]*$/i;

      function isIdentifier(str) {
        return rident.test(str);
      }

      function filledRange(count, prefix, suffix) {
        var ret = new Array(count);

        for (var i = 0; i < count; ++i) {
          ret[i] = prefix + i + suffix;
        }

        return ret;
      }

      function safeToString(obj) {
        try {
          return obj + "";
        } catch (e) {
          return "[no string representation]";
        }
      }

      function isError(obj) {
        return obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
      }

      function markAsOriginatingFromRejection(e) {
        try {
          notEnumerableProp(e, "isOperational", true);
        } catch (ignore) {}
      }

      function originatesFromRejection(e) {
        if (e == null) return false;
        return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
      }

      function canAttachTrace(obj) {
        return isError(obj) && es5.propertyIsWritable(obj, "stack");
      }

      var ensureErrorObject = function () {
        if (!("stack" in new Error())) {
          return function (value) {
            if (canAttachTrace(value)) return value;

            try {
              throw new Error(safeToString(value));
            } catch (err) {
              return err;
            }
          };
        } else {
          return function (value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
          };
        }
      }();

      function classString(obj) {
        return {}.toString.call(obj);
      }

      function copyDescriptors(from, to, filter) {
        var keys = es5.names(from);

        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];

          if (filter(key)) {
            try {
              es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
          }
        }
      }

      var asArray = function asArray(v) {
        if (es5.isArray(v)) {
          return v;
        }

        return null;
      };

      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var ArrayFrom = typeof Array.from === "function" ? function (v) {
          return Array.from(v);
        } : function (v) {
          var ret = [];
          var it = v[Symbol.iterator]();
          var itResult;

          while (!(itResult = it.next()).done) {
            ret.push(itResult.value);
          }

          return ret;
        };

        asArray = function asArray(v) {
          if (es5.isArray(v)) {
            return v;
          } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
          }

          return null;
        };
      }

      var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
      var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";

      function env(key) {
        return hasEnvVariables ? process.env[key] : undefined;
      }

      function getNativePromise() {
        if (typeof Promise === "function") {
          try {
            var promise = new Promise(function () {});

            if ({}.toString.call(promise) === "[object Promise]") {
              return Promise;
            }
          } catch (e) {}
        }
      }

      function domainBind(self, cb) {
        return self.bind(cb);
      }

      var ret = {
        isClass: isClass,
        isIdentifier: isIdentifier,
        inheritedDataKeys: inheritedDataKeys,
        getDataPropertyOrDefault: getDataPropertyOrDefault,
        thrower: thrower,
        isArray: es5.isArray,
        asArray: asArray,
        notEnumerableProp: notEnumerableProp,
        isPrimitive: isPrimitive,
        isObject: isObject,
        isError: isError,
        canEvaluate: canEvaluate,
        errorObj: errorObj,
        tryCatch: tryCatch,
        inherits: inherits,
        withAppended: withAppended,
        maybeWrapAsError: maybeWrapAsError,
        toFastProperties: toFastProperties,
        filledRange: filledRange,
        toString: safeToString,
        canAttachTrace: canAttachTrace,
        ensureErrorObject: ensureErrorObject,
        originatesFromRejection: originatesFromRejection,
        markAsOriginatingFromRejection: markAsOriginatingFromRejection,
        classString: classString,
        copyDescriptors: copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
        isNode: isNode,
        hasEnvVariables: hasEnvVariables,
        env: env,
        global: globalObject,
        getNativePromise: getNativePromise,
        domainBind: domainBind
      };

      ret.isRecentNode = ret.isNode && function () {
        var version = process.versions.node.split(".").map(Number);
        return version[0] === 0 && version[1] > 10 || version[0] > 0;
      }();

      if (ret.isNode) ret.toFastProperties(process);

      try {
        throw new Error();
      } catch (e) {
        ret.lastLineError = e;
      }

      module.exports = ret;
    }, {
      "./es5": 13
    }]
  }, {}, [4])(4);
});
;

if (typeof window !== 'undefined' && window !== null) {
  window.P = window.Promise;
} else if (typeof self !== 'undefined' && self !== null) {
  self.P = self.Promise;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10), __webpack_require__(15), __webpack_require__(38).setImmediate))

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * marked - a markdown parser
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */
;

(function (root) {
  'use strict';
  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: noop,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
    heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
    nptable: noop,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    table: noop,
    lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
    paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d+\.)/;
  block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
  block.item = edit(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?-->/;
  block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit(block.paragraph).replace('hr', block.hr).replace('heading', block.heading).replace('lheading', block.lheading).replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();
  /**
   * Normal Block Grammar
   */

  block.normal = merge({}, block);
  /**
   * GFM Block Grammar
   */

  block.gfm = merge({}, block.normal, {
    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
    paragraph: /^/,
    heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
  });
  block.gfm.paragraph = edit(block.paragraph).replace('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|' + block.list.source.replace('\\1', '\\3') + '|').getRegex();
  /**
   * GFM + Tables Block Grammar
   */

  block.tables = merge({}, block.gfm, {
    nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
    table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
  });
  /**
   * Pedantic grammar
   */

  block.pedantic = merge({}, block.normal, {
    html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/
  });
  /**
   * Block Lexer
   */

  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || marked.defaults;
    this.rules = block.normal;

    if (this.options.pedantic) {
      this.rules = block.pedantic;
    } else if (this.options.gfm) {
      if (this.options.tables) {
        this.rules = block.tables;
      } else {
        this.rules = block.gfm;
      }
    }
  }
  /**
   * Expose Block Rules
   */


  Lexer.rules = block;
  /**
   * Static Lex Method
   */

  Lexer.lex = function (src, options) {
    var lexer = new Lexer(options);
    return lexer.lex(src);
  };
  /**
   * Preprocessing
   */


  Lexer.prototype.lex = function (src) {
    src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n');
    return this.token(src, true);
  };
  /**
   * Lexing
   */


  Lexer.prototype.token = function (src, top) {
    src = src.replace(/^ +$/gm, '');
    var next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;

    while (src) {
      // newline
      if (cap = this.rules.newline.exec(src)) {
        src = src.substring(cap[0].length);

        if (cap[0].length > 1) {
          this.tokens.push({
            type: 'space'
          });
        }
      } // code


      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          text: !this.options.pedantic ? rtrim(cap, '\n') : cap
        });
        continue;
      } // fences (gfm)


      if (cap = this.rules.fences.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'code',
          lang: cap[2],
          text: cap[3] || ''
        });
        continue;
      } // heading


      if (cap = this.rules.heading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'heading',
          depth: cap[1].length,
          text: cap[2]
        });
        continue;
      } // table no leading pipe (gfm)


      if (top && (cap = this.rules.nptable.exec(src))) {
        item = {
          type: 'table',
          header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          src = src.substring(cap[0].length);

          for (i = 0; i < item.align.length; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          for (i = 0; i < item.cells.length; i++) {
            item.cells[i] = splitCells(item.cells[i], item.header.length);
          }

          this.tokens.push(item);
          continue;
        }
      } // hr


      if (cap = this.rules.hr.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'hr'
        });
        continue;
      } // blockquote


      if (cap = this.rules.blockquote.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'blockquote_start'
        });
        cap = cap[0].replace(/^ *> ?/gm, ''); // Pass `top` to keep the current
        // "toplevel" state. This is exactly
        // how markdown.pl works.

        this.token(cap, top);
        this.tokens.push({
          type: 'blockquote_end'
        });
        continue;
      } // list


      if (cap = this.rules.list.exec(src)) {
        src = src.substring(cap[0].length);
        bull = cap[2];
        isordered = bull.length > 1;
        listStart = {
          type: 'list_start',
          ordered: isordered,
          start: isordered ? +bull : '',
          loose: false
        };
        this.tokens.push(listStart); // Get each top-level item.

        cap = cap[0].match(this.rules.item);
        listItems = [];
        next = false;
        l = cap.length;
        i = 0;

        for (; i < l; i++) {
          item = cap[i]; // Remove the list item's bullet
          // so it is seen as the next token.

          space = item.length;
          item = item.replace(/^ *([*+-]|\d+\.) +/, ''); // Outdent whatever the
          // list item contains. Hacky.

          if (~item.indexOf('\n ')) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
          } // Determine whether the next list item belongs here.
          // Backpedal if it does not belong in this list.


          if (this.options.smartLists && i !== l - 1) {
            b = block.bullet.exec(cap[i + 1])[0];

            if (bull !== b && !(bull.length > 1 && b.length > 1)) {
              src = cap.slice(i + 1).join('\n') + src;
              i = l - 1;
            }
          } // Determine whether item is loose or not.
          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
          // for discount behavior.


          loose = next || /\n\n(?!\s*$)/.test(item);

          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === '\n';
            if (!loose) loose = next;
          }

          if (loose) {
            listStart.loose = true;
          } // Check for task list items


          istask = /^\[[ xX]\] /.test(item);
          ischecked = undefined;

          if (istask) {
            ischecked = item[1] !== ' ';
            item = item.replace(/^\[[ xX]\] +/, '');
          }

          t = {
            type: 'list_item_start',
            task: istask,
            checked: ischecked,
            loose: loose
          };
          listItems.push(t);
          this.tokens.push(t); // Recurse.

          this.token(item, false);
          this.tokens.push({
            type: 'list_item_end'
          });
        }

        if (listStart.loose) {
          l = listItems.length;
          i = 0;

          for (; i < l; i++) {
            listItems[i].loose = true;
          }
        }

        this.tokens.push({
          type: 'list_end'
        });
        continue;
      } // html


      if (cap = this.rules.html.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: this.options.sanitize ? 'paragraph' : 'html',
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0]
        });
        continue;
      } // def


      if (top && (cap = this.rules.def.exec(src))) {
        src = src.substring(cap[0].length);
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        tag = cap[1].toLowerCase().replace(/\s+/g, ' ');

        if (!this.tokens.links[tag]) {
          this.tokens.links[tag] = {
            href: cap[2],
            title: cap[3]
          };
        }

        continue;
      } // table (gfm)


      if (top && (cap = this.rules.table.exec(src))) {
        item = {
          type: 'table',
          header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/(?: *\| *)?\n$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          src = src.substring(cap[0].length);

          for (i = 0; i < item.align.length; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          for (i = 0; i < item.cells.length; i++) {
            item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
          }

          this.tokens.push(item);
          continue;
        }
      } // lheading


      if (cap = this.rules.lheading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'heading',
          depth: cap[2] === '=' ? 1 : 2,
          text: cap[1]
        });
        continue;
      } // top-level paragraph


      if (top && (cap = this.rules.paragraph.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'paragraph',
          text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
        });
        continue;
      } // text


      if (cap = this.rules.text.exec(src)) {
        // Top-level should never reach here.
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'text',
          text: cap[0]
        });
        continue;
      }

      if (src) {
        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
      }
    }

    return this.tokens;
  };
  /**
   * Inline-Level Grammar
   */


  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noop,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    strong: /^__([^\s])__(?!_)|^\*\*([^\s])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
    em: /^_([^\s_])_(?!_)|^\*([^\s*"<\[])\*(?!\*)|^_([^\s][\s\S]*?[^\s_])_(?!_|[^\s.])|^_([^\s_][\s\S]*?[^\s])_(?!_|[^\s.])|^\*([^\s"<\[][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noop,
    text: /^(`+|[^`])[\s\S]*?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
  };
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace('comment', block._comment).replace('attribute', inline._attribute).getRegex();
  inline._label = /(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|[^\[\]\\])*?/;
  inline._href = /\s*(<(?:\\[<>]?|[^\s<>\\])*>|(?:\\[()]?|\([^\s\x00-\x1f\\]*\)|[^\s\x00-\x1f()\\])*?)/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace('label', inline._label).getRegex();
  /**
   * Normal Inline Grammar
   */

  inline.normal = merge({}, inline);
  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge({}, inline.normal, {
    strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
  });
  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge({}, inline.normal, {
    escape: edit(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^~+(?=\S)([\s\S]*?\S)~+/,
    text: edit(inline.text).replace(']|', '~]|').replace('|$', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|$').getRegex()
  });
  inline.gfm.url = edit(inline.gfm.url).replace('email', inline.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge({}, inline.gfm, {
    br: edit(inline.br).replace('{2,}', '*').getRegex(),
    text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
  });
  /**
   * Inline Lexer & Compiler
   */

  function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = inline.normal;
    this.renderer = this.options.renderer || new Renderer();
    this.renderer.options = this.options;

    if (!this.links) {
      throw new Error('Tokens array requires a `links` property.');
    }

    if (this.options.pedantic) {
      this.rules = inline.pedantic;
    } else if (this.options.gfm) {
      if (this.options.breaks) {
        this.rules = inline.breaks;
      } else {
        this.rules = inline.gfm;
      }
    }
  }
  /**
   * Expose Inline Rules
   */


  InlineLexer.rules = inline;
  /**
   * Static Lexing/Compiling Method
   */

  InlineLexer.output = function (src, links, options) {
    var inline = new InlineLexer(links, options);
    return inline.output(src);
  };
  /**
   * Lexing/Compiling
   */


  InlineLexer.prototype.output = function (src) {
    var out = '',
        link,
        text,
        href,
        title,
        cap,
        prevCapZero;

    while (src) {
      // escape
      if (cap = this.rules.escape.exec(src)) {
        src = src.substring(cap[0].length);
        out += cap[1];
        continue;
      } // autolink


      if (cap = this.rules.autolink.exec(src)) {
        src = src.substring(cap[0].length);

        if (cap[2] === '@') {
          text = escape(this.mangle(cap[1]));
          href = 'mailto:' + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }

        out += this.renderer.link(href, null, text);
        continue;
      } // url (gfm)


      if (!this.inLink && (cap = this.rules.url.exec(src))) {
        if (cap[2] === '@') {
          text = escape(cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);

          text = escape(cap[0]);

          if (cap[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        src = src.substring(cap[0].length);
        out += this.renderer.link(href, null, text);
        continue;
      } // tag


      if (cap = this.rules.tag.exec(src)) {
        if (!this.inLink && /^<a /i.test(cap[0])) {
          this.inLink = true;
        } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
          this.inLink = false;
        }

        if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.inRawBlock = true;
        } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.inRawBlock = false;
        }

        src = src.substring(cap[0].length);
        out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        continue;
      } // link


      if (cap = this.rules.link.exec(src)) {
        src = src.substring(cap[0].length);
        this.inLink = true;
        href = cap[2];

        if (this.options.pedantic) {
          link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          } else {
            title = '';
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : '';
        }

        href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
        out += this.outputLink(cap, {
          href: InlineLexer.escapes(href),
          title: InlineLexer.escapes(title)
        });
        this.inLink = false;
        continue;
      } // reflink, nolink


      if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
        src = src.substring(cap[0].length);
        link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = this.links[link.toLowerCase()];

        if (!link || !link.href) {
          out += cap[0].charAt(0);
          src = cap[0].substring(1) + src;
          continue;
        }

        this.inLink = true;
        out += this.outputLink(cap, link);
        this.inLink = false;
        continue;
      } // strong


      if (cap = this.rules.strong.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
        continue;
      } // em


      if (cap = this.rules.em.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
        continue;
      } // code


      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.codespan(escape(cap[2].trim(), true));
        continue;
      } // br


      if (cap = this.rules.br.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.br();
        continue;
      } // del (gfm)


      if (cap = this.rules.del.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.renderer.del(this.output(cap[1]));
        continue;
      } // text


      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);

        if (this.inRawBlock) {
          out += this.renderer.text(cap[0]);
        } else {
          out += this.renderer.text(escape(this.smartypants(cap[0])));
        }

        continue;
      }

      if (src) {
        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
      }
    }

    return out;
  };

  InlineLexer.escapes = function (text) {
    return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
  };
  /**
   * Compile Link
   */


  InlineLexer.prototype.outputLink = function (cap, link) {
    var href = link.href,
        title = link.title ? escape(link.title) : null;
    return cap[0].charAt(0) !== '!' ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]));
  };
  /**
   * Smartypants Transformations
   */


  InlineLexer.prototype.smartypants = function (text) {
    if (!this.options.smartypants) return text;
    return text // em-dashes
    .replace(/---/g, "\u2014") // en-dashes
    .replace(/--/g, "\u2013") // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
    .replace(/'/g, "\u2019") // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replace(/"/g, "\u201D") // ellipses
    .replace(/\.{3}/g, "\u2026");
  };
  /**
   * Mangle Links
   */


  InlineLexer.prototype.mangle = function (text) {
    if (!this.options.mangle) return text;
    var out = '',
        l = text.length,
        i = 0,
        ch;

    for (; i < l; i++) {
      ch = text.charCodeAt(i);

      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  };
  /**
   * Renderer
   */


  function Renderer(options) {
    this.options = options || marked.defaults;
  }

  Renderer.prototype.code = function (code, lang, escaped) {
    if (this.options.highlight) {
      var out = this.options.highlight(code, lang);

      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }

    if (!lang) {
      return '<pre><code>' + (escaped ? code : escape(code, true)) + '</code></pre>';
    }

    return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + '</code></pre>\n';
  };

  Renderer.prototype.blockquote = function (quote) {
    return '<blockquote>\n' + quote + '</blockquote>\n';
  };

  Renderer.prototype.html = function (html) {
    return html;
  };

  Renderer.prototype.heading = function (text, level, raw) {
    if (this.options.headerIds) {
      return '<h' + level + ' id="' + this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, '-') + '">' + text + '</h' + level + '>\n';
    } // ignore IDs


    return '<h' + level + '>' + text + '</h' + level + '>\n';
  };

  Renderer.prototype.hr = function () {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  };

  Renderer.prototype.list = function (body, ordered, start) {
    var type = ordered ? 'ol' : 'ul',
        startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
  };

  Renderer.prototype.listitem = function (text) {
    return '<li>' + text + '</li>\n';
  };

  Renderer.prototype.checkbox = function (checked) {
    return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
  };

  Renderer.prototype.paragraph = function (text) {
    return '<p>' + text + '</p>\n';
  };

  Renderer.prototype.table = function (header, body) {
    if (body) body = '<tbody>' + body + '</tbody>';
    return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
  };

  Renderer.prototype.tablerow = function (content) {
    return '<tr>\n' + content + '</tr>\n';
  };

  Renderer.prototype.tablecell = function (content, flags) {
    var type = flags.header ? 'th' : 'td';
    var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
    return tag + content + '</' + type + '>\n';
  }; // span level renderer


  Renderer.prototype.strong = function (text) {
    return '<strong>' + text + '</strong>';
  };

  Renderer.prototype.em = function (text) {
    return '<em>' + text + '</em>';
  };

  Renderer.prototype.codespan = function (text) {
    return '<code>' + text + '</code>';
  };

  Renderer.prototype.br = function () {
    return this.options.xhtml ? '<br/>' : '<br>';
  };

  Renderer.prototype.del = function (text) {
    return '<del>' + text + '</del>';
  };

  Renderer.prototype.link = function (href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

    if (href === null) {
      return text;
    }

    var out = '<a href="' + escape(href) + '"';

    if (title) {
      out += ' title="' + title + '"';
    }

    out += '>' + text + '</a>';
    return out;
  };

  Renderer.prototype.image = function (href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

    if (href === null) {
      return text;
    }

    var out = '<img src="' + href + '" alt="' + text + '"';

    if (title) {
      out += ' title="' + title + '"';
    }

    out += this.options.xhtml ? '/>' : '>';
    return out;
  };

  Renderer.prototype.text = function (text) {
    return text;
  };
  /**
   * TextRenderer
   * returns only the textual part of the token
   */


  function TextRenderer() {} // no need for block level renderers


  TextRenderer.prototype.strong = TextRenderer.prototype.em = TextRenderer.prototype.codespan = TextRenderer.prototype.del = TextRenderer.prototype.text = function (text) {
    return text;
  };

  TextRenderer.prototype.link = TextRenderer.prototype.image = function (href, title, text) {
    return '' + text;
  };

  TextRenderer.prototype.br = function () {
    return '';
  };
  /**
   * Parsing & Compiling
   */


  function Parser(options) {
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
  }
  /**
   * Static Parse Method
   */


  Parser.parse = function (src, options) {
    var parser = new Parser(options);
    return parser.parse(src);
  };
  /**
   * Parse Loop
   */


  Parser.prototype.parse = function (src) {
    this.inline = new InlineLexer(src.links, this.options); // use an InlineLexer with a TextRenderer to extract pure text

    this.inlineText = new InlineLexer(src.links, merge({}, this.options, {
      renderer: new TextRenderer()
    }));
    this.tokens = src.reverse();
    var out = '';

    while (this.next()) {
      out += this.tok();
    }

    return out;
  };
  /**
   * Next Token
   */


  Parser.prototype.next = function () {
    return this.token = this.tokens.pop();
  };
  /**
   * Preview Next Token
   */


  Parser.prototype.peek = function () {
    return this.tokens[this.tokens.length - 1] || 0;
  };
  /**
   * Parse Text Tokens
   */


  Parser.prototype.parseText = function () {
    var body = this.token.text;

    while (this.peek().type === 'text') {
      body += '\n' + this.next().text;
    }

    return this.inline.output(body);
  };
  /**
   * Parse Current Token
   */


  Parser.prototype.tok = function () {
    switch (this.token.type) {
      case 'space':
        {
          return '';
        }

      case 'hr':
        {
          return this.renderer.hr();
        }

      case 'heading':
        {
          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)));
        }

      case 'code':
        {
          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
        }

      case 'table':
        {
          var header = '',
              body = '',
              i,
              row,
              cell,
              j; // header

          cell = '';

          for (i = 0; i < this.token.header.length; i++) {
            cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {
              header: true,
              align: this.token.align[i]
            });
          }

          header += this.renderer.tablerow(cell);

          for (i = 0; i < this.token.cells.length; i++) {
            row = this.token.cells[i];
            cell = '';

            for (j = 0; j < row.length; j++) {
              cell += this.renderer.tablecell(this.inline.output(row[j]), {
                header: false,
                align: this.token.align[j]
              });
            }

            body += this.renderer.tablerow(cell);
          }

          return this.renderer.table(header, body);
        }

      case 'blockquote_start':
        {
          body = '';

          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }

          return this.renderer.blockquote(body);
        }

      case 'list_start':
        {
          body = '';
          var ordered = this.token.ordered,
              start = this.token.start;

          while (this.next().type !== 'list_end') {
            body += this.tok();
          }

          return this.renderer.list(body, ordered, start);
        }

      case 'list_item_start':
        {
          body = '';
          var loose = this.token.loose;

          if (this.token.task) {
            body += this.renderer.checkbox(this.token.checked);
          }

          while (this.next().type !== 'list_item_end') {
            body += !loose && this.token.type === 'text' ? this.parseText() : this.tok();
          }

          return this.renderer.listitem(body);
        }

      case 'html':
        {
          // TODO parse inline content if parameter markdown=1
          return this.renderer.html(this.token.text);
        }

      case 'paragraph':
        {
          return this.renderer.paragraph(this.inline.output(this.token.text));
        }

      case 'text':
        {
          return this.renderer.paragraph(this.parseText());
        }
    }
  };
  /**
   * Helpers
   */


  function escape(html, encode) {
    if (encode) {
      if (escape.escapeTest.test(html)) {
        return html.replace(escape.escapeReplace, function (ch) {
          return escape.replacements[ch];
        });
      }
    } else {
      if (escape.escapeTestNoEncode.test(html)) {
        return html.replace(escape.escapeReplaceNoEncode, function (ch) {
          return escape.replacements[ch];
        });
      }
    }

    return html;
  }

  escape.escapeTest = /[&<>"']/;
  escape.escapeReplace = /[&<>"']/g;
  escape.replacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };
  escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';

      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }

      return '';
    });
  }

  function edit(regex, opt) {
    regex = regex.source || regex;
    opt = opt || '';
    return {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(/(^|[^\[])\^/g, '$1');
        regex = regex.replace(name, val);
        return this;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
  }

  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      try {
        var prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, '').toLowerCase();
      } catch (e) {
        return null;
      }

      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return null;
      }
    }

    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }

    try {
      href = encodeURI(href).replace(/%25/g, '%');
    } catch (e) {
      return null;
    }

    return href;
  }

  function resolveUrl(base, href) {
    if (!baseUrls[' ' + base]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (/^[^:]+:\/*[^/]*$/.test(base)) {
        baseUrls[' ' + base] = base + '/';
      } else {
        baseUrls[' ' + base] = rtrim(base, '/', true);
      }
    }

    base = baseUrls[' ' + base];

    if (href.slice(0, 2) === '//') {
      return base.replace(/:[\s\S]*/, ':') + href;
    } else if (href.charAt(0) === '/') {
      return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
    } else {
      return base + href;
    }
  }

  var baseUrls = {};
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

  function noop() {}

  noop.exec = noop;

  function merge(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];

      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }

      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/),
        i = 0;

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leading or trailing whitespace is ignored per the gfm spec
      cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }

    return cells;
  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
  // /c*$/ is vulnerable to REDOS.
  // invert: Remove suffix of non-c chars instead. Default falsey.


  function rtrim(str, c, invert) {
    if (str.length === 0) {
      return '';
    } // Length of suffix matching the invert condition.


    var suffLen = 0; // Step left until we fail to match the invert condition.

    while (suffLen < str.length) {
      var currChar = str.charAt(str.length - suffLen - 1);

      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }

    return str.substr(0, str.length - suffLen);
  }
  /**
   * Marked
   */


  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (callback || typeof opt === 'function') {
      if (!callback) {
        callback = opt;
        opt = null;
      }

      opt = merge({}, marked.defaults, opt || {});
      var highlight = opt.highlight,
          tokens,
          pending,
          i = 0;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      pending = tokens.length;

      var done = function done(err) {
        if (err) {
          opt.highlight = highlight;
          return callback(err);
        }

        var out;

        try {
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!pending) return done();

      for (; i < tokens.length; i++) {
        (function (token) {
          if (token.type !== 'code') {
            return --pending || done();
          }

          return highlight(token.text, token.lang, function (err, code) {
            if (err) return done(err);

            if (code == null || code === token.text) {
              return --pending || done();
            }

            token.text = code;
            token.escaped = true;
            --pending || done();
          });
        })(tokens[i]);
      }

      return;
    }

    try {
      if (opt) opt = merge({}, marked.defaults, opt);
      return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if ((opt || marked.defaults).silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  }
  /**
   * Options
   */


  marked.options = marked.setOptions = function (opt) {
    merge(marked.defaults, opt);
    return marked;
  };

  marked.getDefaults = function () {
    return {
      baseUrl: null,
      breaks: false,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: new Renderer(),
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tables: true,
      xhtml: false
    };
  };

  marked.defaults = marked.getDefaults();
  /**
   * Expose
   */

  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.InlineLexer = InlineLexer;
  marked.inlineLexer = InlineLexer.output;
  marked.parse = marked;

  if (true) {
    module.exports = marked;
  } else {}
})(this || (typeof window !== 'undefined' ? window : global));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))

/***/ }),
/* 268 */
/***/ (function(module) {

module.exports = {"name":"hashbrown-cms","repository":"https://github.com/Putaitu/hashbrown-cms.git","version":"1.0.7","description":"The pluggable CMS","main":"hashbrown.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"author":"Putaitu Productions","license":"MIT","dependencies":{"app-module-path":"^2.2.0","bluebird":"^3.3.3","body-parser":"^1.18.3","cookie-parser":"^1.4.3","express":"^4.16.4","express-ws":"^4.0.0","glob":"^7.0.3","js-beautify":"^1.6.2","marked":"^0.5.2","mongodb":"^2.1.7","multer":"^1.1.0","path-to-regexp":"^1.2.1","production":"0.0.2","pug":"^2.0.0-beta11","rimraf":"^2.5.2","semver":"^5.4.1","webpack":"^4.27.0","yamljs":"^0.3.0"},"devDependencies":{"@babel/core":"^7.0.0","@babel/preset-env":"^7.0.0","babel-loader":"^8.0.0","json-loader":"^0.5.4","webpack-cli":"^3.1.2"}};

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Common

__webpack_require__(186); // Namespaces


window._ = Crisp.Elements;
window.HashBrown = {};
HashBrown.Helpers = __webpack_require__(259);
HashBrown.Views = {};
HashBrown.Models = __webpack_require__(187);
HashBrown.Views.Modals = __webpack_require__(203);
HashBrown.Views.Widgets = __webpack_require__(198); // Helper functions

__webpack_require__(265); // Helper shortcuts


window.debug = HashBrown.Helpers.DebugHelper;
window.UI = HashBrown.Helpers.UIHelper; // --------------------
// Get current user
// --------------------

HashBrown.Helpers.RequestHelper.request('get', 'user').then(function (user) {
  var User = __webpack_require__(197);

  User.current = new User(user);
  return HashBrown.Helpers.RequestHelper.request('get', 'server/projects?ids=true');
}) // --------------------
// Projects
// --------------------
.then(function (projects) {
  projects = projects || [];

  var ProjectEditor = __webpack_require__(270);

  for (var _iterator = projects, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var projectId = _ref;
    var projectEditor = new ProjectEditor({
      modelUrl: '/api/server/projects/' + projectId
    });
    $('.page--dashboard__projects__list').append(projectEditor.$element);
  }
}) // --------------------
// Users
// --------------------
.then(function () {
  if (!currentUserIsAdmin()) {
    return Promise.resolve();
  }

  return HashBrown.Helpers.RequestHelper.request('get', 'users');
}).then(function (users) {
  var UserEditor = __webpack_require__(227);

  var User = __webpack_require__(197);

  var _loop = function _loop() {
    if (_isArray2) {
      if (_i2 >= _iterator2.length) return "break";
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) return "break";
      _ref2 = _i2.value;
    }

    var user = _ref2;
    user = new User(user);
    var $user = void 0;
    var $projectList = void 0;

    var renderUser = function renderUser() {
      _.append($user.empty(), _.button({
        class: 'widget widget--button expanded low list-item',
        title: 'Edit user'
      }, _.span({
        class: 'fa fa-' + (user.isAdmin ? 'black-tie' : 'user')
      }), (user.fullName || user.username || user.email || user.id) + (user.id == User.current.id ? ' (you)' : '')).on('click', function () {
        var userEditor = new UserEditor({
          model: user
        });
        userEditor.on('save', function () {
          renderUser();
        });
      }), _.if(user.id !== User.current.id, _.button({
        class: 'widget widget--button small fa fa-remove',
        title: 'Remove user'
      }).on('click', function () {
        UI.confirmModal('remove', 'Delete user "' + (user.fullName || user.username || user.email || user.id) + '"', 'Are you sure you want to remove this user?', function () {
          HashBrown.Helpers.RequestHelper.request('delete', 'user/' + user.id).then(function () {
            $user.remove();
          }).catch(UI.errorModal);
        });
      })));
    };

    $('.page--dashboard__users__list').append($user = _.div({
      class: 'widget-group page--dashboard__users__list__user'
    }));
    renderUser();
  };

  for (var _iterator2 = users || [], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
    var _ref2;

    var _ret = _loop();

    if (_ret === "break") break;
  }
}) // --------------------
// Restart button
// --------------------
.then(function () {
  if (!currentUserIsAdmin()) {
    return Promise.resolve();
  }

  $('.page--dashboard__restart').click(function () {
    HashBrown.Helpers.RequestHelper.request('post', 'server/restart').then(function () {
      HashBrown.Helpers.RequestHelper.listenForRestart();
    });
  });
}) // --------------------
// Updates
// --------------------
.then(function () {
  if (!currentUserIsAdmin()) {
    return;
  }

  var $btnUpdate = _.find('.page--dashboard__update');

  return HashBrown.Helpers.RequestHelper.request('get', 'server/update/check').then(function (update) {
    $btnUpdate.removeClass('working');

    if (update.isBehind) {
      $btnUpdate.attr('title', 'Update is available (' + update.remoteVersion + ')');
      $btnUpdate.click(function () {
        UI.messageModal('Update', 'HashBrown is upgrading from ' + update.localVersion + ' to ' + update.remoteVersion + ' (this may take a minute)...', false);
        HashBrown.Helpers.RequestHelper.request('post', 'server/update/start').then(function () {
          UI.messageModal('Success', 'HashBrown is restarting...', false);
          HashBrown.Helpers.RequestHelper.listenForRestart();
        }).catch(UI.errorModal);
      });
    } else {
      $btnUpdate.attr('disabled', true);
      $btnUpdate.addClass('disabled');
      $btnUpdate.attr('title', 'HashBrown is up to date');
    }
  });
}).catch(UI.errorModal); // --------------------
// Invite a user
// --------------------

$('.page--dashboard__users__add').click(function () {
  HashBrown.Helpers.RequestHelper.customRequest('get', '/api/users').then(function (users) {
    /**
     * Generate password
     */
    function generatePassword() {
      var length = 8,
          charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
          retVal = "";

      for (var i = 0, n = charset.length; i < length; ++i) {
        retVal += charset.charAt(Math.floor(Math.random() * n));
      }

      return retVal;
    }
    /**
     * Event: On submit user changes
     */


    function onSubmit() {
      var username = addUserModal.$element.find('input').val();
      var currentUsername = HashBrown.Models.User.current.fullName || HashBrown.Models.User.current.username; // Check if username was email

      var emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      var isEmail = emailRegex.test(username); // Check if en existing user has the same information

      var existingUser = users.filter(function (user) {
        return user.username == username || user.email == username;
      })[0]; // The user was found

      if (existingUser) {
        UI.errorModal(new Error('User "' + username + '" already exists'));
        return;
      } // An email was provided, send invitation


      if (isEmail) {
        var _modal = UI.confirmModal('invite', 'Add user', 'Do you want to invite a new user with email "' + username + '"?', function () {
          HashBrown.Helpers.RequestHelper.customRequest('post', '/api/user/invite', {
            email: username
          }).then(function (token) {
            var subject = 'Invitation to HashBrown';
            var url = location.protocol + '//' + location.host + '/login?inviteToken=' + token;
            var body = 'You have been invited by ' + currentUsername + ' to join a HashBrown instance.%0D%0APlease go to this URL to activate your account: %0D%0A' + url;
            var href = 'mailto:' + username + '?subject=' + subject + '&body=' + body;
            location.href = href;
            UI.messageModal('Created invitation for "' + username + '"', 'Make sure to send the new user this link: <a href="' + url + '">' + url + '</a>', function () {
              location.reload();
            });
          }).catch(UI.errorModal);

          var $buttons = _modal.$element.find('button').attr('disabled', true).addClass('disabled');

          return false;
        });

        return;
      } // User doesn't exist, create it


      var $passwd;
      var modal = UI.messageModal('Add user', _.div({
        class: 'widget-group'
      }, _.label({
        class: 'widget widget--label'
      }, 'Password for new user "' + username + '"'), $passwd = _.input({
        required: true,
        pattern: '.{6,}',
        class: 'widget widget--input text',
        type: 'text',
        value: generatePassword(),
        placeholder: 'Type new password'
      })), function () {
        var password = $passwd.val() || '';
        var scopes = {};
        UI.messageModal('Creating user', 'Creating user "' + username + '"...');
        HashBrown.Helpers.RequestHelper.request('post', 'user/new', {
          username: username,
          password: password,
          scopes: {}
        }).then(function () {
          UI.messageModal('Create user', 'User "' + username + '" was created with password "' + password + '".', function () {
            location.reload();
          });
        }).catch(UI.errorModal);
      });
    } // Renders the modal


    var addUserModal = UI.messageModal('Add user', _.div({
      class: 'widget-group'
    }, _.div({
      class: 'widget widget--label'
    }, 'Username or email'), new HashBrown.Views.Widgets.Input({
      placeholder: 'Input username or email'
    }).$element), onSubmit);
  }).catch(UI.errorModal);
}); // --------------------
// Create project
// --------------------

$('.page--dashboard__projects__add').click(function () {
  var modal = new HashBrown.Views.Modals.Modal({
    title: 'Create new project',
    body: _.div({
      class: 'widget-group'
    }, _.label({
      class: 'widget widget--label'
    }, 'Project name'), new HashBrown.Views.Widgets.Input({
      placeholder: 'example.com'
    }).$element),
    actions: [{
      label: 'Create',
      onClick: function onClick(e) {
        var name = modal.$element.find('input').val();

        if (name) {
          HashBrown.Helpers.RequestHelper.request('post', 'server/projects/new', {
            name: name
          }).then(function () {
            location.reload();
          }).catch(UI.errorModal);
        }

        return false;
      }
    }]
  });
});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Project = __webpack_require__(195);

var RequestHelper = __webpack_require__(3);

var InfoEditor = __webpack_require__(271);

var SyncEditor = __webpack_require__(272);

var LanguageEditor = __webpack_require__(273);

var BackupEditor = __webpack_require__(274);

var MigrationEditor = __webpack_require__(275);
/**
 * The editor for projects as seen on the dashboard
 *
 * @memberof HashBrown.Client.Views.Dashboard
 */


var ProjectEditor =
/*#__PURE__*/
function (_Crisp$View) {
  _inheritsLoose(ProjectEditor, _Crisp$View);

  function ProjectEditor(params) {
    var _this;

    _this = _Crisp$View.call(this, params) || this;

    _.append(_this.element, _.div({
      class: 'widget--spinner embedded'
    }, _.div({
      class: 'widget--spinner__image fa fa-refresh'
    })));

    _this.fetch();

    return _this;
  }
  /**
   * Event: Click remove button
   */


  var _proto = ProjectEditor.prototype;

  _proto.onClickRemove = function onClickRemove() {
    var _this2 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var modal = new HashBrown.Views.Modals.Modal({
      title: 'Delete ' + this.model.settings.info.name,
      body: _.div({
        class: 'widget-group'
      }, _.p({
        class: 'widget widget--label'
      }, 'Type the project name to confirm'), _.input({
        class: 'widget widget--input text',
        type: 'text',
        placeholder: this.model.settings.info.name
      }).on('input', function (e) {
        var $btn = modal.$element.find('.widget.warning');

        var isMatch = $(e.target).val() == _this2.model.settings.info.name;

        $btn.toggleClass('disabled', !isMatch);
      })),
      actions: [{
        label: 'Cancel',
        class: 'default'
      }, {
        label: 'Delete',
        class: 'warning disabled',
        onClick: function onClick() {
          RequestHelper.request('delete', 'server/projects/' + _this2.model.id).then(function () {
            location.reload();
          }).catch(UI.errorModal);
        }
      }]
    });
  };
  /**
   * Event: Click remove environment
   *
   * @param {String} environmentName
   */


  _proto.onClickRemoveEnvironment = function onClickRemoveEnvironment(environmentName) {
    var _this3 = this;

    var modal = UI.confirmModal('Remove', 'Remove environment "' + environmentName + '"', 'Are you sure want to remove the environment "' + environmentName + '" from the project "' + (this.model.settings.info.name || this.model.id) + '"?', function () {
      RequestHelper.request('delete', 'server/projects/' + _this3.model.id + '/' + environmentName).then(function () {
        _this3.model = null;

        _this3.fetch();
      }).catch(UI.errorModal);
    });
  };
  /**
   * Event: Click info button */


  _proto.onClickInfo = function onClickInfo() {
    var _this4 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var infoEditor = new InfoEditor({
      modelUrl: '/api/server/projects/' + this.model.id
    });
    infoEditor.on('change', function (newInfo) {
      _this4.model = null;

      _this4.fetch();
    });
  };
  /**
   * Event: Click sync button
   */


  _proto.onClickSync = function onClickSync() {
    var _this5 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var syncEditor = new SyncEditor({
      projectId: this.model.id,
      modelUrl: '/api/' + this.model.id + '/settings/sync'
    });
    syncEditor.on('change', function (newSettings) {
      _this5.model = null;

      _this5.fetch();
    });
  };
  /**
   * Event: Click languages button
   */


  _proto.onClickLanguages = function onClickLanguages() {
    var _this6 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var languageEditor = new LanguageEditor({
      modelUrl: '/api/server/projects/' + this.model.id
    });
    languageEditor.on('change', function () {
      _this6.model = null;

      _this6.fetch();
    });
  };
  /**
   * Event: Click backups button
   */


  _proto.onClickBackups = function onClickBackups() {
    var _this7 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var backupEditor = new BackupEditor({
      modelUrl: '/api/server/projects/' + this.model.id
    });
    backupEditor.on('change', function () {
      _this7.model = null;

      _this7.fetch();
    });
  };
  /**
   * Event: Click migration button
   */


  _proto.onClickMigrate = function onClickMigrate() {
    var _this8 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    if (this.model.environments.length < 2) {
      UI.errorModal(new Error('You need at least 2 environments to migrate content'));
      return;
    }

    var migrationEditor = new MigrationEditor({
      model: this.model
    });
    migrationEditor.on('change', function () {
      _this8.model = null;

      _this8.fetch();
    });
  };
  /**
   * Event: Click add environment button
   */


  _proto.onClickAddEnvironment = function onClickAddEnvironment() {
    var _this9 = this;

    var modal = new HashBrown.Views.Modals.Modal({
      title: 'New environment for "' + this.model.id + '"',
      body: _.div({
        class: 'widget-group'
      }, _.label({
        class: 'widget widget--label'
      }, 'Environment name'), new HashBrown.Views.Widgets.Input({
        placeholder: 'i.e. "testing" or "staging"'
      })),
      actions: [{
        label: 'Create',
        onClick: function onClick() {
          var environmentName = modal.$element.find('input').val();

          if (!environmentName) {
            return false;
          }

          RequestHelper.request('put', 'server/projects/' + _this9.model.id + '/' + environmentName).then(function () {
            modal.close();
            _this9.model = null;

            _this9.fetch();
          }).catch(UI.errorModal);
          return false;
        }
      }]
    });
  };
  /**
   * Pre render
   */


  _proto.prerender = function prerender() {
    if (this.model instanceof HashBrown.Models.Project === false) {
      this.model = new HashBrown.Models.Project(this.model);
    }
  };
  /**
   * Renders this editor
   */


  _proto.template = function template() {
    var _this10 = this;

    var languageCount = this.model.settings.languages.length;
    var userCount = this.model.users.length;
    return _.div({
      class: 'page--dashboard__project in'
    }, _.div({
      class: 'page--dashboard__project__body'
    }, _.if(currentUserIsAdmin(), new HashBrown.Views.Widgets.Dropdown({
      icon: 'ellipsis-v',
      reverseKeys: true,
      options: {
        'Info': function Info() {
          _this10.onClickInfo();
        },
        'Languages': function Languages() {
          _this10.onClickLanguages();
        },
        'Backups': function Backups() {
          _this10.onClickBackups();
        },
        'Sync': function Sync() {
          _this10.onClickSync();
        },
        'Delete': function Delete() {
          _this10.onClickRemove();
        },
        'Migrate content': function MigrateContent() {
          _this10.onClickMigrate();
        }
      }
    }).$element.addClass('page--dashboard__project__menu')), _.div({
      class: 'page--dashboard__project__info'
    }, _.h4(this.model.settings.info.name || this.model.id), _.p(userCount + ' user' + (userCount != 1 ? 's' : '')), _.p(languageCount + ' language' + (languageCount != 1 ? 's' : '') + ' (' + this.model.settings.languages.join(', ') + ')')), _.div({
      class: 'page--dashboard__project__environments'
    }, _.each(this.model.environments, function (i, environment) {
      return _.div({
        class: 'page--dashboard__project__environment'
      }, _.a({
        title: 'Go to "' + environment + '" CMS',
        href: '/' + _this10.model.id + '/' + environment,
        class: 'widget widget--button expanded'
      }, environment), _.if(currentUserIsAdmin(), new HashBrown.Views.Widgets.Dropdown({
        icon: 'ellipsis-v',
        reverseKeys: true,
        options: {
          'Delete': function Delete() {
            _this10.onClickRemoveEnvironment(environment);
          }
        }
      }).$element.addClass('page--dashboard__project__environment__menu')));
    }), _.if(currentUserIsAdmin(), _.button({
      title: 'Add environment',
      class: 'widget widget--button round right fa fa-plus'
    }).click(function () {
      _this10.onClickAddEnvironment();
    })))));
  };

  return ProjectEditor;
}(Crisp.View);

module.exports = ProjectEditor;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var SettingsHelper = __webpack_require__(208);
/**
 * The info settings editor
 *
 * @memberof HashBrown.Client.Views.Dashboard
 */


var InfoEditor =
/*#__PURE__*/
function (_HashBrown$Views$Moda) {
  _inheritsLoose(InfoEditor, _HashBrown$Views$Moda);

  function InfoEditor(params) {
    var _this;

    params.title = 'Project info';
    params.actions = [{
      label: 'Save',
      onClick: function onClick() {
        _this.onClickSave();

        return false;
      }
    }];
    params.autoFetch = false;
    _this = _HashBrown$Views$Moda.call(this, params) || this;

    _this.fetch();

    return _this;
  }
  /**
   * Event: Click save. Posts the model to the modelUrl
   */


  var _proto = InfoEditor.prototype;

  _proto.onClickSave = function onClickSave() {
    var _this2 = this;

    SettingsHelper.setSettings(this.model.id, null, 'info', this.model.settings.info).then(function () {
      _this2.close();

      _this2.trigger('change', _this2.model);
    }).catch(UI.errorModal);
  };
  /**
   * Renders the modal body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    var _this3 = this;

    if (!this.model) {
      return;
    }

    return _.div({
      class: 'widget-group'
    }, _.span({
      class: 'widget widget--label'
    }, 'Name'), new HashBrown.Views.Widgets.Input({
      value: this.model.settings.info.name,
      onChange: function onChange(newName) {
        _this3.model.settings.info.name = newName;
      }
    }));
  };

  return InfoEditor;
}(HashBrown.Views.Modals.Modal);

module.exports = InfoEditor;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestHelper = __webpack_require__(3);

var SettingsHelper = __webpack_require__(208);

var ProjectHelper = __webpack_require__(7);
/**
 * The sync settings editor
 *
 * @memberof HashBrown.Client.Views.Dashboard
 */


var SyncEditor =
/*#__PURE__*/
function (_HashBrown$Views$Moda) {
  _inheritsLoose(SyncEditor, _HashBrown$Views$Moda);

  function SyncEditor(params) {
    var _this;

    params.title = 'Sync';
    params.actions = [{
      label: 'Apply',
      class: 'btn-primary',
      onClick: function onClick() {
        _this.onClickApply();

        return false;
      }
    }, {
      label: 'Save',
      class: 'btn-primary',
      onClick: function onClick() {
        _this.onClickSave();

        return false;
      }
    }];
    params.autoFetch = false;
    _this = _HashBrown$Views$Moda.call(this, params) || this;

    _this.fetch();

    return _this;
  }
  /**
   * Event: Click save. Posts the model to the modelUrl and closes
   */


  var _proto = SyncEditor.prototype;

  _proto.onClickSave = function onClickSave() {
    var _this2 = this;

    this.model.url = this.$element.find('input[name="url"]').val();
    SettingsHelper.setSettings(this.projectId, '', 'sync', this.model).then(function () {
      _this2.close();

      _this2.trigger('change', _this2.model);
    }).catch(UI.errorModal);
  };
  /**
   * Event: Click apply. Posts the model to the modelUrl
   */


  _proto.onClickApply = function onClickApply() {
    var _this3 = this;

    this.model.url = this.$element.find('input[name="url"]').val();
    SettingsHelper.setSettings(this.projectId, '', 'sync', this.model).then(function () {
      _this3.trigger('change', _this3.model);
    }).catch(UI.errorModal);
  };
  /**
   * Render enabled switch
   */


  _proto.renderEnabledSwitch = function renderEnabledSwitch() {
    var _this4 = this;

    return new HashBrown.Views.Widgets.Input({
      type: 'checkbox',
      name: 'enabled',
      value: this.model.enabled === true,
      onChange: function onChange(newValue) {
        _this4.model.enabled = newValue;
      }
    }).$element;
  };
  /**
   * Renders the URL editor
   *
   * @returns {HTMLElement} Element
   */


  _proto.renderUrlEditor = function renderUrlEditor() {
    return new HashBrown.Views.Widgets.Input({
      name: 'url',
      type: 'text',
      value: this.model.url || '',
      placeholder: 'e.g. "https://myserver.com/api/"'
    }).$element;
  };
  /**
   * Renders the project id editor
   *
   * @returns {HTMLElement} Element
   */


  _proto.renderProjectIdEditor = function renderProjectIdEditor() {
    var _this5 = this;

    return new HashBrown.Views.Widgets.Input({
      name: 'name',
      value: this.model.project,
      onChange: function onChange(newValue) {
        _this5.model.project = newValue;
      }
    }).$element;
  };
  /**
   * Renders the token editor
   *
   * @returns {HTMLElement} Element
   */


  _proto.renderTokenEditor = function renderTokenEditor() {
    var _this6 = this;

    return [new HashBrown.Views.Widgets.Input({
      value: this.model.token,
      name: 'token',
      placeholder: 'API token',
      onChange: function onChange(newToken) {
        _this6.model.token = newToken;
      }
    }).$element, _.button({
      class: 'widget widget--button small fa fa-refresh'
    }).on('click', function () {
      if (!_this6.model.url) {
        alert('You need to specify a URL. Please do so and apply the settings first.');
        return;
      }

      var tokenModal = new HashBrown.Views.Modals.Modal({
        title: 'Refresh token',
        body: [_.div({
          class: 'widget-group'
        }, _.label({
          class: 'widget widget--label'
        }, 'Username'), _.input({
          class: 'widget widget--input text',
          type: 'text'
        })), _.div({
          class: 'widget-group'
        }, _.label({
          class: 'widget widget--label'
        }, 'Password'), _.input({
          class: 'widget widget--input text',
          type: 'password'
        }))],
        actions: [{
          label: 'Get token',
          onClick: function onClick() {
            var username = tokenModal.element.querySelector('input[type="text"]').value;
            var password = tokenModal.element.querySelector('input[type="password"]').value;
            RequestHelper.request('post', _this6.projectId + '/sync/login', {
              username: username,
              password: password
            }).then(function (token) {
              _this6.model.token = token;
              _this6.element.querySelector('input[name="token"]').value = token;
            }).catch(UI.errorModal);
          }
        }]
      });
    })];
  };
  /**
   * Renders a single field
   *
   * @param {String} label
   * @param {HTMLElement} $content
   *
   * @return {HTMLElement} Editor element
   */


  _proto.renderField = function renderField(label, $content) {
    return _.div({
      class: 'widget-group'
    }, _.div({
      class: 'widget widget--label'
    }, label), $content);
  };
  /**
   * Renders the modal body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    return [this.renderField('Enabled', this.renderEnabledSwitch()), this.renderField('API URL', this.renderUrlEditor()), this.renderField('API Token', this.renderTokenEditor()), this.renderField('Project id', this.renderProjectIdEditor())];
  };

  return SyncEditor;
}(HashBrown.Views.Modals.Modal);

module.exports = SyncEditor;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var LanguageHelper = __webpack_require__(248);
/**
 * The language settings editor
 *
 * @memberof HashBrown.Client.Views.Dashboard
 */


var LanguageEditor =
/*#__PURE__*/
function (_HashBrown$Views$Moda) {
  _inheritsLoose(LanguageEditor, _HashBrown$Views$Moda);

  function LanguageEditor(params) {
    var _this;

    params.title = 'Languages';
    params.actions = [{
      label: 'Save',
      onClick: function onClick() {
        _this.onClickSave();

        return false;
      }
    }];
    params.autoFetch = false;
    _this = _HashBrown$Views$Moda.call(this, params) || this;

    _this.fetch();

    return _this;
  }
  /**
   * Event: Click save
   */


  var _proto = LanguageEditor.prototype;

  _proto.onClickSave = function onClickSave() {
    var _this2 = this;

    LanguageHelper.setLanguages(this.model.id, this.model.settings.languages).then(function () {
      _this2.close();

      _this2.trigger('change');
    }).catch(UI.errorModal);
  };
  /**
   * Renders the modal body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    var _this3 = this;

    return _.div({
      class: 'widget-group'
    }, _.label({
      class: 'widget widget--label'
    }, 'Selected languages'), new HashBrown.Views.Widgets.Dropdown({
      value: this.model.settings.languages,
      useTypeAhead: true,
      useMultiple: true,
      options: LanguageHelper.getLanguageOptions(this.model.id),
      onChange: function onChange(newValue) {
        _this3.model.settings.languages = newValue;
      }
    }).$element);
  };

  return LanguageEditor;
}(HashBrown.Views.Modals.Modal);

module.exports = LanguageEditor;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestHelper = __webpack_require__(3);
/**
 * The project backup editor
 *
 * @memberof HashBrown.Client.Views.Dashboard
 */


var BackupEditor =
/*#__PURE__*/
function (_HashBrown$Views$Moda) {
  _inheritsLoose(BackupEditor, _HashBrown$Views$Moda);

  function BackupEditor() {
    return _HashBrown$Views$Moda.apply(this, arguments) || this;
  }

  var _proto = BackupEditor.prototype;

  /**
   * Event: Click upload button
   */
  _proto.onClickUploadBackup = function onClickUploadBackup() {
    var _this = this;

    var uploadModal = new HashBrown.Views.Modals.Modal({
      title: 'Upload a backup file',
      body: new HashBrown.Views.Widgets.Input({
        type: 'file',
        name: 'backup',
        onSubmit: function onSubmit(formData) {
          var apiPath = 'server/backups/' + _this.model.id + '/upload'; // TODO: Use the RequestHelper for this

          $.ajax({
            url: RequestHelper.environmentUrl(apiPath),
            type: 'POST',
            data: formData,
            processData: false,
            contentType: false,
            success: function success(id) {
              _this.model = null;

              _this.fetch();

              uploadModal.close();
            }
          });
        }
      }).$element,
      actions: [{
        label: 'OK',
        onClick: function onClick() {
          uploadModal.$element.find('form').submit();
          return false;
        }
      }]
    });
  };
  /**
   * Event: Click backup button
   */


  _proto.onClickCreateBackup = function onClickCreateBackup() {
    var _this2 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    RequestHelper.request('post', 'server/backups/' + this.model.id + '/new').then(function (data) {
      _this2.model = null;

      _this2.fetch();
    }).catch(UI.errorModal);
  };
  /**
   * Event: Click restore backup button
   *
   * @param {String} timestamp
   */


  _proto.onClickRestoreBackup = function onClickRestoreBackup(timestamp) {
    var _this3 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var label = '"' + timestamp + '"';
    var date = new Date(parseInt(timestamp));

    if (!isNaN(date.getTime())) {
      label = date.toString();
    }

    var modal = UI.confirmModal('restore', 'Restore backup', 'Are you sure you want to restore the backup ' + label + '? Current content will be replaced.', function () {
      RequestHelper.request('post', 'server/backups/' + _this3.model.id + '/' + timestamp + '/restore').then(function () {
        modal.close();

        _this3.trigger('change');

        _this3.close();
      }).catch(UI.errorModal);
    });
  };
  /**
   * Event: Click delete backup button
   */


  _proto.onClickDeleteBackup = function onClickDeleteBackup(timestamp) {
    var _this4 = this;

    if (!currentUserIsAdmin()) {
      return;
    }

    var label = timestamp;
    var date = new Date(parseInt(timestamp));

    if (!isNaN(date.getTime())) {
      label = date.toString();
    }

    var modal = UI.confirmModal('delete', 'Delete backup', 'Are you sure you want to delete the backup "' + label + '"?', function () {
      RequestHelper.request('delete', 'server/backups/' + _this4.model.id + '/' + timestamp).then(function () {
        modal.close();
        _this4.model = null;

        _this4.fetch();
      }).catch(UI.errorModal);
    });
  };
  /**
   * Pre render
   */


  _proto.prerender = function prerender() {
    var _this5 = this;

    if (this.model instanceof HashBrown.Models.Project === false) {
      this.model = new HashBrown.Models.Project(this.model);
    }

    this.title = this.model.settings.info.name + ' backups';
    this.body = _.div(_.if(!this.model.backups || this.model.backups.length < 1, _.label({
      class: 'widget widget--label'
    }, 'No backups yet')), // List existing backups
    _.each(this.model.backups, function (i, backup) {
      var label = backup;
      var date = new Date(parseInt(backup));

      if (!isNaN(date.getTime())) {
        label = date.toString();
      }

      return _.div({
        class: 'page--dashboard__backup-editor__backup widget-group'
      }, _.p({
        class: 'widget widget--label page--dashboard__backup-editor__back__label'
      }, label), new HashBrown.Views.Widgets.Dropdown({
        icon: 'ellipsis-v',
        reverseKeys: true,
        options: {
          'Restore': function Restore() {
            _this5.onClickRestoreBackup(backup);
          },
          'Download': function Download() {
            location = RequestHelper.environmentUrl('server/backups/' + _this5.model.id + '/' + backup + '.hba');
          },
          'Delete': function Delete() {
            _this5.onClickDeleteBackup(backup);
          }
        }
      }).$element);
    }));
  };
  /**
   * Renders the modal footer
   *
   * @returns {HTMLElement} Footer
   */


  _proto.renderFooter = function renderFooter() {
    var _this6 = this;

    return [_.button({
      class: 'widget widget--button',
      title: 'Upload backup'
    }, 'Upload').click(function () {
      _this6.onClickUploadBackup();
    }), _.button({
      class: 'widget widget--button',
      title: 'Create a new backup'
    }, 'Create').click(function () {
      _this6.onClickCreateBackup();
    })];
  };

  return BackupEditor;
}(HashBrown.Views.Modals.Modal);

module.exports = BackupEditor;

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestHelper = __webpack_require__(3);
/**
 * The editor for migrating content between environments
 *
 * @memberof HashBrown.Client.Views.Dashboard
 */


var MigrationEditor =
/*#__PURE__*/
function (_HashBrown$Views$Moda) {
  _inheritsLoose(MigrationEditor, _HashBrown$Views$Moda);

  function MigrationEditor(params) {
    var _this;

    params.title = 'Migrate content';
    params.actions = [{
      label: 'Migrate',
      onClick: function onClick() {
        _this.onSubmit();

        return false;
      }
    }];
    params.data = {
      from: params.model.environments[0],
      to: '',
      settings: {
        schemas: true,
        replace: true
      }
    };
    return _this = _HashBrown$Views$Moda.call(this, params) || this;
  }
  /**
   * Pre render
   */


  var _proto = MigrationEditor.prototype;

  _proto.prerender = function prerender() {
    if (!this.data.to || this.getToOptions().indexOf(this.data.to) < 0) {
      this.data.to = this.getToOptions()[0];
    }
  };
  /**
   * Renders this modal body
   *
   * @returns {HTMLElement} Body
   */


  _proto.renderBody = function renderBody() {
    var _this2 = this;

    return [_.div({
      class: 'widget-group'
    }, new HashBrown.Views.Widgets.Dropdown({
      value: this.data.from,
      options: this.model.environments,
      onChange: function onChange(newValue) {
        _this2.data.from = newValue;

        _this2.fetch();
      }
    }).$element, _.div({
      class: 'widget-group__separator fa fa-arrow-right'
    }), new HashBrown.Views.Widgets.Dropdown({
      value: this.data.to,
      options: this.getToOptions(),
      onChange: function onChange(newValue) {
        _this2.data.to = newValue;
      }
    }).$element), _.each({
      replace: 'Overwrite on target',
      schemas: 'Schemas',
      content: 'Content',
      forms: 'Forms',
      media: 'Media',
      connections: 'Connections'
    }, function (key, label) {
      return _.div({
        class: 'widget-group'
      }, _.label({
        class: 'widget widget--label'
      }, label), new HashBrown.Views.Widgets.Input({
        type: 'checkbox',
        value: _this2.data.settings[key] === true,
        onChange: function onChange(newValue) {
          _this2.data.settings[key] = newValue;
        }
      }).$element);
    })];
  };
  /**
   * Gets the displayed "to" options
   */


  _proto.getToOptions = function getToOptions() {
    var _this3 = this;

    return this.model.environments.filter(function (environment) {
      return environment !== _this3.data.from;
    });
  };
  /**
   * Event: Clicked submit
   */


  _proto.onSubmit = function onSubmit() {
    var _this4 = this;

    RequestHelper.request('post', 'server/migrate/' + this.model.id, this.data).then(function () {
      UI.messageModal('Success', 'Successfully migrated content from "' + _this4.data.from + '" to "' + _this4.data.to + '"', function () {
        _this4.trigger('change');

        _this4.close();
      });
    }).catch(UI.errorModal);
  };

  return MigrationEditor;
}(HashBrown.Views.Modals.Modal);

module.exports = MigrationEditor;

/***/ })
/******/ ]);
//# sourceMappingURL=dashboard.js.map